{"filename":"sidecar.md","filepath":"docs/usage/guides/bundler","hash":42,"frontmatter":{"title":"Sidecar (Embedding External Binaries)","sidebar_label":"Sidecar"},"text":"\nimport Alert from '@theme/Alert'\n\nYou may need to embed depending binaries in order to make your application work or to prevent users having to install additional dependencies (e.g. Node.js, Python, etc).\n\nTo bundle the binaries of your choice, you can add the `externalBin` property to the `tauri > bundle` object in your `tauri.conf.json`.\n\nSee more about tauri.conf.json configuration <a href=\"/docs/api/config#tauri.bundle\">here</a>.\n\n`externalBin` expects a list of strings targeting binaries either with absolute or relative paths.\n\nHere is a sample to illustrate the configuration, this is not a complete `tauri.conf.json` file:\n\n```json\n{\n  \"tauri\": {\n    \"bundle\": {\n      \"externalBin\": [\"/absolute/path/to/app\", \"relative/path/to/binary\", \"bin/python\"]\n    }\n  }\n}\n```\n\nA binary with the same name and a `-$TARGET_TRIPLE` suffix must exist on the specified path. For instance, `\"externalBin\": [\"bin/python\"]` requires a `src-tauri/bin/python-x86_64-unknown-linux-gnu` executable on Linux. You can find the current platform's target triple running the following command:\n\n```bash\nRUSTC_BOOTSTRAP=1 rustc -Z unstable-options --print target-spec-json\n```\n\nHere's a Node.js script to append the target triple to a binary:\n\n```javascript\nconst execa = require('execa')\nconst fs = require('fs')\n\nlet extension = ''\nif (process.platform === 'win32') {\n  extension = '.exe'\n}\n\nasync function main() {\n  const rustInfo = (await execa('rustc', ['-vV'])).stdout\n  const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1]\n  if (!targetTriple) {\n    console.error('Failed to determine platform target triple')\n  }\n  fs.renameSync(\n    `src-tauri/binaries/app${extension}`,\n    `src-tauri/binaries/app-${targetTriple}${extension}`\n  )\n}\n\nmain().catch((e) => {\n  throw e\n})\n\n```\n\n## Running the sidecar binary on JavaScript\n\nOn the JavaScript code, import the `Command` class on the `shell` module and use the `sidecar` static method:\n\n```javascript\nimport { Command } from '@tauri-apps/api/shell'\n// alternatively, use `window.__TAURI__.shell.Command`\n// `my-sidecar` is the value specified on `tauri.conf.json > tauri > bundle > externalBin`\nconst command = Command.sidecar('my-sidecar')\nconst output = await command.execute()\n```\n\n## Running the sidecar binary on Rust\n\nOn the Rust code, import the `Command` struct from the `tauri::api::process` module:\n\n```rust\nlet (mut rx, mut child) = Command::new_sidecar(\"my-sidecar\")\n  .expect(\"failed to create `my-sidecar` binary command\")\n  .spawn()\n  .expect(\"Failed to spawn sidecar\");\n\ntauri::async_runtime::spawn(async move {\n  // read events such as stdout\n  while let Some(event) = rx.recv().await {\n    if let CommandEvent::Stdout(line) = event {\n      window\n        .emit(\"message\", Some(format!(\"'{}'\", line)))\n        .expect(\"failed to emit event\");\n      // write to stdin\n      child.write(\"message from Rust\\n\".as_bytes()).unwrap();\n    }\n  }\n});\n```\n\n## Using Node.js on a sidecar\n\nThe Tauri [sidecar example](https://github.com/tauri-apps/tauri/tree/dev/examples/sidecar) demonstrates how to use the sidecar API to run a Node.js application on Tauri.\nIt compiles the Node.js code using [pkg](https://github.com/vercel/pkg) and uses the scripts above to run it.\n","h1":[],"h2":[{"content":"Running the sidecar binary on JavaScript","type":"text"},{"content":"Running the sidecar binary on Rust","type":"text"},{"content":"Using Node","type":"text"}],"h3":[],"hasCodeBlock":true,"programmingLanguages":["json","bash","javascript","rust"],"otherSymbols":["text","inlineCode","link"]}