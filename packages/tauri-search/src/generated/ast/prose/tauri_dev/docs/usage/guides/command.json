{"filename":"command.md","filepath":"docs/usage/guides","hash":42,"frontmatter":{"title":"Create Rust Commands"},"text":"\nimport Alert from '@theme/Alert'\n\nTauri provides a simple yet powerful \"command\" system for calling Rust functions from your web app. Commands can accept arguments and return values. They can also return errors and be `async`.\n\n## Basic Example\n\nCommands are defined in your `src-tauri/src/main.rs` file. To create a command, just add a function and annotate it with `#[tauri::command]`:\n\n```rust\n#[tauri::command]\nfn my_custom_command() {\n  println!(\"I was invoked from JS!\");\n}\n```\n\nYou will have to provide a list of your commands to the builder function like so:\n\n```rust\n// Also in main.rs\nfn main() {\n  tauri::Builder::default()\n    // This is where you pass in your commands\n    .invoke_handler(tauri::generate_handler![my_custom_command])\n    .run(tauri::generate_context!())\n    .expect(\"failed to run app\");\n}\n```\n\nNow, you can invoke the command from your JS code:\n\n```js\n// With the Tauri API npm package:\nimport { invoke } from '@tauri-apps/api/tauri'\n// With the Tauri global script, enabled when `tauri.conf.json > build > withGlobalTauri` is set to true:\nconst invoke = window.__TAURI__.invoke\n\n// Invoke the command\ninvoke('my_custom_command')\n```\n\n## Passing Arguments\n\nYour command handlers can take arguments:\n\n```rust\n#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n  println!(\"I was invoked from JS, with this message: {}\", invoke_message);\n}\n```\n\nArguments should be passed as a JSON object with camelCase keys:\n\n```js\ninvoke('my_custom_command', { invokeMessage: 'Hello!' })\n```\n\nArguments can be of any type, as long as they implement [serde::Deserialize](https://serde.rs/derive.html).\n\n## Returning Data\n\nCommand handlers can return data as well:\n\n```rust\n#[tauri::command]\nfn my_custom_command() -> String {\n  \"Hello from Rust!\".into()\n}\n```\n\nThe `invoke` function returns a promise that resolves with the returned value:\n\n```js\ninvoke('my_custom_command').then((message) => console.log(message))\n```\n\nReturned data can be of any type, as long as it implements [Serde::Serialize](https://serde.rs/derive.html).\n\n## Error Handling\n\nIf your handler could fail and needs to be able to return an error, have the function return a `Result`:\n\n```rust\n#[tauri::command]\nfn my_custom_command() -> Result<String, String> {\n  // If something fails\n  Err(\"This failed!\".into())\n  // If it worked\n  Ok(\"This worked!\".into())\n}\n```\n\nIf the command returns an error, the promise will reject, otherwise it resolves:\n\n```js\ninvoke('my_custom_command')\n  .then((message) => console.log(message))\n  .catch((error) => console.error(error))\n```\n\n## Async Commands\n\n<Alert title=\"Note\">\nAsync commands are executed on a separate thread using the <a href=\"https://tauri.studio/en/docs/api/rust/tauri/async_runtime/fn.spawn\">async runtime</a>.\nCommands without the <i>async</i> keyword are executed on the main thread, unless defined with <i>#[tauri::command(async)]</i>.\n</Alert>\n\nIf your command needs to run asynchronously, simply declare it as `async`:\n\n```rust\n#[tauri::command]\nasync fn my_custom_command() {\n  // Call another async function and wait for it to finish\n  let result = some_async_function().await;\n  println!(\"Result: {}\", result);\n}\n```\n\nSince invoking the command from JS already returns a promise, it works just like any other command:\n\n```js\ninvoke('my_custom_command').then(() => console.log('Completed!'))\n```\n\n## Accessing the Window in Commands\n\nCommands can access the `Window` instance that invoked the message:\n\n```rust\n#[tauri::command]\nasync fn my_custom_command(window: tauri::Window) {\n  println!(\"Window: {}\", window.label());\n}\n```\n\n## Accessing an AppHandle in Commands\n\nCommands can access an `AppHandle` instance:\n\n```rust\n#[tauri::command]\nasync fn my_custom_command(app_handle: tauri::AppHandle) {\n  let app_dir = app_handle.path_resolver().app_dir();\n  use tauri::GlobalShortcutManager;\n  app_handle.global_shortcut_manager().register(\"CTRL + U\", move || {});\n}\n```\n\n## Accessing managed state\n\nTauri can manage state using the `manage` function on `tauri::Builder`.\nThe state can be accessed on a command using `tauri::State`:\n\n```rust\nstruct MyState(String);\n\n#[tauri::command]\nfn my_custom_command(state: tauri::State<MyState>) {\n  assert_eq!(state.0 == \"some state value\", true);\n}\n\nfn main() {\n  tauri::Builder::default()\n    .manage(MyState(\"some state value\".into()))\n    .invoke_handler(tauri::generate_handler![my_custom_command])\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n## Creating Multiple Commands\n\nThe `tauri::generate_handler!` macro takes an array of commands. To register\nmultiple commands, you cannot call invoke_handler multiple times. Only the last\ncall will be used. You must pass each command to a single call of\n`tauri::generate_handler!`.\n\n```rust\n#[tauri::command]\nfn cmd_a() -> String {\n\t\"Command a\"\n}\n#[tauri::command]\nfn cmd_b() -> String {\n\t\"Command b\"\n}\n\nfn main() {\n  tauri::Builder::default()\n    .invoke_handler(tauri::generate_handler![cmd_a, cmd_b])\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n## Complete Example\n\nAny or all of the above features can be combined:\n\n```rust title=main.rs\n// Definition in main.rs\n\nstruct Database;\n\n#[derive(serde::Serialize)]\nstruct CustomResponse {\n  message: String,\n  other_val: usize,\n}\n\nasync fn some_other_function() -> Option<String> {\n  Some(\"response\".into())\n}\n\n#[tauri::command]\nasync fn my_custom_command(\n  window: tauri::Window,\n  number: usize,\n  database: tauri::State<'_, Database>,\n) -> Result<CustomResponse, String> {\n  println!(\"Called from {}\", window.label());\n  let result: Option<String> = some_other_function().await;\n  if let Some(message) = result {\n    Ok(CustomResponse {\n      message,\n      other_val: 42 + number,\n    })\n  } else {\n    Err(\"No result\".into())\n  }\n}\n\nfn main() {\n  tauri::Builder::default()\n    .manage(Database {})\n    .invoke_handler(tauri::generate_handler![my_custom_command])\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n```js\n// Invocation from JS\n\ninvoke('my_custom_command', {\n  number: 42,\n})\n  .then((res) =>\n    console.log(`Message: ${res.message}, Other Val: ${res.other_val}`)\n  )\n  .catch((e) => console.error(e))\n```\n","h1":[],"h2":[{"content":"Basic Example","type":"text"},{"content":"Passing Arguments","type":"text"},{"content":"Returning Data","type":"text"},{"content":"Error Handling","type":"text"},{"content":"Async Commands","type":"text"},{"content":"Accessing the Window in Commands","type":"text"},{"content":"Accessing an AppHandle in Commands","type":"text"},{"content":"Accessing managed state","type":"text"},{"content":"Creating Multiple Commands","type":"text"},{"content":"Complete Example","type":"text"}],"h3":[],"hasCodeBlock":true,"programmingLanguages":["rust","js"],"otherSymbols":["text","inlineCode","link","em"]}