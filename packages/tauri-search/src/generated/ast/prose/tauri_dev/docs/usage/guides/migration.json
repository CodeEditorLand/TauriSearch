{"filename":"migration.md","filepath":"docs/usage/guides","hash":42,"frontmatter":{"title":"Migrating from 0.x"},"text":"\nFirst of all if you still have `tauri` as dependency in your `package.json`\nreplace it with a recent version of `@tauri-apps/cli` (make sure to also change\nthe import path in your JavaScript/TypeScript files, see [JavaScript](#javascript)).\n\nFor example:\n\n```diff\n- \"tauri\": \"^0.14.1\"\n+ \"@tauri-apps/cli\": \"^1.0.0-beta-rc.4\"\n```\n\nNext update your `Cargo.toml`:\n\n- add `tauri-build` as a new build-dependency and remove `winres`, e.g.:\n\n  ```diff\n  + [build-dependencies]\n  + tauri-build = { version = \"1.0.0-beta-rc.0\" }\n\n  - [target.\"cfg(windows)\".build-dependencies]\n  - winres = \"0.1\"\n  ```\n\n- update the version of `tauri` to e.g. `1.0.0-beta-rc.4`\n- remove all old features of the `tauri` dependency\n- remove all features, that tauri added and add `custom-protocol` as a new one:\n  \n  ```diff\n  [features]\n  - embedded-server = [ \"tauri/embedded-server\" ]\n  - no-server = [ \"tauri/no-server\" ]\n  + custom-protocol = [ \"tauri/custom-protocol\" ]\n  + default = [ \"custom-protocol\" ]\n  ```\n\nUpdate your `tauri.conf.json` like this:\n\n- remove `ctx`\n- remove the `embeddedServer`\n- rename `osx` to `macOS` and add some fields:\n  - `\"exceptionDomain\": \"\"`\n  - `\"signingIdentity\": null`\n  - `\"entitlements\": null`\n- remove the `exceptionDomain`\n- add a configuration for `windows`:\n  - `\"certificateThumbprint\": null`\n  - `\"digestAlgorithm\": \"sha256\"`\n  - `\"timestampUrl\": \"\"`\n- make the `window` definition into an array and call it `windows`\n- remove `inliner`\n\n> for more information about the config see [here](../../api/config.md)\n\n```diff\n  {\n-   \"ctx\": {},\n    \"tauri\": {\n-     \"embeddedServer\": {\n-       \"active\": true\n-     },\n      \"bundle\": {\n-       \"osx\": {\n+       \"macOS\": {\n          \"frameworks\": [],\n          \"minimumSystemVersion\": \"\",\n-         \"useBootstrapper\": false\n+         \"useBootstrapper\": false,\n+         \"exceptionDomain\": \"\",\n+         \"signingIdentity\": null,\n+         \"entitlements\": null\n        },\n-       \"exceptionDomain\": \"\"\n+       \"windows\": {\n+         \"certificateThumbprint\": null,\n+         \"digestAlgorithm\": \"sha256\",\n+         \"timestampUrl\": \"\"\n+       }\n      },\n+     \"updater\": {\n+       \"active\": false\n+     },\n-     \"window\": {\n+     \"windows\": [\n        {\n          \"title\": \"Calciumdibromid\",\n          \"width\": 800,\n          \"height\": 600,\n          \"resizable\": true,\n          \"fullscreen\": false\n        }\n+     ],\n-     \"inliner\": {\n-       \"active\": true\n-     }\n    }\n  }\n```\n\n## Commands\n\nThe following example is taken from the previous documentation.\n\nIn the new version of Tauri there is no distinction between synchronous and\nasynchronous commands, the only difference in your code is a call of\n`tauri::execute_promise()`, that isn't there in a synchronous command.\n\n### Rust\n\nHere is the complete example code of the \"old\" version:\n\n```rust\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize)]\nstruct DoSomethingPayload {\n  state: String,\n  data: u64,\n}\n\n#[derive(Deserialize)]\n#[serde(tag = \"cmd\", rename_all = \"camelCase\")]\nenum Cmd {\n  DoSomething {\n    count: u64,\n    payload: DoSomethingPayload,\n    callback: String,\n    error: String,\n  },\n}\n\n#[derive(Serialize)]\nstruct Response<'a> {\n  value: u64,\n  message: &'a str,\n}\n\n#[derive(Debug, Clone)]\nstruct CommandError<'a> {\n  message: &'a str,\n}\n\nimpl<'a> CommandError<'a> {\n  fn new(message: &'a str) -> Self {\n    Self { message }\n  }\n}\n\nimpl<'a> std::fmt::Display for CommandError<'a> {\n  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n    write!(f, \"{}\", self.message)\n  }\n}\n\nimpl<'a> std::error::Error for CommandError<'a> {}\n\nfn main() {\n  tauri::AppBuilder::new()\n    .invoke_handler(|_webview, arg| {\n      use Cmd::*;\n      match serde_json::from_str(arg) {\n        Err(e) => Err(e.to_string()),\n        Ok(command) => {\n          match command {\n            DoSomething { count, payload, callback, error } => tauri::execute_promise(\n              _webview,\n              move || {\n                if count > 5 {\n                  let response = Response {\n                    value: 5,\n                    message: \"async response!\",\n                  };\n                  Ok(response)\n                } else {\n                  Err(CommandError::new(\"count should be > 5\").into())\n                }\n              },\n              callback,\n              error,\n            ),\n          }\n          Ok(())\n        }\n      }\n    })\n    .build()\n    .run();\n}\n```\n\nComplete the following steps to migrate your code:\n\n- create a new function for every `Cmd` enum variant\n- wrap the new function with the `#[tauri::command]` macro\n- use the fields of the enum as arguments (`callback` and `error` can be deleted)\n- as function body use the code inside the `match` block of the enum variant\n- add a return type\n- rename `AppBuilder` to `Builder` in `main()`\n- replace the big `invoke_handler` with the new syntax\n\nThe old example code should look like this now:\n\n```rust\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize)]\nstruct DoSomethingPayload {\n  state: String,\n  data: u64,\n}\n\n#[derive(Serialize)]\nstruct Response<'a> {\n  value: u64,\n  message: &'a str,\n}\n\n#[derive(Debug, Clone, Serialize)]\nstruct CommandError<'a> {\n  message: &'a str,\n}\n\nimpl<'a> CommandError<'a> {\n  fn new(message: &'a str) -> Self {\n    Self { message }\n  }\n}\n\nimpl<'a> std::fmt::Display for CommandError<'a> {\n  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n    write!(f, \"{}\", self.message)\n  }\n}\n\nimpl<'a> std::error::Error for CommandError<'a> {}\n\n#[tauri::command]\nfn do_something(count: u64, payload: DoSomethingPayload) -> Result<Response, CommandError> {\n  if count > 5 {\n    let response = Response {\n      value: 5,\n      message: \"async response!\",\n    };\n    Ok(response)\n  } else {\n    Err(CommandError::new(\"count should be > 5\").into())\n  }\n}\n\nfn main() {\n  tauri::Builder::new()\n    .invoke_handler(tauri::generate_handler![do_something])\n    .run(tauri::generate_context!());\n}\n```\n\n### JavaScript\n\nLike mentioned above there is also no distinction between synchronous and\nasynchronous commands in JavaScript.  \nYou only have to use `invoke` and optionally use the results.\n\nHere is an example of the \"old\" code:\n\n```js\ninvoke({\n  cmd: 'doSomething',\n  count: 5,\n  payload: {\n    state: 'some string data',\n    data: 17\n  }\n});\n\npromisified({\n  cmd: 'doSomething',\n  count: 5,\n  payload: {\n    state: 'some string data',\n    data: 17\n  }\n}).then(response => {\n  console.log(response);\n}).catch(error => {\n  console.error(error);\n});\n```\n\nComplete the following steps to migrate your code:\n\n- replace all `promisified`-calls with `invoke`-calls\n- extract the `cmd` attribute of the argument object as first parameter  \n  (you may have to rename it to `snake_case` as the `cmd` parameter is now the\n  name of the function in Rust)\n- if you import parts of the tauri-api with `tauri/api/*` replace it with `@tauri-apps/api/*`, e.g.:\n\n  ```diff\n  - import { invoke } from 'tauri/api/tauri';\n  + import { invoke } from '@tauri-apps/api/tauri';\n  ```\n\nThe old example code should look like this now:\n\n```js\ninvoke(\n  'do_something',\n  {\n    count: 5,\n    payload: {\n      state: 'some string data',\n      data: 17\n    }\n  }\n);\n\ninvoke(\n  'do_something',\n  {\n    count: 5,\n    payload: {\n      state: 'some string data',\n      data: 17\n    }\n  }\n).then(response => {\n  console.log(response);\n}).catch(error => {\n  console.error(error);\n});\n```\n\nFor more information on commands read [Create Rust Commands](command.md).\n","h1":[],"h2":[{"content":"Commands","type":"text"}],"h3":[{"content":"Rust","type":"text"},{"content":"JavaScript","type":"text"}],"hasCodeBlock":true,"programmingLanguages":["diff","rust","js"],"otherSymbols":["text","inlineCode","link","list","blockQuote","br"]}