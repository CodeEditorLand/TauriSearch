[{"id":"prose_docs_api_cli_md","title":"CLI","sections":["info","init","dev","deps","build","icon","version","CLI usage"],"subSections":[],"code":[null,"sh"],"text":"\nimport Command from '@theme/Command'\nimport Alert from '@theme/Alert'\n\n\nThe tauri.js cli is composed in TypeScript and published as JavaScript. \n\n## `info`\n\n<Command name=\"info\" />\n\n```\n  Description\n    Returns the known state of tauri dependencies and configuration\n```\n\nIt shows a concise list of information about the environment, Rust, Node.js and their versions as well as some relevant configurations.\n\n<Alert title=\"Note\" icon=\"info-alt\">\nThis command is pretty helpful when you need to have a quick overview of your application. When requesting some help, it can be useful that you share this report with us.\n</Alert>\n\n## `init`\n\n<Command name=\"init\" />\n\n```\n  Description\n    Inits the Tauri template. If Tauri cannot find the src-tauri/tauri.conf.json\n    it will create one.\n  Usage\n    $ tauri init\n  Options\n    --help, -h        Displays this message\n    --force, -f       Force init to overwrite [conf|template|all]\n    --log, -l         Logging [boolean]\n    --directory, -d   Set target directory for init\n    --tauriPath, -t   Path of the Tauri project to use (relative to the cwd)\n```\n\n## `dev`\n\n<Command name=\"dev\" />\n\n```\n  Description\n    Tauri dev.\n  Usage\n    $ tauri dev\n  Options\n    --help, -h     Displays this message\n```\n\nThis command will open the WebView in development mode. It makes use of the `build.devPath` property from your `src-tauri/tauri.conf.json` file.\n\nIf you have entered a command to the `build.beforeDevCommand` property, this one will be executed before the `dev` command.\n\n<a href=\"/docs/api/config#build\">See more about the configuration.</a><br/><br/>\n\n<Alert title=\"Troubleshooting\" type=\"warning\" icon=\"alert\">\n\nIf you're not using `build.beforeDevCommand`, make sure your `build.devPath` is correct and, if using a development server, that it's started before using this command.\n</Alert>\n\n## `deps`\n\n<Command name=\"deps update\" />\n\n```sh\n  Description\n    Tauri dependency management script\n  Usage\n    $ tauri deps [install|update]\n```\n\n\n## `build`\n\n<Command name=\"build\" />\n\n```\n  Description\n    Tauri build.\n  Usage\n    $ tauri build\n  Options\n    --help, -h     Displays this message\n    --debug, -d    Build a tauri app with debugging\n```\n\nThis command will bundle your application, either in production mode or debug mode if you used the `--debug` flag. It makes use of the `build.distDir` property from your `src-tauri/tauri.conf.json` file.\n\nIf you have entered a command to the `build.beforeBuildCommand` property, this one will be executed before the `build` command.\n\n<a href=\"/docs/api/config#build\">See more about the configuration.</a>\n\n## `icon`\n\n<Command name=\"icon\" />\n\n```\n  Description\n    Create all the icons you need for your Tauri app.\n\n  Usage\n    $ tauri icon\n\n  Options\n    --help, -h          Displays this message\n    --log, -l            Logging [boolean]\n    --icon, -i           Source icon (png, 1240x1240 with transparency)\n    --target, -t         Target folder (default: 'src-tauri/icons')\n    --compression, -c    Compression type [pngquant|optipng|zopfli]\n```\n\nThis command will generate a set of icons, based on the source icon you've entered.\n\n## `version`\n\n<Command name=\"--version\" />\n\n```\n  Description\n    Returns the current version of tauri\n```\n\nThis command will show the current version of Tauri.\n\n## CLI usage\n\nSee more about the usage through this [complete guide](/docs/usage/development/integration).\n\n","url":"https://tauri.studio/docs/docs/api/cli"},{"id":"prose_docs_api_config_md","title":"Configuration","sections":["build","package","tauri"],"subSections":[],"code":[],"text":"\nimport Properties from '@theme/Properties'\nimport Array from '@theme/Array'\nimport Alert from '@theme/Alert'\n\nThe `tauri.conf.json` is a file generated by the `tauri init` command (see <a href=\"/docs/api/cli#tauri-init\">here</a>) that lives in your Tauri application source directory (src-tauri).\n\nOnce generated, you may modify it at will to customize your Tauri application.\n\n# Platform-specific configuration\n\nIn addition to the JSON defined on the `tauri.conf.json` file, Tauri reads a platform-specific configuration on `tauri.linux.conf.json`, `tauri.windows.conf.json` and `tauri.macos.conf.json` and merges it with the main `tauri.conf.json` configuration.\n\n# Configuration structure\n\n`tauri.conf.json` is composed of the following properties:\n\n## `build`\n\n<Properties anchorRoot=\"build\" rows={[\n{property: \"distDir\", type: \"string\", description: `The path to the production-ready webpage/webapp directory (either absolute or relative to tauri.conf.json) that will be bundled by Tauri.\n\n<div class=\"alert alert--info\" role=\"alert\" style=\"margin-top: 10px;\">\n  The target directory <em>must</em> contain an index.html file.\n</div>`},\n{property: \"devPath\", type: \"string\", description: `Can be a path to a folder (either absolute or relative to tauri.conf.json) or a URL (like a live reload server).`},\n{property: \"beforeDevCommand\", optional: true, type: \"string\", description: `A command to run before starting Tauri in dev mode.`},\n{property: \"beforeBuildCommand\", optional: true, type: \"string\", description: `A command to run before starting Tauri in build mode.`},\n{property: \"withGlobalTauri\", optional: true, type: \"boolean\", description: \"Enables the API injection to the window.__TAURI__ object. Useful if you're using Vanilla JS instead of importing the API using Rollup or Webpack. Reduces the command security since any external code can access it, so be careful with XSS attacks.\"}\n]}/>\n\n```js title=Example\n\"build\": {\n  \"distDir\": \"../dist\",\n  \"devPath\": \"http://localhost:4000\",\n  \"beforeDevCommand\": \"npm run dev\",\n  \"beforeBuildCommand\": \"npm run build\",\n  \"withGlobalTauri\": false\n}\n```\n\n## `package`\n\n<Properties anchorRoot=\"package\" rows={[\n  { property: \"productName\", optional: true, type: \"string\", description: `Application name. The binary name is converted to snake-case on Linux.` },\n  { property: \"version\", optional: true, type: \"string\", description: `Application version.` }\n]}/>\n\n## `tauri`\n\n<Properties anchorRoot=\"tauri\" rows={[\n  {\n    property: \"cli\", optional: true, type: \"CliConfig\",\n    child: <Properties anchorRoot=\"tauri.cli\"  rows={[\n      { property: \"args\", optional: true, type: \"CliArg[]\", description: `List of args for the command.`, child: <Array type=\"CliArg\" name=\"arg\"><Properties anchorRoot=\"tauri.cli.args\" rows={[\n        { property: \"short\", optional: true, type: \"string\", description: `the short version of the argument, without the preceding hyphen (the \"-\" character).\n        <div class=\"alert alert--info\" role=\"alert\" style=\"margin-top: 10px;\">\n        Any leading hyphen will be stripped, and only the first non hyphen character will be used as the short version.\n      </div>` },\n        { property: \"name\", type: \"string\", description: `The unique argument name.` },\n        { property: \"description\", optional: true, type: \"string\", description: `The argument description which will be shown on the help information. Typically, this is a short (one line) description of the arg.` },\n        { property: \"longDescription\", optional: true, type: \"string\", description: `The argument long description which will be shown on the help information.\n   Typically, this a more detailed (multi-line) message that describes the argument` },\n        { property: \"takesValue\", optional: true, type: \"boolean\", description: `Specifies that the argument takes a value at runtime.\n        <div class=\"alert alert--info\" role=\"alert\" style=\"margin-top: 10px;\">\n          Values for arguments may be specified in any of the following methods:\n          <ul>\n            <li>Using a space such as <code>-o value</code> or <code>--option value</code></li>\n            <li>Using an equals and no space such as <code>-o=value</code> or <code>--option=value</code></li>\n            <li>Use a short and no space such as <code>-ovalue</code></li>\n          </ul>\n        </div>`\n        },\n        { property: \"index\", type: \"number\", optional: true, description: `The positional argument index, starting at 1.\n        <div class=\"alert alert--info\" role=\"alert\" style=\"margin-top: 10px;\">\n          The index refers to position according to other positional argument. It does not define position in the argument list as a whole.\n          When utilized with multiple=true, only the last positional argument may be defined as multiple (i.e. the one with the highest index).\n        </div>`\n        },\n        { property: \"multiple\", optional: true, type: \"boolean\", description: `Specifies that the argument may appear more than once.\n   For flags, this results in the number of occurrences of the flag being recorded. For example <code>-ddd</code> or <code>-d -d -d</code> would count as three occurrences.\n   For options, there is a distinct difference in multiple occurrences vs multiple values. For example, <code>--opt val1 val2</code> is one occurrence, but two values. Whereas <code>--opt val1 --opt val2</code> is two occurrences.` },\n        { property: \"possibleValues\", optional: true, type: \"string[]\", description: `Specifies a list of possible values for this argument. At runtime, the CLI verifies that only one of the specified values was used, or fails with an error message.` },\n        { property: \"minValues\", optional: true, type: \"number\", description: `Specifies the minimum number of values for this argument.\n   For example, if you had a -f &lt;file&gt; argument where you wanted at least 2 \"files\" you would set <code>minValues: 2</code>, and this argument would be satisfied if the user provided, 2 or more values.` },\n        { property: \"maxValues\", optional: true, type: \"number\", description: `Specifies the maximum number of values for this argument.\n   For example, if you had a -f &lt;file&gt; argument where you wanted up to 3 \"files\" you would set <code>max_values: 3</code>, and this argument would be satisfied if the user provided, 1, 2, or 3 values.` },\n        { property: \"required\", optional: true, type: \"boolean\", description: `Sets whether or not the argument is required by default.\n   \"required by default\" means it is required, when no other conflicting rules have been evaluated\n   conflicting rules take precedence over being required.` },\n        { property: \"requiredUnless\", optional: true, type: \"string\", description: `Sets an arg that overrides this arg's required setting.<br/>\n   i.e. this arg will be required unless this other argument is present.` },\n        { property: \"requiredUnlessAll\", optional: true, type: \"string[]\", description: `Sets args that override this arg's required setting.<br/>\n   i.e. this arg will be required unless all these other arguments are present.` },\n        { property: \"requiredUnlessOne\", optional: true, type: \"string[]\", description: `Sets args that override this arg's required setting.<br/>\n   i.e. this arg will be required unless at least one of these other arguments are present.` },\n        { property: \"conflictsWith\", optional: true, type: \"string\", description: `Sets a conflicting argument by name\n   i.e. when using this argument, the following argument can't be present and vice versa.` },\n        { property: \"conflictsWithAll\", optional: true, type: \"string\", description: `The same as <code>\"conflictsWith\"</code> but allows specifying multiple two-way conflicts per argument.` },\n        { property: \"requires\", optional: true, type: \"string\", description: `Sets an argument by name that is required when this one is present.<br/>\n   i.e. when using this argument, the following argument must be present.` },\n        { property: \"requiresAll\", optional: true, type: \"string[]\", description: `Sets multiple arguments by names that are required when this one is present.<br/>\n   i.e. when using this argument, the following arguments must be present.` },\n        { property: \"requiresIf\", optional: true, type: \"[string, string]\", description: `Allows a conditional requirement with the signature <code>[arg: string, value: string]</code>.\n        <div class=\"alert alert--info\" role=\"alert\" style=\"margin-top: 10px;\">\n          The requirement will only become valid if <code>\"arg\"</code>'s value equals <code>\\${value}</code>.\n        </div>\n   ` },\n        { property: \"requiredIf\", optional: true, type: \"[string, string]\", description: `Allows specifying that an argument is required conditionally with the signature <code>[arg: string, value: string]</code>.\n        <div class=\"alert alert--info\" role=\"alert\" style=\"margin-top: 10px;\">\n          The requirement will only become valid if the <code>\"arg\"</code>'s value equals <code>\\${value}</code>.\n        </div>\n   ` },\n        { property: \"requireEquals\", optional: true, type: \"boolean\", description: `Requires that options use the <code>--option=val</code> syntax.<br/>\n   i.e. an equals between the option and associated value.` },\n      ]} /></Array> },\n      { property: \"description\", optional: true, type: \"string\", description: `Command description which will be shown on the help information.` },\n      { property: \"longDescription\", optional: true, type: \"string\", description: `Command long description which will be shown on the help information.` },\n      { property: \"beforeHelp\", optional: true, type: \"string\", description: `Adds additional help information to be displayed in addition to auto-generated help.<br/>\n      This information is displayed before the auto-generated help information.<br/>\n      This is often used for header information.` },\n      { property: \"afterHelp\", optional: true, type: \"string\", description: `Adds additional help information to be displayed in addition to auto-generated help.<br/>\n      This information is displayed after the auto-generated help information.<br/>\n      This is often used to describe how to use the arguments, or caveats to be noted.` },\n      { property: \"subcommands\", optional: true, type: \"{ [name: string]: CliConfig }\", description: `List of subcommands of this command.<br/>\n      Subcommands are effectively sub-apps, because they can contain their own arguments, subcommands, usage, etc.<br/>\n      They also function just like the app command, in that they get their own auto generated help and usage.` },\n    ]} />\n  },\n  {\n    property: \"bundle\", type: \"object\",\n    child: <Properties anchorRoot=\"tauri.bundle\" rows={[\n      { property: \"active\", optional: true, type: \"boolean\", description: `Whether we should build your app with tauri-bundler or plain <code>cargo build</code>.` },\n      { property: \"targets\", optional: true, type: \"string | string[]\", description: `An array of the bundles you want to generate; e.g. [\"deb\", \"app\", \"msi\", \"appimage\", \"dmg\"] or the string 'all' to make every supported bundle. By default we bundle everything your target supports (app/dmg on mac, deb/appimage on linux, msi on windows).` },\n      { property: \"identifier\", type: \"string\", description: `A string that uniquely identifies your application, in reverse-DNS form (for example, \"com.example.appname\" or \"io.github.username.project\"). For OS X and iOS, this is used as the bundle's CFBundleIdentifier value; for Windows, this is hashed to create an application GUID.` },\n      { property: \"icon\", optional: true, type: \"string[]\", description: `A list of (relative to src-tauri) icon paths to use for your application bundle.` },\n      { property: \"resources\", optional: true, type: \"string[]\", description: `A list of files or directories which will be copied to the resources section of the bundle. Globs are supported.` },\n      { property: \"externalBin\", optional: true, type: \"string[]\", description: `A list of—either absolute or relative—paths to binaries to embed with your application.\n      <div class=\"alert alert--info\" role=\"alert\" style=\"margin-top: 10px;\">\n        Note that Tauri will look for system-specific binaries following the pattern \"binary-name{-target-triple}{.system-extension}\". <br/>\n        E.g. you typed \"my-binary\":\n        <ul>\n          <li>\"my-binary-x86_64-pc-windows-msvc.exe\" for Windows</li>\n          <li>\"my-binary-x86_64-apple-darwin\" for macOS</li>\n          <li>\"my-binary-x86_64-unknown-linux-gnu\" for Linux</li>\n        </ul>\n        so don't forget to provide binaries for <strong>all targeted platforms</strong>.\n      </div>` },\n      { property: \"copyright\", optional: true, type: \"string\", description: `A copyright string associated with your application.` },\n      { property: \"category\", optional: true, type: \"string\", description: `What kind of application this is.\n        Should be one among the following list: <br/>\n        Business, DeveloperTool, Education, Entertainment, Finance, Game, ActionGame, AdventureGame, ArcadeGame, BoardGame, CardGame, CasinoGame, DiceGame, EducationalGame, FamilyGame, KidsGame, MusicGame, PuzzleGame, RacingGame, RolePlayingGame, SimulationGame, SportsGame, StrategyGame, TriviaGame, WordGame, GraphicsAndDesign, HealthcareAndFitness, Lifestyle, Medical, Music, News, Photography, Productivity, Reference, SocialNetworking, Sports, Travel, Utility, Video, Weather.\n      ` },\n      { property: \"shortDescription\", optional: true, type: \"string\", description: `A short description of your application.` },\n      { property: \"longDescription\", optional: true, type: \"string\", description: `A longer, multi-line description of the application.` },\n      { property: \"deb\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.bundle.deb\" rows={[\n        { property: \"depends\", optional: true, type: \"string[]\", description: `The list of deb dependencies your application relies on.` },\n        { property: \"useBootstrapper\", optional: true, type: \"boolean\", description: `Enable the <a href=\"/en/docs/usage/guides/bundler/debian#bootstrapper\">boostrapper script</a>.` },\n        { property: \"files\", optional: true, type: \"{ [path: string]: string }\", description: `The files to include on the package. See <a href=\"/en/docs/usage/guides/bundler/debian#custom-files\">the debian guide</a>.` }]} />\n      },\n      { property: \"windows\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.bundle.windows\" rows={[\n        { property: \"digestAlgorithm\", optional: true, type: \"string\", description: `Specifies the file digest algorithm to use for creating file signatures. Required for code signing. SHA-256 is recommended.` },\n        { property: \"certificateThumbprint\", optional: true, type: \"string[]\", description: `Specifies the SHA1 hash of the signing certificate.` },\n        { property: \"timestampUrl\", optional: true, type: \"string[]\", description: `Server to use during timestamping.` },\n        { property: \"wix\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.bundle.windows.wix\" rows={[\n          { property: \"language\", optional: true, type: \"string\", description: `The installer language. See https://docs.microsoft.com/en-us/windows/win32/msi/localizing-the-error-and-actiontext-tables.` },\n          { property: \"template\", optional: true, type: \"string\", description: `A custom .wxs template to use.` },\n          { property: \"fragmentPaths\", optional: true, type: \"string[]\", description: `A list of paths to .wxs files with WiX fragments to use.` },\n          { property: \"componentGroupRefs\", optional: true, type: \"string[]\", description: `The ComponentGroup element ids you want to reference from the fragments.` },\n          { property: \"componentRefs\", optional: true, type: \"string[]\", description: `The Component element ids you want to reference from the fragments.` },\n          { property: \"featureGroupRefs\", optional: true, type: \"string[]\", description: `The FeatureGroup element ids you want to reference from the fragments.` },\n          { property: \"featureRefs\", optional: true, type: \"string[]\", description: `The Feature element ids you want to reference from the fragments.` },\n          { property: \"mergeRefs\", optional: true, type: \"string[]\", description: `The Merge element ids you want to reference from the fragments.` },\n          { property: \"skipWebviewInstall\", optional: true, type: \"boolean\", description: `Disables the Webview2 runtime installation after app install.` },\n          { property: \"license\", optional: true, type: \"string\", description: `The path to the license file to render on the installer. Must be an RTF file, so if a different extension is provided, we convert it to the RTF format.` },\n          { property: \"bannerPath\", optional: true, type: \"string\", description: `Path to a bitmap file to use as the installation user interface banner. This bitmap will appear at the top of all but the first page of the installer. The required dimensions are 493px × 58px.` },\n          { property: \"dialogImagePath\", optional: true, type: \"string\", description: `Path to a bitmap file to use on the installation user interface dialogs. It is used on the welcome and completion dialogs. The required dimensions are 493px × 312px.` }]} />\n        }\n        ]} />\n      },\n      { property: \"macOS\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.bundle.macOS\" rows={[\n        { property: \"frameworks\", optional: true, type: \"string[]\", description: `A list of strings indicating any macOS X frameworks that need to be bundled with the application. If a name is used, \".framework\" must be omitted and it will look for standard install locations. You may also use a path to a specific framework.` },\n        { property: \"minimumSystemVersion\", optional: true, type: \"string\", description: `A version string indicating the minimum macOS X version that the bundled application supports.` },\n        { property: \"license\", optional: true, type: \"string\", description: `The path to the license file to add to the DMG.` },\n        { property: \"useBootstrapper\", optional: true, type: \"boolean\", description: `Enable the <a href=\"#bootstrapper\">boostrapper script</a>.` },\n        { property: \"exceptionDomain\", optional: true, type: \"string\", description: `Allows your application to communicate with the outside world.\n      <div class=\"alert alert--info\" role=\"alert\" style=\"margin-top: 10px;\">\n        It should be a lowercase, without port and protocol domain name.\n      </div>\n      ` },\n        { property: \"signingIdentity\", optional: true, type: \"string\", description: `Identity to use for code signing.` },\n        { property: \"entitlements\", optional: true, type: \"string\", description: `Path to the entitlements file.` },\n      ]} /> },\n    ]} />\n  },\n  {\n    property: \"allowlist\", type: \"object\",\n    child: <Properties anchorRoot=\"tauri.allowlist\" rows={[\n      { property: \"all\", type: \"boolean\", description: `Use this flag to enable all API features.` },\n      {\n        property: \"fs\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.allowlist.fs\" rows={[\n          { property: \"all\", type: \"boolean\", description: `Use this flag to enable all file system API features.` },\n          { property: \"readTextFile\", optional: true, type: \"boolean\", description: `Read text file from local filesystem.` },\n          { property: \"readBinaryFile\", optional: true, type: \"boolean\", description: `Read binary file from local filesystem.` },\n          { property: \"writeFile\", optional: true, type: \"boolean\", description: `Write text file to local filesystem.` },\n          { property: \"writeBinaryFile\", optional: true, type: \"boolean\", description: `Write binary file to local filesystem.` },\n          { property: \"readDir\", optional: true, type: \"boolean\", description: `Read directory from local filesystem.` },\n          { property: \"copyFile\", optional: true, type: \"boolean\", description: `Copy file from local filesystem.` },\n          { property: \"createDir\", optional: true, type: \"boolean\", description: `Create directory from local filesystem.` },\n          { property: \"removeDir\", optional: true, type: \"boolean\", description: `Remove directory from local filesystem.` },\n          { property: \"removeFile\", optional: true, type: \"boolean\", description: `Remove file from local filesystem.` },\n          { property: \"renameFile\", optional: true, type: \"boolean\", description: `Rename file from local filesystem.` },\n        ]}/>\n      },\n      {\n        property: \"window\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.allowlist.window\" rows={[\n          { property: \"all\", type: \"boolean\", description: `Use this flag to enable all window API features.` },\n          { property: \"create\", optional: true, type: \"boolean\", description: `Allows dynamic window creation.` },\n        ]}/>\n      },\n      {\n        property: \"shell\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.allowlist.shell\" rows={[\n          { property: \"all\", type: \"boolean\", description: `Use this flag to enable all shell API features.` },\n          { property: \"execute\", optional: true, type: \"boolean\", description: `Enable binary execution.` },\n          { property: \"open\", optional: true, type: \"boolean\", description: `Open URL with the user's default application.` },\n        ]}/>\n      },\n      {\n        property: \"dialog\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.allowlist.dialog\" rows={[\n          { property: \"all\", type: \"boolean\", description: `Use this flag to enable all dialog API features.` },\n          { property: \"open\", optional: true, type: \"boolean\", description: `Open dialog window to pick files.` },\n          { property: \"save\", optional: true, type: \"boolean\", description: `Open dialog window to pick where to save files.` },\n        ]}/>\n      },\n      {\n        property: \"http\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.allowlist.http\" rows={[\n          { property: \"all\", type: \"boolean\", description: `Use this flag to enable all HTTP API features.` },\n          { property: \"request\", optional: true, type: \"boolean\", description: `Allows making HTTP requests.` },\n        ]}/>\n      },\n      {\n        property: \"notification\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.allowlist.notification\" rows={[\n          { property: \"all\", type: \"boolean\", description: `Use this flag to enable all notification API features.` },\n        ]}/>\n      },\n      {\n        property: \"globalShortcut\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.allowlist.globalShortcut\" rows={[\n          { property: \"all\", type: \"boolean\", description: `Use this flag to enable all global shortcut API features.` },\n        ]}/>\n      },\n      {\n        property: \"os\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.allowlist.os\" rows={[\n          { property: \"all\", type: \"boolean\", description: `Use this flag to enable all OS API features.` },\n        ]}/>\n      },\n      {\n        property: \"path\", optional: true, type: \"object\", child: <Properties anchorRoot=\"tauri.allowlist.path\" rows={[\n          { property: \"all\", type: \"boolean\", description: `Use this flag to enable all path API features.` },\n        ]}/>\n      },\n    ]} />\n  },\n  {\n    property: \"windows\", type: \"WindowConfig[]\",\n    child: <Array type=\"WindowConfig\" name=\"window\">\n      <Properties anchorRoot=\"tauri.windows\" rows={[\n        { property: \"label\", type: \"string\", description: `Window id to reference on the codebase.` },\n        { property: \"url\", type: \"string\", description: `URL to load on the webview.` },\n        { property: \"fileDropEnabled\", type: \"boolean\", description: `Whether the file drop handler is enabled or not on the webview. Disabling it is required to use drag and drop on the frontend on Windows.` },\n        { property: \"center\", type: \"boolean\", description: `Show window in the center of the screen.` },\n        { property: \"x\", type: \"number\", description: `The horizontal position of the window's top left corner.` },\n        { property: \"y\", type: \"number\", description: `The vertical position of the window's top left corner.` },\n        { property: \"width\", optional: true, type: \"number\", description: `Initial window width.` },\n        { property: \"height\", optional: true, type: \"number\", description: `Initial window height.` },\n        { property: \"minWidth\", type: \"number\", description: `The minimum window width.` },\n        { property: \"minHeight\", type: \"number\", description: `The minimum window height.` },\n        { property: \"maxWidth\", type: \"number\", description: `The maximum window width.` },\n        { property: \"maxHeight\", type: \"number\", description: `The maximum window height.` },\n        { property: \"resizable\", optional: true, type: \"boolean\", description: `Whether the window is resizable or not..` },\n        { property: \"title\", type: \"string\", description: `Window title.` },\n        { property: \"fullscreen\", optional: true, type: \"boolean\", description: `Whether the window starts as fullscreen or not.` },\n        { property: \"focus\", optional: true, type: \"boolean\", description: `Whether the window will be initially hidden or focused.` },\n        { property: \"transparent\", optional: true, type: \"boolean\", description: `Whether the window is transparent or not.` },\n        { property: \"maximized\", optional: true, type: \"boolean\", description: `Whether the window is maximized or not.` },\n        { property: \"visible\", optional: true, type: \"boolean\", description: `Whether the window is visible or not.` },\n        { property: \"decorations\", optional: true, type: \"boolean\", description: `Whether the window should have borders and bars.` },\n        { property: \"alwaysOnTop\", optional: true, type: \"boolean\", description: `Whether the window should always be on top of other windows.` },\n        { property: \"skipTaskbar\", optional: true, type: \"boolean\", description: `Whether or not the window icon should be added to the taskbar.` },\n      ]}/>\n    </Array>\n  },\n  {\n    property: \"security\", type: \"object\",\n    child: <Properties anchorRoot=\"tauri.security\" rows={[\n      { property: \"csp\", optional: true, type: \"string\", description: `The Content Security Policy.\n      <div class=\"alert alert--warning\" role=\"alert\" style=\"margin-top: 10px;\">\n  This is a really important part of the configuration since it helps you ensure your WebView is secured. See more <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\" target=\"_blank\">on Mozilla</a>.\n</div>` },\n    ]} />\n  },\n]} />\n\n<!-- Dirty trick to have an anchor without make it appear in the table of contents -->\n<div id=\"bootstrapper\"></div>\n\n<Alert title=\"bootstrapper script\">\nInstead of launching the app directly, we configure the bundled app to run a script that tries to expose the environment variables to the app; without that you'll have trouble using system CLI apps like Node.js.\n</Alert>\n\n```js title=Example\n\"tauri\": {\n  \"cli\": {\n    \"description\": \"Tauri communication example\",\n    \"longDescription\": null,\n    \"beforeHelp\": null,\n    \"afterHelp\": null,\n    \"args\": [{\n      \"short\": \"c\",\n      \"name\": \"config\",\n      \"takesValue\": true,\n      \"description\": \"Config path\"\n    }, {\n      \"short\": \"t\",\n      \"name\": \"theme\",\n      \"takesValue\": true,\n      \"description\": \"App theme\",\n      \"possibleValues\": [\"light\", \"dark\", \"system\"]\n    }, {\n      \"short\": \"v\",\n      \"name\": \"verbose\",\n      \"multipleOccurrences\": true,\n      \"description\": \"Verbosity level\"\n    }],\n    \"subcommands\": {\n      \"update\": {\n        \"description\": \"Updates the app\",\n        \"longDescription\": null,\n        \"beforeHelp\": null,\n        \"afterHelp\": null,\n        \"args\": [{\n          \"short\": \"b\",\n          \"name\": \"background\",\n          \"description\": \"Update in background\"\n        }],\n        \"subcommands\": null\n      }\n    }\n  },\n  \"bundle\": {\n    \"active\": true,\n    \"targets\": [\"deb\"],\n    \"identifier\": \"com.tauri.dev\",\n    \"icon\": [\"icons/32x32.png\", \"icons/128x128.png\", \"icons/128x128@2x.png\", \"icons/icon.icns\", \"icons/icon.ico\"],\n    \"resources\": [],\n    \"externalBin\": [],\n    \"copyright\": \"\",\n    \"category\": \"DeveloperTool\",\n    \"shortDescription\": \"\",\n    \"longDescription\": \"\",\n    \"deb\": {\n      \"depends\": []\n    },\n    \"macOS\": {\n      \"frameworks\": [],\n      \"minimumSystemVersion\": \"\",\n      \"exceptionDomain\": \"\"\n    }\n  },\n  \"allowlist\": {\n    \"all\": true\n  },\n  \"windows\": [{\n    \"title\": \"Tauri App\",\n    \"width\": 800,\n    \"height\": 600,\n    \"resizable\": true,\n    \"fullscreen\": false\n  }],\n  \"security\": {\n    \"csp\": \"default-src blob: data: filesystem: ws: wss: http: https: tauri: 'unsafe-eval' 'unsafe-inline' 'self'\"\n  }\n}\n```\n","url":"https://tauri.studio/docs/docs/api/config"},{"id":"prose_docs_getting_started_intro_md","title":"Introduction","sections":["Steps"],"subSections":["Setting up Your Environment"],"code":[],"text":"\nimport OSList from '@theme/OSList'\n\nWelcome to Tauri!\n\nTauri is a polyglot and generic system that is very composable and allows engineers to make a wide variety of applications. It is used for building applications for Desktop Computers using a combination of [Rust](https://www.rust-lang.org/) tools and HTML rendered in a Webview. Apps built with Tauri can ship with any number of pieces of an optional JS API / Rust API so that webviews can control the system via message passing.\n\nAnything that can be displayed on a website, can be displayed in a Tauri webview app!\n\nDevelopers are free to build the web front-end displayed in a Webview through Tauri with any web frameworks of their choice!\n**Developers can even extend the default API** with their own functionality and bridge the Webview and Rust-based backend easily!\n\nThe Architecture is more fully described in [Architecture](https://github.com/tauri-apps/tauri/blob/dev/ARCHITECTURE.md).\n\nThis guide will help you create your first Tauri app. It should only take about 10 minutes, although it could take longer if you have a slower internet connection.\n\nIf you find an error or something unclear, or would like to propose an improvement, you have several options:\n\n1. Open an issue on our [Github Repo](https://github.com/tauri-apps/tauri-docs)\n2. Visit our [Discord server](https://discord.gg/tauri) and raise your concern\n3. Request to join the education working group on Discord to gain access to its discussion channel\n\n## Steps\n\n1. Install and configure system prerequisites\n2. Create a web app with your frontend framework of choice\n3. Use the Tauri CLI to setup Tauri in your app\n4. Write native Rust code to add functionality or improve performance (totally optional)\n5. Use `tauri dev` to develop your app with features like hot module reloading and webview devtools\n6. Use `tauri build` to package your app into a tiny installer\n\n### Setting up Your Environment\n\nBefore creating an app, you'll have to install and configure some developer tools. This guide assumes that you know what the command line is, how to install packages on your operating system, and generally know your way around the development side of computing.\n\nFollow the platform-specific guides to get started:\n\n<OSList content={{\n    linux: { title: 'Linux Setup', link: '/docs/getting-started/setup-linux'},\n    macos: { title: 'macOS Setup', link: '/docs/getting-started/setup-macos'},\n    windows: { title: 'Windows Setup', link: '/docs/getting-started/setup-windows'}\n}} />\n\nAfter that, you'll be ready to [add Tauri to your project!](/docs/usage/development/integration)\n","url":"https://tauri.studio/docs/docs/getting-started/intro"},{"id":"prose_docs_getting_started_setup_linux_md","title":"Setup for Linux","sections":["1","2","3","4","Continue"],"subSections":["Optional dependencies","Node","Optional Node","WSL Version 1","WSL Version 2"],"code":["sh","bash"],"text":"\nimport Alert from '@theme/Alert'\nimport Icon from '@theme/Icon'\nimport { Intro } from '@theme/SetupDocs'\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Intro />\n\n## 1. System Dependencies&nbsp;<Icon title=\"alert\" color=\"danger\"/>\n\n<Tabs\ndefaultValue=\"debian\"\nvalues={[\n{label: 'Debian', value: 'debian'},\n{label: 'Arch', value: 'arch'},\n{label: 'Fedora', value: 'fedora'},\n]}>\n<TabItem value=\"debian\">\n\n```sh\n$ sudo apt update && sudo apt install libwebkit2gtk-4.0-dev \\\n    build-essential \\\n    curl \\\n    wget \\\n    libssl-dev \\\n    libgtk-3-dev \\\n    libappindicator3-dev \\\n    patchelf \\\n    librsvg2-dev\n```\n\n</TabItem>\n<TabItem value=\"arch\">\n\n```sh\n$ sudo pacman -Syy && sudo pacman -S  webkit2gtk \\\n    base-devel \\\n    curl \\\n    wget \\\n    openssl \\\n    appmenu-gtk-module \\\n    gtk3 \\\n    libappindicator-gtk3 \\\n    patchelf \\\n    librsvg \\\n    libvips\n```\n\n</TabItem>\n<TabItem value=\"fedora\">\n\n```sh\n$ sudo dnf check-update && sudo dnf install webkit2gtk3-devel.x86_64 \\\n    openssl-devel \\\n    curl \\\n    wget \\\n    libappindicator-gtk3 \\ #\n    patchelf \\\n    librsvg2-devel \\\n    && sudo dnf group install \"C Development Tools and Libraries\"\n```\n\n</TabItem>\n</Tabs>\n\n### Optional dependencies:\n\n- `libappindicator`: needed to use the system tray feature.\n- `patchelf` and `librsvg`: needed to bundle `AppImage`.\n\n## 2. Node.js Runtime and Package Manager&nbsp;<Icon title=\"control-skip-forward\" color=\"warning\"/>\n\n### Node.js (npm included)\n\nWe recommend using nvm to manage your Node.js runtime. It allows you to easily switch versions and update Node.js.\n\n```sh\n$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash\n```\n\n<Alert title=\"Note\">\nWe have audited this bash script, and it does what it says it is supposed to do. Nevertheless, before blindly curl-bashing a script, it is always wise to look at it first. Here is the file as a mere <a href=\"https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh\" target=\"_blank\">download link</a>.\n</Alert>\n\nOnce nvm is installed, close and reopen your terminal, then install the latest version of Node.js and npm:\n\n```sh\n$ nvm install node --latest-npm\n$ nvm use node\n```\n\nIf you have any problems with nvm, please consult their <a href=\"https://github.com/nvm-sh/nvm\">project readme</a>.\n\n### Optional Node.js Package Manager\n\nYou may want to use an alternative to npm:\n\n- <a href=\"https://yarnpkg.com/getting-started\" target=\"_blank\">Yarn</a>, is preferred by Tauri's team\n- <a href=\"https://pnpm.js.org/en/installation\" target=\"_blank\">pnpm</a>\n\n## 3. Rustc and Cargo Package Manager&nbsp;<Icon title=\"control-skip-forward\" color=\"warning\"/>\n\nThe following command will install <a href=\"https://rustup.rs/\" target=\"_blank\">rustup</a>, the official installer for <a href=\"https://www.rust-lang.org/\" target=\"_blank\">Rust</a>.\n\n```bash\n$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n<Alert title=\"Note\">\nWe have audited this bash script, and it does what it says it is supposed to do. Nevertheless, before blindly curl-bashing a script, it is always wise to look at it first. Here is the file as a mere <a href=\"https://sh.rustup.rs\" target=\"_blank\">download link</a>.\n</Alert>\n\nTo make sure that Rust has been installed successfully, run the following command:\n\n```sh\n$ rustc --version\nlatest update on 2019-12-19, rust version 1.40.0\n```\n\nYou may need to restart your terminal if the command does not work.\n\n## 4. For Windows Subsystem for Linux (WSL) Users&nbsp;<Icon title=\"info-alt\" color=\"info\"/>\n\nIn order to run a graphical application with WSL, you need to download **one** of these X servers: Xming, Cygwin X, and vcXsrv.\nSince vcXsrv has been used internally, it's the one we recommend to install.\n\n### WSL Version 1\n\nOpen the X server and then run `export DISPLAY=:0` in the terminal. You should now be able to run any graphical application via the terminal.\n\n### WSL Version 2\n\nYou'll need to run a command that is slightly more complex than WSL 1: `export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0` and you need to add `-ac` to the X server as an argument. Note: if for some reason this command doesn't work you can use an alternative command such as: `export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | sed 's/.* //g'):0` or you can manually find the Address using `cat /etc/resolve.conf | grep nameserver`.\n\n<Alert type=\"info\" title=\"Note\">\n\nDon't forget that you'll have to use the \"export\" command anytime you want to use a graphical application, for each newly opened terminal.\n\nYou can download some examples to try with `sudo apt-get install x11-apps`. xeyes is always a good one. It can be handy when troubleshooting WSL issues.\n</Alert>\n\n## Continue\n\nNow that you have set up the Linux-specific dependencies for Tauri, learn how to [add Tauri to your project](/docs/usage/development/integration).\n","url":"https://tauri.studio/docs/docs/getting-started/setup-linux"},{"id":"prose_docs_getting_started_setup_macos_md","title":"Setup for macOS","sections":["1","2","3","Continue"],"subSections":["Node","Optional Node"],"code":["sh",null],"text":"\nimport Alert from '@theme/Alert'\nimport { Intro } from '@theme/SetupDocs'\nimport Icon from '@theme/Icon'\n\n<Intro />\n\n## 1. System Dependencies&nbsp;<Icon title=\"alert\" color=\"danger\"/>\n\n\nYou will need to have <a href=\"https://brew.sh/\" target=\"_blank\">Homebrew</a> installed to run the following command.\n\n```sh\n$ brew install gcc\n```\n\nYou will also need to make sure `xcode` is installed.\n\n```sh\n$ xcode-select --install\n```\n\n## 2. Node.js Runtime and Package Manager&nbsp;<Icon title=\"control-skip-forward\" color=\"warning\"/>\n\n### Node.js (npm included)\n\nWe recommend using nvm to manage your Node.js runtime. It allows you to easily switch versions and update Node.js.\n\n```sh\n$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash\n```\n\n<Alert title=\"Note\">\nWe have audited this bash script, and it does what it says it is supposed to do. Nevertheless, before blindly curl-bashing a script, it is always wise to look at it first. Here is the file as a mere <a href=\"https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh\" target=\"_blank\">download link</a>.\n</Alert>\n\nOnce nvm is installed, close and reopen your terminal, then install the latest version of Node.js and npm:\n\n```sh\n$ nvm install node --latest-npm\n$ nvm use node\n```\n\nIf you have any problems with nvm, please consult their <a href=\"https://github.com/nvm-sh/nvm\">project readme</a>.\n\n### Optional Node.js Package Manager\n\nYou may want to use an alternative to npm:\n\n- <a href=\"https://yarnpkg.com/getting-started\" target=\"_blank\">Yarn</a>, is preferred by Tauri's team\n- <a href=\"https://pnpm.js.org/en/installation\" target=\"_blank\">pnpm</a>\n\n## 3. Rustc and Cargo Package Manager&nbsp;<Icon title=\"control-skip-forward\" color=\"warning\"/>\n\nThe following command will install <a href=\"https://rustup.rs/\" target=\"_blank\">rustup</a>, the official installer for <a href=\"https://www.rust-lang.org/\" target=\"_blank\">Rust</a>.\n\n```\n$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n<Alert title=\"Note\">\nWe have audited this bash script, and it does what it says it is supposed to do. Nevertheless, before blindly curl-bashing a script, it is always wise to look at it first. Here is the file as a mere <a href=\"https://sh.rustup.rs\" target=\"_blank\">download link</a>.\n</Alert>\n\nTo make sure that Rust has been installed successfully, run the following command:\n\n```sh\n$ rustc --version\nlatest update on 2019-12-19, rust version 1.40.0\n```\n\nYou may need to restart your terminal if the command does not work.\n\n## Continue\n\nNow that you have set up the macOS-specific dependencies for Tauri, learn how to [add Tauri to your project](/docs/usage/development/integration).\n","url":"https://tauri.studio/docs/docs/getting-started/setup-macos"},{"id":"prose_docs_getting_started_setup_windows_md","title":"Setup for Windows","sections":["1","2","3","4","Continue"],"subSections":["Node","Optional Node"],"code":["powershell"],"text":"\nimport Alert from '@theme/Alert'\nimport Icon from '@theme/Icon'\nimport { Intro } from '@theme/SetupDocs'\n\n<Alert title=\"Note\">\n\nFor those using the Windows Subsystem for Linux (WSL) please refer to our [Linux specific instructions](/docs/getting-started/setup-linux) instead.\n</Alert>\n\n<Intro />\n\n## 1. System Dependencies&nbsp;<Icon title=\"alert\" color=\"danger\"/>\n\nYou'll need to install Microsoft Visual Studio C++ build tools. <a href=\"https://visualstudio.microsoft.com/visual-cpp-build-tools/\" target=\"_blank\">Download the installer here</a>, and then run it. When it asks you what packages you would like to install, select C++ Build Tools.\n\n<Alert title=\"Note\">\nThis is a big download (over 1GB) and takes the most time, so go grab a coffee.\n</Alert>\n\n<Alert type=\"warning\">\nYou may need to uninstall the 2017 version of the build tools if you have them. There are reports of Tauri not working with both the 2017 and 2019 versions installed.\n</Alert>\n\n## 2. Node.js Runtime and Package Manager&nbsp;<Icon title=\"control-skip-forward\" color=\"warning\"/>\n\n### Node.js (npm included)\n\nWe recommend using <a href=\"https://github.com/coreybutler/nvm-windows#installation--upgrades\" target=\"_blank\">nvm-windows</a> to manage your Node.js runtime. It allows you to easily switch versions and update Node.js.\n\nThen run the following from an Administrative PowerShell and press Y when prompted:\n\n```powershell\n# BE SURE YOU ARE IN AN ADMINISTRATIVE PowerShell!\nnvm install latest\nnvm use {{latest}} # Replace with your latest downloaded version\n```\n\nThis will install the most recent version of Node.js with npm.\n\n### Optional Node.js Package Manager\n\nYou may want to use an alternative to npm:\n\n- <a href=\"https://yarnpkg.com/getting-started\" target=\"_blank\">Yarn</a>, is preferred by Tauri's team\n- <a href=\"https://pnpm.js.org/en/installation\" target=\"_blank\">pnpm</a>\n\n## 3. Rustc and Cargo Package Manager&nbsp;<Icon title=\"control-skip-forward\" color=\"warning\"/>\n\nNow you will need to install <a href=\"https://www.rust-lang.org/\" target=\"_blank\">Rust</a>. The easiest way to do this is to use <a href=\"https://rustup.rs/\" target=\"_blank\">rustup</a>, the official installer.\n\n- <a href=\"https://win.rustup.rs/x86_64\" target=\"_blank\">64-bit download link</a>\n- <a href=\"https://win.rustup.rs/i686\" target=\"_blank\">32-bit download link</a>\n\nDownload and install the proper variant for your computer's architecture.\n\n## 4. Install WebView2\n\n<Alert title=\"Note\">\nWebView2 is pre-installed in Windows 11. \n</Alert>\n\nFinally, you will need to install WebView2. The best way to do this is to download and run the Evergreen Bootstrapper from [this page](https://developer.microsoft.com/en-us/microsoft-edge/webview2/#download-section).\n\n## Continue\n\nNow that you have set up the Windows-specific dependencies for Tauri, learn how to [add Tauri to your project](/docs/usage/development/integration).\n","url":"https://tauri.studio/docs/docs/getting-started/setup-windows"},{"id":"prose_docs_usage_contributor_guide_md","title":"Contributor Guide","sections":["Contribution Flow","Hands On Example"],"subSections":["A Note About Contributions to the Rust Libraries"],"code":["sh","json","ini"],"text":"\ntodo: make this friendlier and more complete\n\nTauri is a polyglot system that uses:\n\n- git\n- Node.js\n- Rust\n- GitHub actions\n\nIt can be developed on macOS, Linux and Windows.\n\n## Contribution Flow\n\n1. File an Issue\n2. Fork the Repository\n3. Make Your Changes\n4. Make a PR\n\n### A Note About Contributions to the Rust Libraries\n\nWhen contributing to the Rust libraries `tauri`, `tauri-api`, and `tauri-updater`; you will want to setup an environment for RLS (the Rust Language Server). In the Tauri root directory, there is a `.scripts` folder that contains a set of scripts to automate adding a couple temporary environment variables to your shell/terminal. These environment variables point to directories in the test fixture which will prevent RLS from crashing on compile-time. This is a necessary step for setting up a development environment for Tauri's Rust libraries.\n\n##### _Example Instructions_\n\n1. Navigate to the Tauri Root directory.\n2. Execute a script based on your Operating System from this folder: `.scripts/init_env.bat` for Windows Cmd, `.scripts/init_env.ps1` for Windows Powershell, `. .scripts/init_env.sh` for Linux/macOS bash (note the first `.` in this command).\n3. Open your text editor/IDE from this shell/terminal.\n\n## Hands On Example\n\nLet's make a new example. That's a great way to learn. We are going to assume you are on a nixy type of environment like Linux or macOS and have all of your development dependencies like rust and node already sorted out.\n\n```sh\ngit clone git@github.com:tauri-apps/tauri.git\ncd tauri/cli/tauri.js\nyarn\nmkdir ../../examples/vanillajs && cd \"$_\"\n```\n\n```json\n  \"tauri:source\": \"node ../../../cli/tauri.js/bin/tauri\",\n```\n\n```ini\n  [dependencies.tauri]\n  path = \"../../../../core/tauri\"\n  features = [ \"all-api\" ]\n```\n","url":"https://tauri.studio/docs/docs/usage/contributor-guide"},{"id":"prose_docs_usage_intro_md","title":"Introduction","sections":["A Step Further","Guides"],"subSections":[],"code":[],"text":"\nThis part of the documentation is dedicated to learning how to use Tauri.\n\nTauri provides a [CLI](/docs/api/cli), a Rust API, and a [JavaScript API](/docs/api/js/index) that you can use in your project. Because raw docs can be quite scary to newcomers (especially people who have never played with Rust before), we've created this \"learn by example\" section.\n\nHere you will find guides and techniques to add to your own project in order to fulfill your goals.\n\n## A Step Further\n\n- [Understanding Tauri Patterns](/docs/usage/patterns/about-patterns)\n- [Add Tauri to my existing project](/docs/usage/development/integration)\n- [Tauri Development Cycle](/docs/usage/development/development)\n\n## Guides\n\n- [How to embed custom binaries](/docs/usage/guides/bundler/sidecar)\n- [How to customize app icons](/docs/usage/guides/visual/icons)\n","url":"https://tauri.studio/docs/docs/usage/intro"},{"id":"prose_docs_usage_ci_cd_cross_platform_md","title":"Cross-Platform Compilation","sections":[],"subSections":[],"code":[],"text":"\nHow to use GH Action for Building: a glance at Tauri Action.","url":"https://tauri.studio/docs/docs/usage/ci-cd/cross-platform"},{"id":"prose_docs_usage_ci_cd_signing_macos_md","title":"Signing for macOS","sections":[],"subSections":[],"code":[],"text":"\nSigning for macOS","url":"https://tauri.studio/docs/docs/usage/ci-cd/signing-macos"},{"id":"prose_docs_usage_ci_cd_workflow_md","title":"Workflow","sections":["Continuous Integration","Continuous Deployment"],"subSections":["Introduction to immutable checksum","Next Steps"],"code":["yml"],"text":"\n## Continuous Integration\n\nGithub Actions has two triggers of which we make heavy use: `push` and `pull_request`. Every commit that made to the repo is a `push`. When you open a pull request from a branch (call it `great_feature`) to another branch (our working branch, `dev`), each commit to `great_feature` would possibly trigger both of these events. We can use a filter to focus on the events we care about though. In our workflows, we only PR (pull request) the `dev` and `master` branches. This means that if we filter to only the `dev` and `master` branches on commit, we will only run that workflow when we _merge_ a PR. A merged PR typically only occurs once a day or less so this will be a good fit for the longer running tests, e.g. the smoke tests in our case. Below is how that might look.\n\nUnit tests:\n\n```yml\n# these run fast so we can have them run on any commit\nname: unit tests\non:\n  pull_request:\n  push:\n    branches:\n      - dev\n      - master\n```\n\nSmoke tests:\n\n```yml\n# these run slower so we run only on merges to dev or master branch\nname: smoke tests\non:\n  push:\n    branches:\n      - dev\n      - master\n```\n\nTauri operates off the `dev` branch as default, and merges to `master` for release. With these Github Actions set up, we will run the unit tests on every commit to an open PR (see `pull_request`). When that PR is merged into `dev`, we will run both the unit tests and the smoke tests.\n\n## Continuous Deployment\n\n### Introduction to immutable checksum\n\nIt is not only possible, but trivial to modify release notes and artifacts after it has been published on Github. While there are very valid reasons for doing this, it is not exactly a totally trustworthy method - i.e. you have no guarantee that what you are reading is really reflective of the underlying truth or the tarballs. It is technically possible to change downloads over the wire or in the box or change checksums in targeted attacks. What we are seeking to accomplish is a best case scenario where:\n\n1. Human error is reduced to a minimum, but humans are still integral in the actual release\n2. Machine built assets, changelogs and attached security audits are verifiable with checksums that are published in an immutable, globally available store.\n\nTo this end we fashioned a workflow shown below. As it stands now, we have #3 through #6 implemented. We manually do #2 which then feeds into #3 and kicks off the rest of the automatic workflow.\n\n1. a human pushes to dev through a pull request (can happen any number of times)\n   - pull request includes a changeset file describing the change and required version bump\n2. a pull request is created (or updated) to include the change and version bump\n   - this pull request stays open and will be force pushed until it gets merged (and published)\n   - increase the version number based on changesets\n   - delete all changeset files\n3. a codeowner merges the publish PR to dev (no direct push permissible for anyone)\n   - all tests (unit, e2e, smoke tests) are run on the PR\n   - failures prevent the publish so they must pass before merge\n4. merge to dev triggers release sequence\n   - changes are squashed and a PR is opened against master\n5. when PR to master is merged...\n   - vulnerability audit (crates and yarn) and output saved\n   - checksums and metadata and output saved\n   - packages are published on npm/cargo, tarball/zip created\n   - release is created for each package that had updates (if version isn't changed, build skips the publish steps)\n   - output from audit/checksums is piped into the release body\n   - tarball / zip attached to release\n   - async process to publish to IOTA tangle (feeless) via release tag [note: still have things to resolve here]\n6. release is complete\n   - master has updated code and tagged\n   - GitHub release has tarballs, checksums, and changelog (may have multiple releases if more than one package published) [note: is part of step 2 and is not yet implemented]\n\n### Next Steps\n\nNext steps may include transferring and publishing the built assets to additional places:\n\n1. Tauri's private verdaccio\n2. IPFS\n3. PureOS Gitlab\n4. GitHub Packages\n\nWe can also do some interesting things like signing our releases, including a hash in the release and/or even publishing this information on a blockchain that it can be easily verified. Publishing on the blockchain is another avenue to increase the confidence that what is seen on GitHub matches what you have downloaded. The IOTA foundation created a Github Action which will publish a release to their blockchain. This has shown promise, but he gave a couple errors to tackle still.\n","url":"https://tauri.studio/docs/docs/usage/ci-cd/workflow"},{"id":"prose_docs_usage_development_debugging_md","title":"App Debugging","sections":["Rust Console","WebView JS Console","Create a Debug Build","Run Your App From the Terminal"],"subSections":[],"code":["rust","sh",null],"text":"\nimport Alert from '@theme/Alert'\nimport Command from '@theme/Command'\n\nWith all the moving pieces in Tauri, you may run into a problem that requires debugging. There are a handful of locations where error details are printed, and Tauri includes some tools to make the debugging process easier.\n\n## Rust Console\n\nWhen you run a Tauri app in development mode you will have a Rust console available. This is in the terminal where you ran e.g. `tauri dev`. You can use the following code to print something to that console from within a Rust file:\n\n```rust\nprintln!(\"Message from Rust: {}\", msg);\n```\n\nSometimes you may have an error in your Rust code, and the Rust compiler can give you lots of information. If, for example, `tauri dev` crashes, you can rerun it like this on Linux and macOS:\n\n```sh\nRUST_DEBUG=1 tauri dev\n```\n\nor like this on MS Windows:\n\n```sh\nset RUST_DEBUG=1\ntauri dev\n```\n\nThis will give you a granular stack trace. Generally speaking, the Rust compiler will help you by\ngiving you detailed information about the issue, such as:\n\n```\nerror[E0425]: cannot find value `sun` in this scope\n  --> src/main.rs:11:5\n   |\n11 |     sun += i.to_string().parse::<u64>().unwrap();\n   |     ^^^ help: a local variable with a similar name exists: `sum`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n```\n\n## WebView JS Console\n\nRight click in the WebView, and choose `Inspect Element`. This will open up a web-inspector similar to the Chrome or Firefox dev tools you are used to.\n\n## Create a Debug Build\n\nThere are cases where you might need to inspect the JS console in the final bundle, so Tauri provides a simple command to create a debugging bundle:\n\n<Command name=\"build --debug\" />\n\nLike the normal build and dev processes, the first time you run this it will take more time than subsequent runs. The final bundled app will be placed in `src-tauri/target/debug/bundle`. That app will ship with the development console enabled.\n\n## Run Your App From the Terminal\n\nYou can also run a built app from the terminal, which will also give you the Rust compiler notes (in case of errors) or your `println` messages. Just find the file `src-tauri/target/(release|debug)/[app name]` and either double click it (but be warned, the terminal will close on errors) or just run it in directly in your console.\n","url":"https://tauri.studio/docs/docs/usage/development/debugging"},{"id":"prose_docs_usage_development_development_md","title":"App Development","sections":[],"subSections":["1","2"],"code":[],"text":"\nimport Alert from '@theme/Alert'\nimport Command from '@theme/Command'\n\n### 1. Start Your Devserver\n\nNow that you have everything setup, you should start your application development server provided by your UI framework or bundler (assuming you're using one, of course).\n\n<Alert title=\"Note\">\nEvery framework has its own development tooling. It is outside of the scope of this document to treat them all or keep them up to date.\n</Alert>\n\n### 2. Start Tauri Development Window\n\n<Command name=\"dev\" />\n\nThe first time you run this command, it will take several minutes for the Rust package manager to download and build all the required packages. Since they are cached, subsequent builds will be much faster, as only your code will need rebuilding.\n\nOnce Rust has finished building, the webview will open and it should display your web app. You can make changes to your web app, and if your tooling enables it, the webview should update automatically just like a browser. When you make changes to your Rust files, they will be rebuilt automatically and your app will restart.\n\n<Alert title=\"A note about Cargo.toml and Source Control\" icon=\"info-alt\">\n  In your project repository, you SHOULD commit the \"src-tauri/Cargo.toml\" to git because you want it to be deterministic. You SHOULD NOT commit the \"src-tauri/target\" folder or any of its contents.\n</Alert>\n","url":"https://tauri.studio/docs/docs/usage/development/development"},{"id":"prose_docs_usage_development_integration_md","title":"Tauri Integration","sections":["Vue CLI Plugin Tauri"],"subSections":["1","1","2","3","Patterns"],"code":["bash","sh",null],"text":"\nimport Alert from '@theme/Alert'\nimport Command from '@theme/Command'\nimport Link from '@docusaurus/Link'\n\n<Alert title=\"Please note\" type=\"warning\" icon=\"alert\">\n  You must have completed all the steps required for setting up the development environment on your machine. If you haven't done this yet, please see the <a href=\"/docs/getting-started/intro#setting-up-your-environment\"> setup page for your operating system</a>.\n</Alert>\n\n### 1. Install Tauri CLI Package as a Dev Dependency:\n\n```bash\ncd project-folder\n\n# Not required if you already have a package.json:\n# yarn init\n# OR\n# npm init\n\nyarn add -D @tauri-apps/cli\n# OR\nnpm install -D @tauri-apps/cli\n```\n\n<Alert title=\"Note\">\n  You can install Tauri as both a local and a global dependency, but we recommend installing it locally.\n</Alert>\n\nIf you decide to use Tauri as a local package with npm (not yarn), you will have to define a custom script to your package.json:\n\n```js title=package.json\n{\n  // This content is just a sample\n  \"scripts\": {\n    \"tauri\": \"tauri\"\n  }\n}\n```\n\n### 1. Install Tauri API Package as a Dependency (optional):\n\nThe `@tauri-apps/api` package is recommended for projects using ES modules or modern build tools such as Webpack or Vite. It is the most secure way to access the Tauri APIs.\n\n```bash\nyarn add @tauri-apps/api\n# OR\nnpm install @tauri-apps/api\n```\n\n### 2. Initialize Tauri in Your App\n\n<Command name=\"init\" />\n\nThis command will place a new folder in your current working directory, `src-tauri`.\n\n```sh\n└── src-tauri\n    ├── .gitignore\n    ├── Cargo.toml\n    ├── rustfmt.toml\n    ├── tauri.conf.json\n    ├── icons\n    │   ├── 128x128.png\n    │   ├── 128x128@2x.png\n    │   ├── 32x32.png\n    │   ├── Square107x107Logo.png\n    │   ├── Square142x142Logo.png\n    │   ├── Square150x150Logo.png\n    │   ├── Square284x284Logo.png\n    │   ├── Square30x30Logo.png\n    │   ├── Square310x310Logo.png\n    │   ├── Square44x44Logo.png\n    │   ├── Square71x71Logo.png\n    │   ├── Square89x89Logo.png\n    │   ├── StoreLogo.png\n    │   ├── icon.icns\n    │   ├── icon.ico\n    │   └── icon.png\n    └── src\n        ├── build.rs\n        ├── cmd.rs\n        └── main.rs\n```\n\n### 3. Check `tauri info` to Make Sure Everything Is Set up Properly:\n\n<Command name=\"info\" />\n\nWhich should return something like:\n\n```\nOperating System - Darwin(16.7.0) - darwin/x64\n\nNode.js environment\n  Node.js - 12.16.3\n  @tauri-apps/cli - 1.0.0-beta.2\n  @tauri-apps/api - 1.0.0-beta.1\n\nGlobal packages\n  npm - 6.14.4\n  yarn - 1.22.4\n\nRust environment\n  rustc - 1.52.1\n  cargo - 1.52.0\n\nApp directory structure\n/node_modules\n/src-tauri\n/src\n/public\n\nApp\n  tauri.rs - 1.0.0-beta.1\n  build-type - bundle\n  CSP - default-src blob: data: filesystem: ws: wss: http: https: tauri: 'unsafe-eval' 'unsafe-inline' 'self' img-src: 'self'\n  distDir - ../public\n  devPath - ../public\n  framework - Svelte\n  bundler - Rollup\n```\n\nThis information can be very helpful when triaging problems.\n\n### Patterns\n\nWe've also defined prebuilt configurations called \"Patterns\". They may help you to customize Tauri to fit your needs.\n[See more about patterns](/docs/usage/patterns/about-patterns).\n\n## Vue CLI Plugin Tauri\n\nIf you are using Vue CLI, it is recommended to use the official [CLI plugin](https://github.com/tauri-apps/vue-cli-plugin-tauri).\n","url":"https://tauri.studio/docs/docs/usage/development/integration"},{"id":"prose_docs_usage_development_publishing_md","title":"App Publishing","sections":[],"subSections":["1","2"],"code":[],"text":"\nimport Alert from '@theme/Alert'\nimport Command from '@theme/Command'\n\n### 1. Build Your Web App\n\nNow that you are ready to package your project, you will need to run your framework's or bundler's build command (assuming you're using one, of course).\n\n<Alert title=\"Note\">\nEvery framework has its own publishing tooling. It is outside of the scope of this document to treat them all or keep them up to date.\n</Alert>\n\n### 2. Bundle your application with Tauri\n\n<Command name=\"build\" />\n\nThis command will embed your web assets into a single binary with your Rust code. The binary itself will be located in `src-tauri/target/release/[app name]`, and installers will be located in `src-tauri/target/release/bundle/`.\n\nLike the `tauri dev` command, the first time you run this, it will take some time to collect the Rust crates and build everything - but on subsequent runs it will only need to rebuild your code, which is much quicker.\n","url":"https://tauri.studio/docs/docs/usage/development/publishing"},{"id":"prose_docs_usage_development_updating_md","title":"Updating","sections":["Automatic updates","Manual updates"],"subSections":["Update NPM Packages"],"code":[],"text":"import Alert from '@theme/Alert'\n\n<Alert title=\"Please note\" type=\"warning\" icon=\"alert\">\n    Especially during the alpha and beta phases, you are expected to keep all Tauri dependencies and toolchains up to date. There is no support for any versions other than latest.\n</Alert>\n\n## Automatic updates\n\nThe Tauri JS CLI has a command to install and update all needed dependencies, just run `tauri deps install` or `tauri deps update`.\n\n## Manual updates\n\n### Update NPM Packages\n\nIf you are using the `tauri` package:\n```bash\n$ yarn upgrade @tauri-apps/cli @tauri-apps/api --latest\n$ npm install @tauri-apps/cli@latest @tauri-apps/api@latest\n```\nYou can also detect what the latest version of Tauri is on the command line, using:\n- `npm outdated @tauri-apps/cli`\n- `yarn outdated @tauri-apps/cli`\n\nAlternatively, if you are using the `vue-cli-plugin-tauri` approach:\n```bash\n$ yarn upgrade vue-cli-plugin-tauri --latest\n$ npm install vue-cli-plugin-tauri@latest\n```\n\n### Update Cargo Packages\nGo to `src-tauri/Cargo.toml` and change `tauri` to\n`tauri = { version = \"%version%\" }` where `%version%` is the version number shown above. (You can just use the `MAJOR.MINOR`) version, like `0.9`.\n\nThen do the following:\n```bash\n$ cd src-tauri\n$ cargo update -p tauri\n```\nYou can also run `cargo outdated -r tauri` to get direct information about the core library's latest version.\n","url":"https://tauri.studio/docs/docs/usage/development/updating"},{"id":"prose_docs_usage_guides_cli_md","title":"Make your own CLI","sections":["Base Configuration","Adding Arguments","Subcommands","Reading the matches","Complete documentation"],"subSections":["Positional Arguments","Named Arguments","Flag Arguments","Rust","JavaScript"],"code":["rust","js"],"text":"\nimport Alert from '@theme/Alert'\n\nTauri enables your app to have a CLI through <a href=\"https://github.com/clap-rs/clap\" target=\"_blank\">clap</a>, a robust command line argument parser. With a simple CLI definition in your `tauri.conf.json` file, you can define your interface and read its argument matches map on JavaScript and/or Rust.\n\n## Base Configuration\n\nUnder `tauri.conf.json`, you have the following structure to configure the interface:\n\n```js title=src-tauri/tauri.conf.json\n{\n  \"tauri\": {\n    \"cli\": {\n      \"description\": \"\", // command description that's shown on help\n      \"longDescription\": \"\", // command long description that's shown on help\n      \"beforeHelp\": \"\", // content to show before the help text\n      \"afterHelp\": \"\", // content to show after the help text\n      \"args\": [], // list of arguments of the command, we'll explain it later\n      \"subcommands\": {\n        \"subcommand-name\": {\n          // configures a subcommand that is accessible\n          // with `$ ./app subcommand-name --arg1 --arg2 --etc`\n          // configuration as above, with \"description\", \"args\", etc.\n        }\n      }\n    }\n  }\n}\n```\n\n<Alert title=\"Note\">\n  All JSON configurations here are just samples, many other fields have been omitted for the sake of clarity.\n</Alert>\n\n## Adding Arguments\n\nThe `args` array represents the list of arguments accepted by its command or subcommand. You can find more details about the way to configure them <a href=\"/docs/api/config#tauri\">here</a>.\n\n### Positional Arguments\n\nA positional argument is identified by its position in the list of arguments. With the following configuration:\n\n```json title=src-tauri/tauri.conf.json:tauri.cli\n{\n  \"args\": [\n    {\n      \"name\": \"source\",\n      \"index\": 1\n    },\n    {\n      \"name\": \"destination\",\n      \"index\": 2\n    }\n  ]\n}\n```\n\nUsers can run your app as `$ ./app tauri.txt dest.txt` and the arg matches map will define `source` as `\"tauri.txt\"` and `destination` as `\"dest.txt\"`.\n\n### Named Arguments\n\nA named argument is a (key, value) pair where the key identifies the value. With the following configuration:\n\n```json title=src-tauri/tauri.conf.json:tauri.cli\n{\n  \"args\": [\n    {\n      \"name\": \"type\",\n      \"short\": \"t\",\n      \"takesValue\": true,\n      \"multiple\": true,\n      \"possibleValues\": [\"foo\", \"bar\"]\n    }\n  ]\n}\n```\n\nUsers can run your app as `$ ./app --type foo bar`, `$ ./app -t foo -t bar` or `$ ./app --type=foo,bar` and the arg matches map will define `type` as `[\"foo\", \"bar\"]`.\n\n### Flag Arguments\n\nA flag argument is a standalone key whose presence or absence provides information to your application. With the following configuration:\n\n```js title=src-tauri/tauri.conf.json:tauri.cli\n{\n  \"args\": [\n    \"name\": \"verbose\",\n    \"short\": \"v\",\n    \"multipleOccurrences\": true\n  ]\n}\n```\n\nUsers can run your app as `$ ./app -v -v -v`, `$ ./app --verbose --verbose --verbose` or `$ ./app -vvv` and the arg matches map will define `verbose` as `true`, with `occurrences = 3`.\n\n## Subcommands\n\nSome CLI applications has additional interfaces as subcommands. For instance, the `git` CLI has `git branch`, `git commit` and `git push`. You can define additional nested interfaces with the `subcommands` array:\n\n```js title=src-tauri/tauri.conf.json:tauri\n{\n  \"cli\": {\n    ...\n    \"subcommands\": {\n      \"branch\": {\n        \"args\": []\n      },\n      \"push\": {\n        \"args\": []\n      }\n    }\n  }\n}\n```\n\nIts configuration is the same as the root application configuration, with the `description`, `longDescription`, `args`, etc.\n\n## Reading the matches\n\n### Rust\n\n```rust\nuse tauri::api::cli::get_matches;\n\nfn main() {\n  let context = tauri::generate_context!();\n  let cli_config = context.config().tauri.cli.clone().unwrap();\n  \n  match get_matches(&cli_config) {\n    // `matches` here is a Struct with { args, subcommand }.\n    // `args` is `HashMap<String, ArgData>` where `ArgData` is a struct with { value, occurances }.\n    // `subcommand` is `Option<Box<SubcommandMatches>>` where `SubcommandMatches` is a struct with { name, matches }.\n    Ok(matches) => {\n      println!(\"{:?}\", matches)\n    }\n    Err(_) => {}\n  };\n  \n  tauri::Builder::default()\n  .run(context)\n  .expect(\"error while running tauri application\");\n}\n```\n\n### JavaScript\n\n```js\nimport { getMatches } from '@tauri-apps/api/cli'\n\ngetMatches().then((matches) => {\n  // do something with the { args, subcommand } matches\n})\n```\n\n## Complete documentation\n\nYou can find more about the CLI configuration <a href=\"/docs/api/config#tauri\">here</a>.\n","url":"https://tauri.studio/docs/docs/usage/guides/cli"},{"id":"prose_docs_usage_guides_command_md","title":"Create Rust Commands","sections":["Basic Example","Passing Arguments","Returning Data","Error Handling","Async Commands","Accessing the Window in Commands","Accessing an AppHandle in Commands","Accessing managed state","Creating Multiple Commands","Complete Example"],"subSections":[],"code":["rust","js"],"text":"\nimport Alert from '@theme/Alert'\n\nTauri provides a simple yet powerful \"command\" system for calling Rust functions from your web app. Commands can accept arguments and return values. They can also return errors and be `async`.\n\n## Basic Example\n\nCommands are defined in your `src-tauri/src/main.rs` file. To create a command, just add a function and annotate it with `#[tauri::command]`:\n\n```rust\n#[tauri::command]\nfn my_custom_command() {\n  println!(\"I was invoked from JS!\");\n}\n```\n\nYou will have to provide a list of your commands to the builder function like so:\n\n```rust\n// Also in main.rs\nfn main() {\n  tauri::Builder::default()\n    // This is where you pass in your commands\n    .invoke_handler(tauri::generate_handler![my_custom_command])\n    .run(tauri::generate_context!())\n    .expect(\"failed to run app\");\n}\n```\n\nNow, you can invoke the command from your JS code:\n\n```js\n// With the Tauri API npm package:\nimport { invoke } from '@tauri-apps/api/tauri'\n// With the Tauri global script, enabled when `tauri.conf.json > build > withGlobalTauri` is set to true:\nconst invoke = window.__TAURI__.invoke\n\n// Invoke the command\ninvoke('my_custom_command')\n```\n\n## Passing Arguments\n\nYour command handlers can take arguments:\n\n```rust\n#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n  println!(\"I was invoked from JS, with this message: {}\", invoke_message);\n}\n```\n\nArguments should be passed as a JSON object with camelCase keys:\n\n```js\ninvoke('my_custom_command', { invokeMessage: 'Hello!' })\n```\n\nArguments can be of any type, as long as they implement [serde::Deserialize](https://serde.rs/derive.html).\n\n## Returning Data\n\nCommand handlers can return data as well:\n\n```rust\n#[tauri::command]\nfn my_custom_command() -> String {\n  \"Hello from Rust!\".into()\n}\n```\n\nThe `invoke` function returns a promise that resolves with the returned value:\n\n```js\ninvoke('my_custom_command').then((message) => console.log(message))\n```\n\nReturned data can be of any type, as long as it implements [Serde::Serialize](https://serde.rs/derive.html).\n\n## Error Handling\n\nIf your handler could fail and needs to be able to return an error, have the function return a `Result`:\n\n```rust\n#[tauri::command]\nfn my_custom_command() -> Result<String, String> {\n  // If something fails\n  Err(\"This failed!\".into())\n  // If it worked\n  Ok(\"This worked!\".into())\n}\n```\n\nIf the command returns an error, the promise will reject, otherwise it resolves:\n\n```js\ninvoke('my_custom_command')\n  .then((message) => console.log(message))\n  .catch((error) => console.error(error))\n```\n\n## Async Commands\n\n<Alert title=\"Note\">\nAsync commands are executed on a separate thread using the <a href=\"https://tauri.studio/en/docs/api/rust/tauri/async_runtime/fn.spawn\">async runtime</a>.\nCommands without the <i>async</i> keyword are executed on the main thread, unless defined with <i>#[tauri::command(async)]</i>.\n</Alert>\n\nIf your command needs to run asynchronously, simply declare it as `async`:\n\n```rust\n#[tauri::command]\nasync fn my_custom_command() {\n  // Call another async function and wait for it to finish\n  let result = some_async_function().await;\n  println!(\"Result: {}\", result);\n}\n```\n\nSince invoking the command from JS already returns a promise, it works just like any other command:\n\n```js\ninvoke('my_custom_command').then(() => console.log('Completed!'))\n```\n\n## Accessing the Window in Commands\n\nCommands can access the `Window` instance that invoked the message:\n\n```rust\n#[tauri::command]\nasync fn my_custom_command(window: tauri::Window) {\n  println!(\"Window: {}\", window.label());\n}\n```\n\n## Accessing an AppHandle in Commands\n\nCommands can access an `AppHandle` instance:\n\n```rust\n#[tauri::command]\nasync fn my_custom_command(app_handle: tauri::AppHandle) {\n  let app_dir = app_handle.path_resolver().app_dir();\n  use tauri::GlobalShortcutManager;\n  app_handle.global_shortcut_manager().register(\"CTRL + U\", move || {});\n}\n```\n\n## Accessing managed state\n\nTauri can manage state using the `manage` function on `tauri::Builder`.\nThe state can be accessed on a command using `tauri::State`:\n\n```rust\nstruct MyState(String);\n\n#[tauri::command]\nfn my_custom_command(state: tauri::State<MyState>) {\n  assert_eq!(state.0 == \"some state value\", true);\n}\n\nfn main() {\n  tauri::Builder::default()\n    .manage(MyState(\"some state value\".into()))\n    .invoke_handler(tauri::generate_handler![my_custom_command])\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n## Creating Multiple Commands\n\nThe `tauri::generate_handler!` macro takes an array of commands. To register\nmultiple commands, you cannot call invoke_handler multiple times. Only the last\ncall will be used. You must pass each command to a single call of\n`tauri::generate_handler!`.\n\n```rust\n#[tauri::command]\nfn cmd_a() -> String {\n\t\"Command a\"\n}\n#[tauri::command]\nfn cmd_b() -> String {\n\t\"Command b\"\n}\n\nfn main() {\n  tauri::Builder::default()\n    .invoke_handler(tauri::generate_handler![cmd_a, cmd_b])\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n## Complete Example\n\nAny or all of the above features can be combined:\n\n```rust title=main.rs\n// Definition in main.rs\n\nstruct Database;\n\n#[derive(serde::Serialize)]\nstruct CustomResponse {\n  message: String,\n  other_val: usize,\n}\n\nasync fn some_other_function() -> Option<String> {\n  Some(\"response\".into())\n}\n\n#[tauri::command]\nasync fn my_custom_command(\n  window: tauri::Window,\n  number: usize,\n  database: tauri::State<'_, Database>,\n) -> Result<CustomResponse, String> {\n  println!(\"Called from {}\", window.label());\n  let result: Option<String> = some_other_function().await;\n  if let Some(message) = result {\n    Ok(CustomResponse {\n      message,\n      other_val: 42 + number,\n    })\n  } else {\n    Err(\"No result\".into())\n  }\n}\n\nfn main() {\n  tauri::Builder::default()\n    .manage(Database {})\n    .invoke_handler(tauri::generate_handler![my_custom_command])\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n```js\n// Invocation from JS\n\ninvoke('my_custom_command', {\n  number: 42,\n})\n  .then((res) =>\n    console.log(`Message: ${res.message}, Other Val: ${res.other_val}`)\n  )\n  .catch((e) => console.error(e))\n```\n","url":"https://tauri.studio/docs/docs/usage/guides/command"},{"id":"prose_docs_usage_guides_events_md","title":"Events","sections":["Frontend","Backend"],"subSections":["Global events","Window","Global events","Window"],"code":["ts","rust"],"text":"\nThe Tauri event system is a multi-producer multi-consumer communication primitive that allows message passing between the frontend and the backend.\nIt is analogous to the command system, but payload type check must be written on the event handler and it simplifies communication from the backend to the frontend, working like a channel.\n\nA Tauri application can listen and emit to global and window-specific events. Usage from the frontend and the backend are described below.\n\n## Frontend\n\nThe event system is accessible on the frontend on the `event` and `window` modules of the `@tauri-apps/api` package.\n\n### Global events\n\nTo use the global event channel, import the `event` module and use the `emit` and `listen` functions:\n\n```ts\nimport { emit, listen } from '@tauri-apps/api/event'\n\n// listen to the `click` event and get a function to remove the event listener\n// there's also a `once` function that subscribes to an event and automatically unsubscribes the listener on the first event\nconst unlisten = await listen('click', event => {\n  // event.event is the event name (useful if you want to use a single callback fn for multiple event types)\n  // event.payload is the payload object\n})\n\n// emits the `click` event with the object payload\nemit('click', {\n  theMessage: 'Tauri is awesome!'\n})\n```\n\n### Window-specific events\n\nWindow-specific events are exposed on the `window` module.\n\n```ts\nimport { getCurrent, WebviewWindow } from '@tauri-apps/api/window'\n\n// emit an event that are only visible to the current window\nconst current = getCurrent()\ncurrent.emit('event', { message: 'Tauri is awesome!' })\n\n// create a new webview window and emit an event only to that window\nconst webview = new WebviewWindow('window')\nwebview.emit('event')\n\n```\n\n## Backend\n\nOn the backend, the global event channel is exposed on the `App` struct, and window-specific events can be emitted using the `Window` trait.\n\n### Global events\n\n```rust\nuse tauri::Manager;\n\n// the payload type must implement `Serialize`.\n// for global events, it also must implement `Clone`.\n#[derive(Clone, serde::Serialize)]\nstruct Payload {\n  message: String,\n}\n\nfn main() {\n  tauri::Builder::default()\n    .setup(|app| {\n      // listen to the `event-name` (emitted on any window)\n      let id = app.listen_global(\"event-name\", |event| {\n        println!(\"got event-name with payload {:?}\", event.payload());\n      });\n      // unlisten to the event using the `id` returned on the `listen_global` function\n      // an `once_global` API is also exposed on the `App` struct\n      app.unlisten(id);\n\n      // emit the `event-name` event to all webview windows on the frontend\n      app.emit_all(\"event-name\", Payload { message: \"Tauri is awesome!\".into() }).unwrap();\n      Ok(())\n    })\n    .run(tauri::generate_context!())\n    .expect(\"failed to run app\");\n}\n```\n\n### Window-specific events\n\nTo use the window-specific event channel, a `Window` object can be obtained on a command handler or with the `get_window` function:\n\n```rust\nuse tauri::{Manager, Window};\n\n// the payload type must implement `Serialize`.\n#[derive(serde::Serialize)]\nstruct Payload {\n  message: String,\n}\n\n// init a background process on the command, and emit periodic events only to the window that used the command\n#[tauri::command]\nfn init_process(window: Window) {\n  std::thread::spawn(move || {\n    loop {\n      window.emit(\"event-name\", Payload { message: \"Tauri is awesome!\".into() }).unwrap();\n    }\n  });\n}\n\nfn main() {\n  tauri::Builder::default()\n    .setup(|app| {\n      // `main` here is the window label; it is defined on the window creation or under `tauri.conf.json`\n      // the default value is `main`. note that it must be unique\n      let main_window = app.get_window(\"main\").unwrap();\n\n      // listen to the `event-name` (emitted on the `main` window)\n      let id = main_window.listen(\"event-name\", |event| {\n        println!(\"got window event-name with payload {:?}\", event.payload());\n      });\n      // unlisten to the event using the `id` returned on the `listen` function\n      // an `once` API is also exposed on the `Window` struct\n      main_window.unlisten(id);\n\n      // emit the `event-name` event to the `main` window\n      main_window.emit(\"event-name\", Payload { message: \"Tauri is awesome!\".into() }).unwrap();\n      Ok(())\n    })\n    .invoke_handler(tauri::generate_handler![init_process])\n    .run(tauri::generate_context!())\n    .expect(\"failed to run app\");\n}\n```\n","url":"https://tauri.studio/docs/docs/usage/guides/events"},{"id":"prose_docs_usage_guides_migration_md","title":"Migrating from 0.x","sections":["Commands"],"subSections":["Rust","JavaScript"],"code":["diff","rust","js"],"text":"\nFirst of all if you still have `tauri` as dependency in your `package.json`\nreplace it with a recent version of `@tauri-apps/cli` (make sure to also change\nthe import path in your JavaScript/TypeScript files, see [JavaScript](#javascript)).\n\nFor example:\n\n```diff\n- \"tauri\": \"^0.14.1\"\n+ \"@tauri-apps/cli\": \"^1.0.0-beta-rc.4\"\n```\n\nNext update your `Cargo.toml`:\n\n- add `tauri-build` as a new build-dependency and remove `winres`, e.g.:\n\n  ```diff\n  + [build-dependencies]\n  + tauri-build = { version = \"1.0.0-beta-rc.0\" }\n\n  - [target.\"cfg(windows)\".build-dependencies]\n  - winres = \"0.1\"\n  ```\n\n- update the version of `tauri` to e.g. `1.0.0-beta-rc.4`\n- remove all old features of the `tauri` dependency\n- remove all features, that tauri added and add `custom-protocol` as a new one:\n  \n  ```diff\n  [features]\n  - embedded-server = [ \"tauri/embedded-server\" ]\n  - no-server = [ \"tauri/no-server\" ]\n  + custom-protocol = [ \"tauri/custom-protocol\" ]\n  + default = [ \"custom-protocol\" ]\n  ```\n\nUpdate your `tauri.conf.json` like this:\n\n- remove `ctx`\n- remove the `embeddedServer`\n- rename `osx` to `macOS` and add some fields:\n  - `\"exceptionDomain\": \"\"`\n  - `\"signingIdentity\": null`\n  - `\"entitlements\": null`\n- remove the `exceptionDomain`\n- add a configuration for `windows`:\n  - `\"certificateThumbprint\": null`\n  - `\"digestAlgorithm\": \"sha256\"`\n  - `\"timestampUrl\": \"\"`\n- make the `window` definition into an array and call it `windows`\n- remove `inliner`\n\n> for more information about the config see [here](../../api/config.md)\n\n```diff\n  {\n-   \"ctx\": {},\n    \"tauri\": {\n-     \"embeddedServer\": {\n-       \"active\": true\n-     },\n      \"bundle\": {\n-       \"osx\": {\n+       \"macOS\": {\n          \"frameworks\": [],\n          \"minimumSystemVersion\": \"\",\n-         \"useBootstrapper\": false\n+         \"useBootstrapper\": false,\n+         \"exceptionDomain\": \"\",\n+         \"signingIdentity\": null,\n+         \"entitlements\": null\n        },\n-       \"exceptionDomain\": \"\"\n+       \"windows\": {\n+         \"certificateThumbprint\": null,\n+         \"digestAlgorithm\": \"sha256\",\n+         \"timestampUrl\": \"\"\n+       }\n      },\n+     \"updater\": {\n+       \"active\": false\n+     },\n-     \"window\": {\n+     \"windows\": [\n        {\n          \"title\": \"Calciumdibromid\",\n          \"width\": 800,\n          \"height\": 600,\n          \"resizable\": true,\n          \"fullscreen\": false\n        }\n+     ],\n-     \"inliner\": {\n-       \"active\": true\n-     }\n    }\n  }\n```\n\n## Commands\n\nThe following example is taken from the previous documentation.\n\nIn the new version of Tauri there is no distinction between synchronous and\nasynchronous commands, the only difference in your code is a call of\n`tauri::execute_promise()`, that isn't there in a synchronous command.\n\n### Rust\n\nHere is the complete example code of the \"old\" version:\n\n```rust\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize)]\nstruct DoSomethingPayload {\n  state: String,\n  data: u64,\n}\n\n#[derive(Deserialize)]\n#[serde(tag = \"cmd\", rename_all = \"camelCase\")]\nenum Cmd {\n  DoSomething {\n    count: u64,\n    payload: DoSomethingPayload,\n    callback: String,\n    error: String,\n  },\n}\n\n#[derive(Serialize)]\nstruct Response<'a> {\n  value: u64,\n  message: &'a str,\n}\n\n#[derive(Debug, Clone)]\nstruct CommandError<'a> {\n  message: &'a str,\n}\n\nimpl<'a> CommandError<'a> {\n  fn new(message: &'a str) -> Self {\n    Self { message }\n  }\n}\n\nimpl<'a> std::fmt::Display for CommandError<'a> {\n  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n    write!(f, \"{}\", self.message)\n  }\n}\n\nimpl<'a> std::error::Error for CommandError<'a> {}\n\nfn main() {\n  tauri::AppBuilder::new()\n    .invoke_handler(|_webview, arg| {\n      use Cmd::*;\n      match serde_json::from_str(arg) {\n        Err(e) => Err(e.to_string()),\n        Ok(command) => {\n          match command {\n            DoSomething { count, payload, callback, error } => tauri::execute_promise(\n              _webview,\n              move || {\n                if count > 5 {\n                  let response = Response {\n                    value: 5,\n                    message: \"async response!\",\n                  };\n                  Ok(response)\n                } else {\n                  Err(CommandError::new(\"count should be > 5\").into())\n                }\n              },\n              callback,\n              error,\n            ),\n          }\n          Ok(())\n        }\n      }\n    })\n    .build()\n    .run();\n}\n```\n\nComplete the following steps to migrate your code:\n\n- create a new function for every `Cmd` enum variant\n- wrap the new function with the `#[tauri::command]` macro\n- use the fields of the enum as arguments (`callback` and `error` can be deleted)\n- as function body use the code inside the `match` block of the enum variant\n- add a return type\n- rename `AppBuilder` to `Builder` in `main()`\n- replace the big `invoke_handler` with the new syntax\n\nThe old example code should look like this now:\n\n```rust\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize)]\nstruct DoSomethingPayload {\n  state: String,\n  data: u64,\n}\n\n#[derive(Serialize)]\nstruct Response<'a> {\n  value: u64,\n  message: &'a str,\n}\n\n#[derive(Debug, Clone, Serialize)]\nstruct CommandError<'a> {\n  message: &'a str,\n}\n\nimpl<'a> CommandError<'a> {\n  fn new(message: &'a str) -> Self {\n    Self { message }\n  }\n}\n\nimpl<'a> std::fmt::Display for CommandError<'a> {\n  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n    write!(f, \"{}\", self.message)\n  }\n}\n\nimpl<'a> std::error::Error for CommandError<'a> {}\n\n#[tauri::command]\nfn do_something(count: u64, payload: DoSomethingPayload) -> Result<Response, CommandError> {\n  if count > 5 {\n    let response = Response {\n      value: 5,\n      message: \"async response!\",\n    };\n    Ok(response)\n  } else {\n    Err(CommandError::new(\"count should be > 5\").into())\n  }\n}\n\nfn main() {\n  tauri::Builder::new()\n    .invoke_handler(tauri::generate_handler![do_something])\n    .run(tauri::generate_context!());\n}\n```\n\n### JavaScript\n\nLike mentioned above there is also no distinction between synchronous and\nasynchronous commands in JavaScript.  \nYou only have to use `invoke` and optionally use the results.\n\nHere is an example of the \"old\" code:\n\n```js\ninvoke({\n  cmd: 'doSomething',\n  count: 5,\n  payload: {\n    state: 'some string data',\n    data: 17\n  }\n});\n\npromisified({\n  cmd: 'doSomething',\n  count: 5,\n  payload: {\n    state: 'some string data',\n    data: 17\n  }\n}).then(response => {\n  console.log(response);\n}).catch(error => {\n  console.error(error);\n});\n```\n\nComplete the following steps to migrate your code:\n\n- replace all `promisified`-calls with `invoke`-calls\n- extract the `cmd` attribute of the argument object as first parameter  \n  (you may have to rename it to `snake_case` as the `cmd` parameter is now the\n  name of the function in Rust)\n- if you import parts of the tauri-api with `tauri/api/*` replace it with `@tauri-apps/api/*`, e.g.:\n\n  ```diff\n  - import { invoke } from 'tauri/api/tauri';\n  + import { invoke } from '@tauri-apps/api/tauri';\n  ```\n\nThe old example code should look like this now:\n\n```js\ninvoke(\n  'do_something',\n  {\n    count: 5,\n    payload: {\n      state: 'some string data',\n      data: 17\n    }\n  }\n);\n\ninvoke(\n  'do_something',\n  {\n    count: 5,\n    payload: {\n      state: 'some string data',\n      data: 17\n    }\n  }\n).then(response => {\n  console.log(response);\n}).catch(error => {\n  console.error(error);\n});\n```\n\nFor more information on commands read [Create Rust Commands](command.md).\n","url":"https://tauri.studio/docs/docs/usage/guides/migration"},{"id":"prose_docs_usage_guides_plugin_md","title":"Write Tauri Plugins","sections":["Writing a Plugin","Using a plugin","Official Tauri Plugins"],"subSections":[],"code":["rust"],"text":"\nimport Alert from '@theme/Alert'\n\n<Alert title=\"Note\" icon=\"info-alt\">\nTauri will soon offer Plugin starter kits so the process of writing a Plugin crate will be simplified.\n\nFor now it's recommended to follow the [official Tauri plugins](#official-tauri-plugins).\n</Alert>\n\nPlugins allow you to hook into the Tauri application lifecycle and introduce new commands.\n\n## Writing a Plugin\n\nTo write a plugin you just need to implement the `tauri::plugin::Plugin` trait:\n\n```rust\nuse tauri::{plugin::{Plugin, Result as PluginResult}, Runtime, PageLoadPayload, Window, Invoke, AppHandle};\n\nstruct MyAwesomePlugin<R: Runtime> {\n  invoke_handler: Box<dyn Fn(Invoke<R>) + Send + Sync>,\n  // plugin state, configuration fields\n}\n\n// the plugin custom command handlers if you choose to extend the API.\n#[tauri::command]\n// this will be accessible with `invoke('plugin:awesome|initialize')`.\n// where `awesome` is the plugin name.\nfn initialize() {}\n\n#[tauri::command]\n// this will be accessible with `invoke('plugin:awesome|do_something')`.\nfn do_something() {}\n\nimpl<R: Runtime> MyAwesomePlugin<R> {\n  // you can add configuration fields here,\n  // see https://doc.rust-lang.org/1.0.0/style/ownership/builders.html\n  pub fn new() -> Self {\n    Self {\n      invoke_handler: Box::new(tauri::generate_handler![initialize, do_something]),\n    }\n  }\n}\n\nimpl<R: Runtime> Plugin<R> for MyAwesomePlugin<R> {\n  /// The plugin name. Must be defined and used on the `invoke` calls.\n  fn name(&self) -> &'static str {\n    \"awesome\"\n  }\n\n  /// The JS script to evaluate on initialization.\n  /// Useful when your plugin is accessible through `window`\n  /// or needs to perform a JS task on app initialization\n  /// e.g. \"window.awesomePlugin = { ... the plugin interface }\"\n  fn initialization_script(&self) -> Option<String> {\n    None\n  }\n\n  /// initialize plugin with the config provided on `tauri.conf.json > plugins > $yourPluginName` or the default value.\n  fn initialize(&mut self, app: &AppHandle<R>, config: serde_json::Value) -> PluginResult<()> {\n    Ok(())\n  }\n\n  /// Callback invoked when the Window is created.\n  fn created(&mut self, window: Window<R>) {}\n\n  /// Callback invoked when the webview performs a navigation.\n  fn on_page_load(&mut self, window: Window<R>, payload: PageLoadPayload) {}\n\n  /// Extend the invoke handler.\n  fn extend_api(&mut self, message: Invoke<R>) {\n    (self.invoke_handler)(message)\n  }\n}\n```\n\nNote that each function on the `Plugin` trait is optional, except the `name` function.\n\n## Using a plugin\n\nTo use a plugin, just pass an instance of the `MyAwesomePlugin` struct to the App's `plugin` method:\n\n```rust\nfn main() {\n  let awesome_plugin = MyAwesomePlugin::new();\n  tauri::Builder::default()\n    .plugin(awesome_plugin)\n    .run(tauri::generate_context!())\n    .expect(\"failed to run app\");\n}\n```\n\n## Official Tauri Plugins\n\n- [Stronghold (WIP)](https://github.com/tauri-apps/tauri-plugin-stronghold)\n- [Authenticator (WIP)](https://github.com/tauri-apps/tauri-plugin-authenticator)\n- [Logging (WIP)](https://github.com/tauri-apps/tauri-plugin-log)\n- [SQL (WIP)](https://github.com/tauri-apps/tauri-plugin-sql)\n","url":"https://tauri.studio/docs/docs/usage/guides/plugin"},{"id":"prose_docs_usage_guides_updater_md","title":"Updater","sections":["Update Requests","Built","Javascript API","Events","Update Server JSON Format","Update File JSON Format","macOS","Windows","Linux"],"subSections":["Initialize updater and check if a new version is available","Listen New Update Available","Emit Install and Download","Listen Install Progress"],"code":["js","json","none","bash"],"text":"\n# Configuration\n\nOnce you have your Tauri project ready, you need to configure the updater.\n\nAdd this in tauri.conf.json\n```json\n\"updater\": {\n    \"active\": true,\n    \"endpoints\": [\n        \"https://releases.myapp.com/{{target}}/{{current_version}}\"\n    ],\n    \"dialog\": true,\n    \"pubkey\": \"\"\n}\n```\n\nThe required keys are \"active\" and \"endpoints\", others are optional.\n\n\"active\" must be a boolean. By default, it's set to false.\n\n\"endpoints\" must be an array. The string `{{target}}` and `{{current_version}}` are automatically replaced in the URL allowing you determine [server-side](#update-server-json-format) if an update is available. If multiple endpoints are specified, the updater will fallback if a server is not responding within the pre-defined timeout.\n\n\"dialog\" if present must be a boolean. By default, it's set to true. If enabled, [events](#events) are turned-off as the updater will handle everything. If you need the custom events, you MUST turn off the built-in dialog.\n\n\"pubkey\" if present must be a valid public-key generated with Tauri cli. See [Signing updates](#signing-updates).\n\n## Update Requests\n\nTauri is indifferent to the request the client application provides for update checking.\n\n`Accept: application/json` is added to the request headers because Tauri is responsible for parsing the response.\n\nFor the requirements imposed on the responses and the body format of an update, response see [Server Support](#server-support).\n\nYour update request must *at least* include a version identifier so that the server can determine whether an update for this specific version is required.\n\nIt may also include other identifying criteria such as operating system version, to allow the server to deliver as fine-grained an update as you would like.\n\nHow you include the version identifier or other criteria is specific to the server that you are requesting updates from. A common approach is to use query parameters, [Configuration](#configuration) shows an example of this.\n\n## Built-in dialog\n\nBy default, updater uses a built-in dialog API from Tauri.\n\n![New Update](https://i.imgur.com/UMilB5A.png)\n\nThe dialog release notes is represented by the update `note` provided by the [server](#server-support).\n\nIf the user accepts, the download and install are initialized. The user will be then prompted to restart the application.\n\n## Javascript API\n\n**Attention, you need to _disable built-in dialog_ in your [tauri configuration](#configuration), otherwise, events aren't emitted and the javascript API will NOT work.**\n\n\n```js\nimport { checkUpdate, installUpdate } from \"@tauri-apps/api/updater\";\nimport { relaunch } from \"@tauri-apps/api/process\";\ntry {\n    const {shouldUpdate, manifest} = await checkUpdate();\n    if (shouldUpdate) {\n        // display dialog\n        await installUpdate();\n        // install complete, restart app\n        await relaunch();\n    }\n} catch(error) {\n    console.log(error);\n}\n```\n\n## Events\n\n**Attention, you need to _disable built-in dialog_ in your [tauri configuration](#configuration), otherwise, events aren't emitted.**\n\nTo know when an update is ready to be installed, you can subscribe to these events:\n\n### Initialize updater and check if a new version is available\n\n#### If a new version is available, the event `tauri://update-available` is emitted.\n\nEvent: `tauri://update`\n\n### Rust\n```rust\nwindow.emit(\"tauri://update\".to_string(), None);\n```\n\n### Javascript\n```js\nimport { emit } from \"@tauri-apps/api/event\";\nemit(\"tauri://update\");\n```\n\n### Listen New Update Available\n\nEvent: `tauri://update-available`\n\nEmitted data:\n```none\nversion    Version announced by the server\ndate       Date announced by the server\nbody       Note announced by the server\n```\n\n### Rust\n```rust\nwindow.listen(\"tauri://update-available\".to_string(), move |msg| {\n  println!(\"New version available: {:?}\", msg);\n})\n```\n\n### Javascript\n```js\nimport { listen } from \"@tauri-apps/api/event\";\nlisten(\"tauri://update-available\", function (res) {\n  console.log(\"New version available: \", res);\n});\n```\n\n### Emit Install and Download\n\nYou need to emit this event to initialize the download and listen to the [install progress](#listen-install-progress).\n\nEvent: `tauri://update-install`\n\n### Rust\n```rust\nwindow.emit(\"tauri://update-install\".to_string(), None);\n```\n\n### Javascript\n```js\nimport { emit } from \"@tauri-apps/api/event\";\nemit(\"tauri://update-install\");\n```\n\n### Listen Install Progress\n\nEvent: `tauri://update-status`\n\nEmitted data:\n```none\nstatus    [ERROR/PENDING/DONE]\nerror     String/null\n```\n\nPENDING is emitted when the download is started and DONE when the install is complete. You can then ask to restart the application.\n\nERROR is emitted when there is an error with the updater. We suggest to listen to this event even if the dialog is enabled.\n\n### Rust\n```rust\nwindow.listen(\"tauri://update-status\".to_string(), move |msg| {\n  println!(\"New status: {:?}\", msg);\n})\n```\n\n### Javascript\n```js\nimport { listen } from \"@tauri-apps/api/event\";\nlisten(\"tauri://update-status\", function (res) {\n  console.log(\"New status: \", res);\n});\n```\n\n# Server Support\n\nYour server should determine whether an update is required based on the [Update Request](#update-requests) your client issues.\n\nIf an update is required your server should respond with a status code of [200 OK](http://tools.ietf.org/html/rfc2616#section-10.2.1) and include the [update JSON](#update-server-json-format) in the body. To save redundantly downloading the same version multiple times your server must not inform the client to update.\n\nIf no update is required your server must respond with a status code of [204 No Content](http://tools.ietf.org/html/rfc2616#section-10.2.5).\n\n## Update Server JSON Format\n\nWhen an update is available, Tauri expects the following schema in response to the update request provided:\n\n```json\n{\n    \"url\": \"https://mycompany.example.com/myapp/releases/myrelease.tar.gz\",\n    \"version\": \"0.0.1\",\n    \"notes\": \"Theses are some release notes\",\n    \"pub_date\": \"2020-09-18T12:29:53+01:00\",\n    \"signature\": \"\"\n}\n```\n\nThe only required keys are \"url\" and \"version\", the others are optional.\n\n\"pub_date\" if present must be formatted according to ISO 8601.\n\n\"signature\" if present must be a valid signature generated with Tauri cli. See [Signing updates](#signing-updates).\n\n## Update File JSON Format\n\nThe alternate update technique uses a plain JSON file meaning you can store your update metadata on S3, gist, or another static file store. Tauri will check against the name/version field and if the version is smaller than the current one and the platform is available, the update will be triggered. The format of this file is detailed below:\n\n```json\n{\n\t\"name\":\"v1.0.0\",\n\t\"notes\":\"Test version\",\n\t\"pub_date\":\"2020-06-22T19:25:57Z\",\n\t\"platforms\": {\n\t\t\"darwin\": {\n\t\t\t\"signature\":\"\",\n\t\t\t\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.app.tar.gz\"\n\t\t},\n \t\t\"linux\": {\n\t\t\t\"signature\":\"\",\n\t\t\t\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.AppImage.tar.gz\"\n\t\t},\n\t\t\"win64\": {\n\t\t\t\"signature\":\"\",\n\t\t\t\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.x64.msi.zip\"\n\t\t}\n\t}\n}\n```\n\n# Bundler (Artifacts)\n\nThe Tauri bundler will automatically generate update artifacts if the updater is enabled in `tauri.conf.json`\n\nIf the bundler can locate your private and pubkey, your update artifacts will be automatically signed.\n\nThe signature can be found in the `sig` file. The signature can be uploaded to GitHub safely or made public as long as your private key is secure.\n\nYou can see how it's [bundled with the CI](https://github.com/tauri-apps/tauri/blob/5b6c7bb6ee3661f5a42917ce04a89d94f905c949/.github/workflows/artifacts-updater.yml#L44) and a [sample tauri.conf.json](https://github.com/tauri-apps/tauri/blob/5b6c7bb6ee3661f5a42917ce04a89d94f905c949/examples/updater/src-tauri/tauri.conf.json#L52)\n\n## macOS\n\nOn MACOS we create a .tar.gz from the whole application. (.app)\n\n```none\ntarget/release/bundle\n└── osx\n    └── app.app\n    └── app.app.tar.gz (update bundle)\n    └── app.app.tar.gz.sig (if signature enabled)\n```\n\n## Windows\n\nOn Windows we create a .zip from the MSI, when downloaded and validated, we run the MSI install.\n\n```none\ntarget/release\n└── app.x64.msi\n└── app.x64.msi.zip (update bundle)\n└── app.x64.msi.zip.sig (if signature enabled)\n```\n\n## Linux\n\nOn Linux, we create a .tar.gz from the AppImage.\n\n```none\ntarget/release/bundle\n└── appimage\n    └── app.AppImage\n    └── app.AppImage.tar.gz (update bundle)\n    └── app.AppImage.tar.gz.sig (if signature enabled)\n```\n\n# Signing updates\n\nWe offer a built-in signature to ensure your update is safe to be installed.\n\nTo sign your updates, you need two things.\n\nThe *Public-key* (pubkey) should be added inside your `tauri.conf.json` to validate the update archive before installing.\n\nThe *Private key* (privkey) is used to sign your update and should NEVER be shared with anyone. Also, if you lost this key, you'll NOT be able to publish a new update to the current user base (if pubkey is set in tauri.conf.json). It's important to save it at a safe place and you can always access it.\n\nTo generate your keys you need to use the Tauri cli.\n\n```bash\ntauri sign -g -w ~/.tauri/myapp.key\n```\n\nYou have multiple options available\n```bash\nTauri updates signer.\nUSAGE:\n    tauri sign [FLAGS] [OPTIONS]\nFLAGS:\n        --force          Overwrite private key even if it exists on the specified path\n    -g, --generate       Generate keypair to sign files\n    -h, --help           Prints help information\n        --no-password    Set empty password for your private key\n    -V, --version        Prints version information\nOPTIONS:\n    -p, --password <password>                    Set private key password when signing\n    -k, --private-key <private-key>              Load the private key from a string\n    -f, --private-key-path <private-key-path>    Load the private key from a file\n        --sign-file <sign-file>                  Sign the specified file\n    -w, --write-keys <write-keys>                Write private key to a file\n```\n***\nEnvironment variables used to sign with the Tauri `bundler`:\nIf they are set, and `tauri.conf.json` expose the public key, the bundler will automatically generate and sign the updater artifacts.\n`TAURI_PRIVATE_KEY`  Path or String of your private key\n`TAURI_KEY_PASSWORD`  Your private key password (optional)\n","url":"https://tauri.studio/docs/docs/usage/guides/updater"},{"id":"prose_docs_usage_guides_bundler_anti_bloat_md","title":"Anti Bloat","sections":[],"subSections":["Rust Compression Features","Stripping","Allowlist config","UPX"],"code":[null,"json"],"text":"\nimport Alert from '@theme/Alert'\n\nThe following links have tutorials on reducing the size of your installers:\n\n- https://github.com/RazrFalcon/cargo-bloat\n- https://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html\n- https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections\n\n### Rust Compression Features\n\nAdd this to your `src-tauri/Cargo.toml`\n\n    [profile.release]\n    panic = \"abort\"\n    codegen-units = 1\n    lto = true\n    incremental = false\n    opt-level = \"s\"\n\n<Alert title=\"Note\">\n\nThere is also `opt-level = \"z\"` available to try to reduce the resulting binary size. `\"s\"` and `\"z\"` can sometimes be smaller than the other, so test it with your own application!\n\nWe've seen smaller binary sizes from `\"s\"` for Tauri example applications, but real world applications can always differ.\n</Alert>\n\n#### Unstable Rust Compression Features\n\n<Alert type=\"warning\" title=\"Warning\" icon=\"alert\">\nThe following suggestions are all unstable features and require a nightly toolchain. See the <a href=\"https://doc.rust-lang.org/cargo/reference/unstable.html#unstable-features\">Unstable Features</a> documentation for more information of what this involves.\n</Alert>\n\nThe following methods involve using unstable compiler features and require having a rust nightly toolchain installed. If you don't have the nightly toolchain + `rust-src` nightly component added, try the following:\n\n    $ rustup toolchain install nightly\n    $ rustup component add rust-src --toolchain nightly\n\nThe Rust Standard Library comes precompiled. You can instead apply the optimization options used for the rest of your binary + dependencies to the std with an unstable flag. This flag requires specifying your target, so know the target triple that you are targeting.\n\n    $ cargo +nightly build --release -Z build-std --target x86_64-unknown-linux-gnu\n\nIf you are using `panic = \"abort\"` in your release profile optimizations, then you need to make sure the `panic_abort` crate is compiled with std. Additionally, an extra std feature can be used to further reduce the binary size. The following applies both:\n\n    $ cargo +nightly build --release -Z build-std=std,panic_abort -Z build-std-features=panic_immediate_abort --target x86_64-unknown-linux-gnu\n\nSee the unstable documentation for more details about [`-Z build-std`](https://doc.rust-lang.org/cargo/reference/unstable.html#build-std) and [`-Z build-std-features`](https://doc.rust-lang.org/cargo/reference/unstable.html#build-std-features).\n\n### Stripping\n\nBinary size can easily be reduced by stripping out debugging information from binaries that ship to end users. This is not good for debuggable builds, but means good binary size savings for end user binaries. The easiest way is to use the famous `strip` utility to remove this debugging information.\n\n    $ strip target/release/my_application\n\nSee your local `strip` manpage for more information and flags that can be used to specify what information gets stripped out from the binary.\n\n### Allowlist config\n\nYou can also reduce the application size with the `allowlist` config, and only enabling what you need. Sometimes this is useful with Tauri's [Bridge-Pattern](/docs/usage/patterns/bridge) or others, depending on needs.\n\nFor example in `tauri.conf.json` file:\n\n```json\n{\n  \"tauri\": {\n    \"allowlist\": {\n      \"all\": false,\n      \"fs\": {\n        \"writeFile\": true,\n        \"writeBinaryFile\": true\n      },\n      \"shell\": {\n        \"execute\": true\n      },\n      \"dialog\": {\n        \"save\": true\n      }\n    }\n  }\n}\n```\n\n### UPX\n\nUPX, **Ultimate Packer for eXecutables**, is a dinosaur amongst the binary packers. This 23-year old, well-maintained piece of kit is GPL-v2 licensed with a pretty liberal usage declaration. Our understanding of the licensing is that you can use it for any purposes (commercial or otherwise) without needing to change your license unless you modify the source code of UPX.\n\nBasically it compresses the binary and decompresses it at runtime. It should work for pretty much any binary type out there. Read more: https://github.com/upx/upx\n\n<Alert type=\"warning\" title=\"Warning\" icon=\"alert\">\nYou should know that this technique might flag your binary as a virus on Windows and macOS - so use at your own discretion, and as always validate with [Frida](https://frida.re/docs/home/) and do real distribution testing!\n</Alert>\n\n#### Usage on macOS\n\n    $ brew install upx\n    $ yarn tauri build\n    $ upx --ultra-brute src-tauri/target/release/bundle/macos/app.app/Contents/macOS/app\n                           Ultimate Packer for eXecutables\n                              Copyright (C) 1996 - 2018\n    UPX 3.95        Markus Oberhumer, Laszlo Molnar & John Reiser   Aug 26th 2018\n\n            File size         Ratio      Format      Name\n       --------------------   ------   -----------   -----------\n        963140 ->    274448   28.50%   macho/amd64   app\n","url":"https://tauri.studio/docs/docs/usage/guides/bundler/anti-bloat"},{"id":"prose_docs_usage_guides_bundler_debian_md","title":"Debian packages","sections":[],"subSections":[],"code":["json"],"text":"\nimport Alert from '@theme/Alert'\n\nTauri allows your app to be packaged as a `.deb` (Debian package) file.\n\n# Bootstrapper\n\nInstead of launching the app directly, you can configure the bundled app to run a script that tries to expose the environment variables to the app; without that you'll have trouble using system programs because the `PATH` environment variable isn't correct. Enable it with the <a href=\"/docs/api/config#tauri.bundle.deb.useBootstrapper\">`useBootstrapper`</a> config.\n\n# Custom files\n\nTo include custom files to the debian package, you can configure a mapping on `tauri.conf.json > tauri > bundle > deb > files` as follows:\n\n```json\n{\n  \"tauri\": {\n    \"bundle\": {\n      \"deb\": {\n        \"files\": {\n          \"/usr/lib/README.md\": \"../README.md\", // copies the README.md file to /usr/lib/README.md\n          \"usr/lib/assets\": \"../public/\" // copies the entire public directory to /usr/lib/assets\n        }\n      }\n    }\n  }\n}\n```\n\n<Alert title=\"Note\" icon=\"info-alt\">\nEach `files` object key is the path on the debian package, and the value is a path to a file or directory relative to the `tauri.conf.json` file.\n</Alert>\n","url":"https://tauri.studio/docs/docs/usage/guides/bundler/debian"},{"id":"prose_docs_usage_guides_bundler_introduction_md","title":"Introduction","sections":[],"subSections":[],"code":[],"text":"\nThe Tauri Bundler is a Rust harness for compiling your binary, packaging assets, and preparing a final bundle.\n\nIt will detect your operating system and build a bundle accordingly. It currently supports:\n\n- Linux: .deb, .appimage\n- macOS: .app, .dmg\n- Windows: .exe, .msi","url":"https://tauri.studio/docs/docs/usage/guides/bundler/introduction"},{"id":"prose_docs_usage_guides_bundler_sidecar_md","title":"Sidecar (Embedding External Binaries)","sections":["Running the sidecar binary on JavaScript","Running the sidecar binary on Rust","Using Node"],"subSections":[],"code":["json","bash","javascript","rust"],"text":"\nimport Alert from '@theme/Alert'\n\nYou may need to embed depending binaries in order to make your application work or to prevent users having to install additional dependencies (e.g. Node.js, Python, etc).\n\nTo bundle the binaries of your choice, you can add the `externalBin` property to the `tauri > bundle` object in your `tauri.conf.json`.\n\nSee more about tauri.conf.json configuration <a href=\"/docs/api/config#tauri.bundle\">here</a>.\n\n`externalBin` expects a list of strings targeting binaries either with absolute or relative paths.\n\nHere is a sample to illustrate the configuration, this is not a complete `tauri.conf.json` file:\n\n```json\n{\n  \"tauri\": {\n    \"bundle\": {\n      \"externalBin\": [\"/absolute/path/to/app\", \"relative/path/to/binary\", \"bin/python\"]\n    }\n  }\n}\n```\n\nA binary with the same name and a `-$TARGET_TRIPLE` suffix must exist on the specified path. For instance, `\"externalBin\": [\"bin/python\"]` requires a `src-tauri/bin/python-x86_64-unknown-linux-gnu` executable on Linux. You can find the current platform's target triple running the following command:\n\n```bash\nRUSTC_BOOTSTRAP=1 rustc -Z unstable-options --print target-spec-json\n```\n\nHere's a Node.js script to append the target triple to a binary:\n\n```javascript\nconst execa = require('execa')\nconst fs = require('fs')\n\nlet extension = ''\nif (process.platform === 'win32') {\n  extension = '.exe'\n}\n\nasync function main() {\n  const rustInfo = (await execa('rustc', ['-vV'])).stdout\n  const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1]\n  if (!targetTriple) {\n    console.error('Failed to determine platform target triple')\n  }\n  fs.renameSync(\n    `src-tauri/binaries/app${extension}`,\n    `src-tauri/binaries/app-${targetTriple}${extension}`\n  )\n}\n\nmain().catch((e) => {\n  throw e\n})\n\n```\n\n## Running the sidecar binary on JavaScript\n\nOn the JavaScript code, import the `Command` class on the `shell` module and use the `sidecar` static method:\n\n```javascript\nimport { Command } from '@tauri-apps/api/shell'\n// alternatively, use `window.__TAURI__.shell.Command`\n// `my-sidecar` is the value specified on `tauri.conf.json > tauri > bundle > externalBin`\nconst command = Command.sidecar('my-sidecar')\nconst output = await command.execute()\n```\n\n## Running the sidecar binary on Rust\n\nOn the Rust code, import the `Command` struct from the `tauri::api::process` module:\n\n```rust\nlet (mut rx, mut child) = Command::new_sidecar(\"my-sidecar\")\n  .expect(\"failed to create `my-sidecar` binary command\")\n  .spawn()\n  .expect(\"Failed to spawn sidecar\");\n\ntauri::async_runtime::spawn(async move {\n  // read events such as stdout\n  while let Some(event) = rx.recv().await {\n    if let CommandEvent::Stdout(line) = event {\n      window\n        .emit(\"message\", Some(format!(\"'{}'\", line)))\n        .expect(\"failed to emit event\");\n      // write to stdin\n      child.write(\"message from Rust\\n\".as_bytes()).unwrap();\n    }\n  }\n});\n```\n\n## Using Node.js on a sidecar\n\nThe Tauri [sidecar example](https://github.com/tauri-apps/tauri/tree/dev/examples/sidecar) demonstrates how to use the sidecar API to run a Node.js application on Tauri.\nIt compiles the Node.js code using [pkg](https://github.com/vercel/pkg) and uses the scripts above to run it.\n","url":"https://tauri.studio/docs/docs/usage/guides/bundler/sidecar"},{"id":"prose_docs_usage_guides_utils_multiwindow_md","title":"Multiwindow","sections":[],"subSections":[],"code":[],"text":"\nManage multiple windows on a single application.\n","url":"https://tauri.studio/docs/docs/usage/guides/utils/multiwindow"},{"id":"prose_docs_usage_guides_visual_icons_md","title":"Icons","sections":[],"subSections":[],"code":["sh","json"],"text":"\nimport Command from '@theme/Command'\nimport Alert from '@theme/Alert'\n\nTauri ships with a default iconset based on its logo. This is probably NOT what you want when you ship your application. To remedy this common situation, Tauri provides the `icon` command that will take an input file and create all the icons needed for the various platforms:\n\n<Command name=\"icon\"/>\n\n```sh\nOptions\n  --help, -h          Displays this message\n  --log, l            Logging [boolean]\n  --icon, i           Source icon (png, 1240x1240 with transparency)\n  --target, t         Target folder (default: 'src-tauri/icons')\n  --compression, c    Compression type [pngquant|optipng|zopfli]\n```\n\nThese will be placed in your `src-tauri/icons` folder where they will automatically be included in your built app.\n\nIf you need to source your icons from some other location, you can edit this part of the `src-tauri/tauri.conf.json` file:\n\n```json\n{\n  \"tauri\": {\n    \"bundle\": {\n      \"icon\": [\n        \"icons/32x32.png\",\n        \"icons/128x128.png\",\n        \"icons/128x128@2x.png\",\n        \"icons/icon.icns\",\n        \"icons/icon.ico\"\n      ]\n    }\n  }\n}\n```\n\n<Alert type=\"info\" icon=\"info-alt\" title=\"Note on filetypes\">\n\n  - icon.icns = macOS\n  - icon.ico = MS Windows\n  - \\*.png = Linux\n\n</Alert>\n","url":"https://tauri.studio/docs/docs/usage/guides/visual/icons"},{"id":"prose_docs_usage_guides_visual_menu_md","title":"Window Menu","sections":[],"subSections":["Creating a menu","Adding the menu to all windows","Adding the menu to a specific window","Listening to events on custom menu items","Updating menu items"],"code":["rust"],"text":"\nNative application menus can be attached to a window.\n\n### Creating a menu\n\nTo create a native window menu, import the `Menu`, `Submenu`, `MenuItem` and `CustomMenuItem` types.\nThe `MenuItem` enum contains a collection of platform-specific items (currently not implemented on Windows).\nThe `CustomMenuItem` allows you to create your own menu items and add special functionality to them.\n\n```rust\nuse tauri::{CustomMenuItem, Menu, MenuItem, Submenu};\n```\n\nCreate a `Menu` instance:\n\n```rust\n// here `\"quit\".to_string()` defines the menu item id, and the second parameter is the menu item label.\nlet quit = CustomMenuItem::new(\"quit\".to_string(), \"Quit\");\nlet close = CustomMenuItem::new(\"close\".to_string(), \"Close\");\nlet submenu = Submenu::new(\"File\", Menu::new().add_item(quit).add_item(close));\nlet menu = Menu::new()\n  .add_native_item(MenuItem::Copy)\n  .add_item(CustomMenuItem::new(\"hide\", \"Hide\"))\n  .add_submenu(submenu);\n```\n\n### Adding the menu to all windows\n\nThe defined menu can be set to all windows using the `menu` API on the `tauri::Builder` struct:\n\n```rust\nuse tauri::{CustomMenuItem, Menu, MenuItem, Submenu};\n\nfn main() {\n  let menu = Menu::new(); // configure the menu\n  tauri::Builder::default()\n    .menu(menu)\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n### Adding the menu to a specific window\n\nYou can create a window and set the menu to be used. This allows defining a specific menu set for each application window.\n\n```rust\nuse tauri::{CustomMenuItem, Menu, MenuItem, Submenu};\nuse tauri::WindowBuilder;\n\nfn main() {\n  let menu = Menu::new(); // configure the menu\n  tauri::Builder::default()\n    .create_window(\n      \"main-window\".to_string(),\n      tauri::WindowUrl::App(\"index.html\".into()),\n      move |window_builder, webview_attributes| {\n        (window_builder.menu(menu), webview_attributes)\n      },\n    )\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n### Listening to events on custom menu items\n\nEach `CustomMenuItem` triggers an event when clicked. Use the `on_menu_event` API to handle them, either on the global `tauri::Builder` or on an specific window.\n\n#### Listening to events on global menus\n\n```rust\nuse tauri::{CustomMenuItem, Menu, MenuItem};\n\nfn main() {\n  let menu = vec![]; // insert the menu array here\n  tauri::Builder::default()\n    .menu(menu)\n    .on_menu_event(|event| {\n      match event.menu_item_id() {\n        \"quit\" => {\n          std::process::exit(0);\n        }\n        \"close\" => {\n          event.window().close().unwrap();\n        }\n        _ => {}\n      }\n    })\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n#### Listening to events on window menus\n\n```rust\nuse tauri::{CustomMenuItem, Menu, MenuItem};\nuse tauri::{Manager, WindowBuilder};\n\nfn main() {\n  let menu = vec![]; // insert the menu array here\n  tauri::Builder::default()\n    .create_window(\n      \"main-window\".to_string(),\n      tauri::WindowUrl::App(\"index.html\".into()),\n      move |window_builder, webview_attributes| {\n        (window_builder.menu(menu), webview_attributes)\n      },\n    )\n    .setup(|app| {\n      let window = app.get_window(\"main-window\").unwrap();\n      let window_ = window.clone();\n      window.on_menu_event(move |event| {\n        match event.menu_item_id().as_str() {\n          \"quit\" => {\n            std::process::exit(0);\n          }\n          \"close\" => {\n            window_.close().unwrap();\n          }\n          _ => {}\n        }\n      });\n      Ok(())\n    })\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n### Updating menu items\n\nThe `Window` struct has a `menu_handle` method, which allows updating menu items:\n\n```rust\nfn main() {\n  tauri::Builder::default()\n    .setup(|app| {\n      let main_window = app.get_window(\"main\").unwrap();\n      let menu_handle = main_window.menu_handle();\n      std::thread::spawn(move || {\n        // you can also `set_selected`, `set_enabled` and `set_native_image` (macOS only).\n        menu_handle.get_item(\"item_id\").set_title(\"New title\");\n      })\n      Ok(())\n    })\n}\n```\n","url":"https://tauri.studio/docs/docs/usage/guides/visual/menu"},{"id":"prose_docs_usage_guides_visual_splashscreen_md","title":"Splashscreen","sections":[],"subSections":["Setup","Waiting for Webpage","Waiting for Rust"],"code":["diff",null],"text":"\nimport Link from '@docusaurus/Link'\n\nIf your webpage could take some time to load, or if you need to run an initialization procedure in Rust before displaying your main window, a splashscreen could improve the loading experience for the user.\n\n### Setup\n\nFirst, create a `splashscreen.html` in your `distDir` that contains the HTML code for a splashscreen. Then, update your `tauri.conf.json` like so:\n\n```diff\n\"windows\": [\n  {\n    \"title\": \"Tauri App\",\n    \"width\": 800,\n    \"height\": 600,\n    \"resizable\": true,\n    \"fullscreen\": false,\n+   \"visible\": false // Hide the main window by default\n  },\n  // Add the splashscreen window\n+ {\n+   \"width\": 400,\n+   \"height\": 200,\n+   \"decorations\": false,\n+   \"url\": \"splashscreen.html\",\n+   \"label\": \"splashscreen\"\n+ }\n]\n```\n\nNow, your main window will be hidden and the splashscreen window will show when your app is launched. Next, you'll need a way to close the splashscreen and show the main window when your app is ready. How you do this depends on what you are waiting for before closing the splashscreen.\n\n### Waiting for Webpage\n\nIf you are waiting for your web code, you'll want to create a `close_splashscreen` [command](../command.md).\n\n```rust title=src-tauri/main.rs\nuse tauri::Manager;\n// Create the command:\n#[tauri::command]\nfn close_splashscreen(window: tauri::Window) {\n  // Close splashscreen\n  if let Some(splashscreen) = window.get_window(\"splashscreen\") {\n    splashscreen.close().unwrap();\n  }\n  // Show main window\n  window.get_window(\"main\").unwrap().show().unwrap();\n}\n\n// Register the command:\nfn main() {\n  tauri::Builder::default()\n    // Add this line\n    .invoke_handler(tauri::generate_handler![close_splashscreen])\n    .run(tauri::generate_context!())\n    .expect(\"failed to run app\");\n}\n\n```\n\nThen, you can call it from your JS:\n\n```js\n// With the Tauri API npm package:\nimport { invoke } from '@tauri-apps/api/tauri'\n// With the Tauri global script:\nconst invoke = window.__TAURI__.invoke\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  // This will wait for the window to load, but you could\n  // run this function on whatever trigger you want\n  invoke('close_splashscreen')\n})\n```\n\n### Waiting for Rust\n\nIf you are waiting for Rust code to run, put it in the `setup` function handler so you have access to the `App` instance:\n\n```rust title=src-tauri/main.rs\nuse tauri::Manager;\nfn main() {\n  tauri::Builder::default()\n    .setup(|app| {\n      let splashscreen_window = app.get_window(\"splashscreen\").unwrap();\n      let main_window = app.get_window(\"main\").unwrap();\n      // we perform the initialization code on a new task so the app doesn't freeze\n      tauri::async_runtime::spawn(async move {\n        // initialize your app here instead of sleeping :)\n        println!(\"Initializing...\");\n        std::thread::sleep(std::time::Duration::from_secs(2));\n        println!(\"Done initializing.\");\n\n        // After it's done, close the splashscreen and display the main window\n        splashscreen_window.close().unwrap();\n        main_window.show().unwrap();\n      });\n      Ok(())\n    })\n    .run(tauri::generate_context!())\n    .expect(\"failed to run app\");\n}\n```\n","url":"https://tauri.studio/docs/docs/usage/guides/visual/splashscreen"},{"id":"prose_docs_usage_guides_visual_system_tray_md","title":"System Tray","sections":[],"subSections":["Setup","Creating a system tray","Configuring a system tray context menu","Configure the app system tray","Listening to system tray events","Updating system tray"],"code":["json","rust"],"text":"\nNative application system tray.\n\n### Setup\n\nConfigure the `systemTray` object on `tauri.conf.json`:\n\n```json\n{\n  \"tauri\": {\n    \"systemTray\": {\n      \"iconPath\": \"icons/icon.png\",\n      \"iconAsTemplate\": true,\n    }\n  }\n}\n```\n\nThe `iconPath` is pointed to a PNG file on macOS and Linux, and a `.ico` file must exist for Windows support.\n\nThe `iconAsTemplate` is a boolean value that determines whether the image represents a [template](https://developer.apple.com/documentation/appkit/nsimage/1520017-template?language=objc) image on macOS.\n\n\n### Creating a system tray\n\nTo create a native system tray, import the `SystemTray` type:\n\n```rust\nuse tauri::SystemTray;\n```\n\nInitialize a new tray instance:\n\n```rust\nlet tray = SystemTray::new();\n```\n\n### Configuring a system tray context menu\n\nOptionally you can add a context menu that is visible when the tray icon is right clicked. Import the `SystemTrayMenu`, `SystemTrayMenuItem` and `CustomMenuItem` types:\n\n```rust\nuse tauri::{CustomMenuItem, SystemTrayMenu, SystemTrayMenuItem};\n```\n\nCreate the `SystemTrayMenu`:\n\n```rust\n// here `\"quit\".to_string()` defines the menu item id, and the second parameter is the menu item label.\nlet quit = CustomMenuItem::new(\"quit\".to_string(), \"Quit\");\nlet hide = CustomMenuItem::new(\"hide\".to_string(), \"Hide\");\nlet tray_menu = SystemTrayMenu::new()\n  .add_item(quit)\n  .add_native_item(SystemTrayMenuItem::Separator)\n  .add_item(hide);\n```\n\nAdd the tray menu to the `SystemTray` instance:\n\n```rust\nlet tray = SystemTray::new().with_menu(tray_menu);\n```\n\n### Configure the app system tray\n\nThe created `SystemTray` instance can be set using the `system_tray` API on the `tauri::Builder` struct:\n\n```rust\nuse tauri::{CustomMenuItem, SystemTray, SystemTrayMenu};\n\nfn main() {\n  let tray_menu = SystemTrayMenu::new(); // insert the menu items here\n  let system_tray = SystemTray::new()\n    .with_menu(tray_menu);\n  tauri::Builder::default()\n    .system_tray(system_tray)\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n### Listening to system tray events\n\nEach `CustomMenuItem` triggers an event when clicked.\nAlso, Tauri emits tray icon click events.\nUse the `on_system_tray_event` API to handle them:\n\n```rust\nuse tauri::{CustomMenuItem, SystemTray, SystemTrayMenu};\nuse tauri::Manager;\n\nfn main() {\n  let tray_menu = SystemTrayMenu::new(); // insert the menu items here\n  tauri::Builder::default()\n    .system_tray(SystemTray::new().with_menu(tray_menu))\n    .on_system_tray_event(|app, event| match event {\n      SystemTrayEvent::LeftClick {\n        position: _,\n        size: _,\n        ..\n      } => {\n        println!(\"system tray received a left click\");\n      }\n      SystemTrayEvent::RightClick {\n        position: _,\n        size: _,\n        ..\n      } => {\n        println!(\"system tray received a right click\");\n      }\n      SystemTrayEvent::DoubleClick {\n        position: _,\n        size: _,\n        ..\n      } => {\n        println!(\"system tray received a double click\");\n      }\n      SystemTrayEvent::MenuItemClick { id, .. } => {\n        match id.as_str() {\n          \"quit\" => {\n            std::process::exit(0);\n          }\n          \"hide\" => {\n            let window = app.get_window(\"main\").unwrap();\n            window.hide().unwrap();\n          }\n          _ => {}\n        }\n      }\n      _ => {}\n    })\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n### Updating system tray\n\nThe `AppHandle` struct has a `tray_handle` method, which returns a handle to the system tray allowing updating tray icon and context menu items:\n\n#### Updating context menu items\n\n```rust\nuse tauri::{CustomMenuItem, SystemTray, SystemTrayMenu};\nuse tauri::Manager;\n\nfn main() {\n  let tray_menu = SystemTrayMenu::new(); // insert the menu items here\n  tauri::Builder::default()\n    .system_tray(SystemTray::new().with_menu(tray_menu))\n    .on_system_tray_event(|app, event| match event {\n      SystemTrayEvent::MenuItemClick { id, .. } => {\n        // get a handle to the clicked menu item\n        // note that `tray_handle` can be called anywhere,\n        // just get a `AppHandle` instance with `app.handle()` on the setup hook\n        // and move it to another function or thread\n        let item_handle = app.tray_handle().get_item(&id);\n        match id.as_str() {\n          \"hide\" => {\n            let window = app.get_window(\"main\").unwrap();\n            window.hide().unwrap();\n            // you can also `set_selected`, `set_enabled` and `set_native_image` (macOS only).\n            item_handle.set_title(\"Show\").unwrap();\n          }\n          _ => {}\n        }\n      }\n      _ => {}\n    })\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n```\n\n#### Updating tray icon\n\nNote that `tauri::Icon` must be a `Path` variant on Linux, and `Raw` variant on Windows and macOS.\n\n```rust\napp.tray_handle().set_icon(tauri::Icon::Raw(include_bytes!(\"../path/to/myicon.ico\"))).unwrap();\n```\n","url":"https://tauri.studio/docs/docs/usage/guides/visual/system-tray"},{"id":"prose_docs_usage_guides_visual_window_customization_md","title":"Window Customization","sections":["Configuration","Creating a Custom Titlebar"],"subSections":["CSS","HTML","JS"],"code":["css","html","js"],"text":"\nTauri provides lots of options for customizing the look and feel of your app's window. You can create custom titlebars, have transparent windows, enforce size constraints, and more.\n\n## Configuration\n\nThere are three ways to change the window configuration:\n\n- [Through tauri.conf.json](https://tauri.studio/en/docs/api/config/#tauri.windows)\n- [Through the JS API](https://tauri.studio/en/docs/api/js/classes/window.windowmanager)\n- [Through the Window in Rust](https://tauri.studio/en/docs/api/rust/tauri/window/struct.window)\n\n## Creating a Custom Titlebar\n\nA common use of these window features is creating a custom titlebar. This short tutorial will guide you through that process.\n\n### CSS\n\nYou'll need to add some CSS for the titlebar to keep it at the top of the screen and style the buttons:\n\n```css\n.titlebar {\n  height: 30px;\n  background: #329ea3;\n  user-select: none;\n  display: flex;\n  justify-content: flex-end;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n}\n.titlebar-button {\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  width: 30px;\n  height: 30px;\n}\n.titlebar-button:hover {\n  background: #5bbec3;\n}\n```\n\n### HTML\n\nNow, you'll need to add the HTML for the titlebar. Put this at the top of your `<body>` tag:\n\n```html\n<div data-tauri-drag-region class=\"titlebar\">\n  <div class=\"titlebar-button\" id=\"titlebar-minimize\">\n    <img\n      src=\"https://api.iconify.design/mdi:window-minimize.svg\"\n      alt=\"minimize\"\n    />\n  </div>\n  <div class=\"titlebar-button\" id=\"titlebar-maximize\">\n    <img\n      src=\"https://api.iconify.design/mdi:window-maximize.svg\"\n      alt=\"maximize\"\n    />\n  </div>\n  <div class=\"titlebar-button\" id=\"titlebar-close\">\n    <img src=\"https://api.iconify.design/mdi:close.svg\" alt=\"close\" />\n  </div>\n</div>\n```\n\nNote that you may need to move the rest of your content down so that the titlebar doesn't cover it.\n\n### JS\n\nFinally, you'll need to make the buttons work:\n\n\n```js\nimport { appWindow } from '@tauri-apps/api/window'\ndocument\n  .getElementById('titlebar-minimize')\n  .addEventListener('click', () => appWindow.minimize())\ndocument\n  .getElementById('titlebar-maximize')\n  .addEventListener('click', () => appWindow.toggleMaximize())\ndocument\n  .getElementById('titlebar-close')\n  .addEventListener('click', () => appWindow.close())\n```\n","url":"https://tauri.studio/docs/docs/usage/guides/visual/window-customization"},{"id":"prose_docs_usage_guides_webdriver_ci_md","title":"Continuous Integration","sections":[],"subSections":[],"code":["yaml"],"text":"\nUtilizing Linux and some programs to create a fake display, it is possible to run [WebDriver] tests with\n[`tauri-driver`] on your CI. The following example will use the [WebdriverIO] example we [previously built together] and\nGitHub Actions.\n\nThis means the following assumptions:\n\n1. The Tauri application is in the repository root and the binary builds when running `cargo build --release`.\n2. The [WebDriverIO] test runner is in the `webdriver/webdriverio` directory and runs when `yarn test` is used in that\n   directory.\n\nThe following is a commented GitHub Actions workflow file at `.github/workflows/webdriver.yml`\n\n```yaml\n# run this action when the repository is pushed to\non: [ push ]\n\n# the name of our workflow\nname: WebDriver\n\njobs:\n  # a single job named test\n  test:\n    # the display name the test job\n    name: WebDriverIO Test Runner\n\n    # we want to run on the latest linux environment\n    runs-on: ubuntu-latest\n\n    # the steps our job runs **in order**\n    steps:\n      # checkout the code on the workflow runner\n      - uses: actions/checkout@v2\n\n      # install system dependencies that Tauri needs to compile on Linux.\n      # note the extra dependencies for `tauri-driver` to run which are `webkit2gtk-driver` and  `xvfb`\n      - name: Tauri dependencies\n        run: >-\n          sudo apt-get update &&\n          sudo apt-get install -y\n          libgtk-3-dev\n          libgtksourceview-3.0-dev\n          webkit2gtk-4.0\n          libappindicator3-dev\n          webkit2gtk-driver\n          xvfb\n\n      # install the latest Rust stable\n      - name: Rust stable\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n\n      # we run our rust tests before the webdriver tests to avoid testing a broken application\n      - name: Cargo test\n        uses: actions-rs/cargo@v1\n        with:\n          command: test\n\n      # build a release build of our application to be used during our WebdriverIO tests\n      - name: Cargo build\n        uses: actions-rs/cargo@v1\n        with:\n          command: build\n          args: --release\n\n      # install the latest stable node version at the time of writing\n      - name: Node v16\n        uses: actions/setup-node@v1\n        with:\n          node-version: 16.x\n\n      # install our Node.js dependencies with Yarn\n      - name: Yarn install\n        run: yarn install\n        working-directory: webdriver/webdriverio\n\n      # install the latest version of `tauri-driver`.\n      # note: the tauri-driver version is independent of any other Tauri versions\n      - name: Install tauri-driver\n        uses: actions-rs/cargo@v1\n        with:\n          command: install\n          args: tauri-driver\n\n      # run the WebdriverIO test suite.\n      # we run it through `xvfb-run` (the dependency we installed earlier) to have a fake\n      # display server which allows our application to run headless without any changes to the code\n      - name: WebdriverIO\n        run: xvfb-run yarn test\n        working-directory: webdriver/webdriverio\n```\n\n[WebDriver]: https://www.w3.org/TR/webdriver/\n[`tauri-driver`]: https://crates.io/crates/tauri-driver\n[WebdriverIO]: https://webdriver.io/\n[previously built together]: example/webdriverio\n","url":"https://tauri.studio/docs/docs/usage/guides/webdriver/ci"},{"id":"prose_docs_usage_guides_webdriver_introduction_md","title":"Introduction","sections":["System Dependencies","Example Application"],"subSections":["Linux","Windows"],"code":["sh"],"text":"import Alert from '@theme/Alert'\n\n<Alert title=\"Currently in pre-alpha\" type=\"info\" icon=\"info-alt\">\n\nWebdriver support for Tauri is still in pre-alpha. Tooling that is dedicated to it such as [tauri-driver] is still in\nactive development and may change as necessary over time. Additionally, only Windows and Linux are currently supported.\n</Alert>\n\n[WebDriver] is a standardized interface to interact with web documents that is primarily intended for automated testing.\nTauri supports the [WebDriver] interface by leveraging the native platform's [WebDriver] server underneath a\ncross-platform wrapper [`tauri-driver`].\n\n## System Dependencies\n\nInstall the latest [`tauri-driver`] or update an existing installation by running:\n\n```sh\ncargo install tauri-driver\n```\n\nBecause we currently utilize the platform's native [WebDriver] server, there are some requirements for running\n[`tauri-driver`] on supported platforms. Platform support is currently limited to Linux and Windows.\n\n### Linux\n\nWe use `WebKitWebDriver` on linux platforms. Check if this binary exists already (command `which WebKitWebDriver`) as\nsome distributions bundle it with the regular webkit package. Other platforms may have a separate package for them such\nas `webkit2gtk-driver` on Debian based distributions.\n\n### Windows\n\nMake sure to grab the version of [Microsoft Edge Driver] that matches your Windows' Edge version that the application is\nbeing built and tested on. On up-to-date Window installs, this should almost always be the latest stable version. If the\ntwo versions do not match, you may experience your WebDriver testing suite hanging while trying to connect.\n\nThe download contains a binary called `msedgedriver.exe`. [`tauri-driver`] looks for that binary in the `$PATH` so make\nsure it's either available on the path or use the `--native-driver` option on [`tauri-driver`]. On Windows CI machines,\nyou may want to download this automatically as part of the CI setup process to ensure the Edge and Edge Driver versions\nstay in sync. A guide on how to do this may be added at a later date.\n\n## Example Application\n\nThe [next section](example/setup) of the guide will show step-by-step how to create a minimal example application that\nis tested with WebDriver.\n\nIf you prefer to just see the result of the guide and look over a finished minimal codebase that utilizes it then you\ncan look at https://github.com/chippers/hello_tauri. That example also comes with a CI script to test with GitHub\nactions, but you may still be interested in the [WebDriver CI](ci) guide as it explains the concept a bit more.\n\n[WebDriver]: https://www.w3.org/TR/webdriver/\n[`tauri-driver`]: https://crates.io/crates/tauri-driver\n[tauri-driver]: https://crates.io/crates/tauri-driver\n[Microsoft Edge Driver]: https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/\n","url":"https://tauri.studio/docs/docs/usage/guides/webdriver/introduction"},{"id":"prose_docs_usage_guides_webdriver_example_selenium_md","title":"Selenium","sections":["Create a Directory for the Tests","Initializing a Selenium Project","Testing","Running the Test Suite"],"subSections":[],"code":["sh",null,"text"],"text":"import Alert from '@theme/Alert'\nimport Tabs from '@theme/Tabs'\nimport TabItem from '@theme/TabItem'\n\n<Alert title=\"Example Application\" type=\"info\" icon=\"info-alt\">\n\nThis [Selenium] guide expects you to have already gone through the [example Application setup] in order to follow\nstep-by-step. The general information may still be useful otherwise.\n</Alert>\n\nThis WebDriver testing example will use [Selenium] and a popular Node.js testing suite. It is expected to already have\nNode.js installed, along with `npm` or `yarn` although the [finished example project] uses `yarn`.\n\n## Create a Directory for the Tests\n\nLet's start off by creating a space in our project to write these tests. We are going to be using a nested directory for\nthis example project as we will later also go over other frameworks, but typically you will only need to use one. Create\nthe directory we will use with `mkdir -p webdriver/selenium`. The rest of this guide will assume you are inside the\n`webdriver/selenium` directory.\n\n## Initializing a Selenium Project\n\nWe will be using a pre-existing `package.json` to bootstrap this test suite because we have already chosen specific\ndependencies to use and want to showcase a simple working solution. The bottom of this section has a collapsed\nguide on how to set it up from scratch.\n\n`package.json`:\n```json\n{\n  \"name\": \"selenium\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"test\": \"mocha\"\n  },\n  \"dependencies\": {\n    \"chai\": \"^4.3.4\",\n    \"mocha\": \"^9.0.3\",\n    \"selenium-webdriver\": \"^4.0.0-beta.4\"\n  }\n}\n```\n\nWe have a script which runs [Mocha] as a test framework exposed as the `test` command. We also have various dependencies\nthat we will be using to run the tests. [Mocha] as the testing framework, [Chai] as the assertion library, and\n[`selenium-webdriver`] which is the Node.js [Selenium] package.\n\n<details><summary>Click me if you want to see how to set a project up from scratch</summary>\n\nIf you wanted to install the dependencies from scratch, just run the following command.\n\n<Tabs groupId=\"package-manager\"\ndefaultValue=\"yarn\"\nvalues={[\n{label: 'npm', value: 'npm'}, {label: 'Yarn', value: 'yarn'},\n]}>\n<TabItem value=\"npm\">\n\n```sh\nnpm install mocha chai selenium-webdriver\n```\n\n</TabItem>\n\n<TabItem value=\"yarn\">\n\n```sh\nyarn add mocha chai selenium-webdriver\n```\n\n</TabItem>\n</Tabs>\n\nI suggest also adding a `\"test\": \"mocha\"` item in the `package.json` `\"scripts\"` key so that running mocha can be called\nsimply with\n\n<Tabs groupId=\"package-manager\"\ndefaultValue=\"yarn\"\nvalues={[\n{label: 'npm', value: 'npm'}, {label: 'Yarn', value: 'yarn'},\n]}>\n<TabItem value=\"npm\">\n\n```sh\nnpm test\n```\n\n</TabItem>\n\n<TabItem value=\"yarn\">\n\n```sh\nyarn test\n```\n\n</TabItem>\n</Tabs>\n\n</details>\n\n## Testing\n\nUnlike the [WebdriverIO Test Suite](webdriverio#config), Selenium does not come out of the box with a Test Suite and\nleaves it up to the developer to build those out. We chose [Mocha] which is pretty neutral, and not related to WebDrivers\nat all, so our script will need to do a bit of work to set up everything for us in the right order. [Mocha] expects a\ntesting file at `test/test.js` by default, so let's create that file now.\n\n`test/test.js`:\n```js\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst { expect } = require(\"chai\");\nconst { spawn, spawnSync } = require(\"child_process\");\nconst { Builder, By, Capabilities } = require(\"selenium-webdriver\");\n\n// create the path to the expected application binary\nconst application = path.resolve(\n  __dirname,\n  \"..\",\n  \"..\",\n  \"..\",\n  \"target\",\n  \"release\",\n  \"hello-tauri-webdriver\"\n);\n\n// keep track of the webdriver instance we create\nlet driver;\n\n// keep track of the tauri-driver process we start\nlet tauriDriver;\n\nbefore(async function() {\n  // set timeout to 2 minutes to allow the program to build if it needs to\n  this.timeout(120000)\n\n  // ensure the program has been built\n  spawnSync(\"cargo\", [\"build\", \"--release\"]);\n\n  // start tauri-driver\n  tauriDriver = spawn(\n    path.resolve(os.homedir(), \".cargo\", \"bin\", \"tauri-driver\"),\n    [],\n    { stdio: [null, process.stdout, process.stderr] }\n  );\n\n  const capabilities = new Capabilities();\n  capabilities.set(\"tauri:options\", { application });\n  capabilities.setBrowserName(\"wry\");\n\n  // start the webdriver client\n  driver = await new Builder()\n    .withCapabilities(capabilities)\n    .usingServer(\"http://localhost:4444/\")\n    .build();\n});\n\nafter(async function() {\n  // stop the webdriver session\n  await driver.quit();\n\n  // kill the tauri-driver process\n  tauriDriver.kill();\n});\n\ndescribe(\"Hello Tauri\", () => {\n  it(\"should be cordial\", async () => {\n    const text = await driver.findElement(By.css(\"body > h1\")).getText();\n    expect(text).to.match(/^[hH]ello/);\n  });\n\n  it(\"should be excited\", async () => {\n    const text = await driver.findElement(By.css(\"body > h1\")).getText();\n    expect(text).to.match(/!$/);\n  });\n\n  it(\"should be easy on the eyes\", async () => {\n    // selenium returns color css values as rgb(r, g, b)\n    const text = await driver.findElement(By.css(\"body\")).getCssValue(\"background-color\");\n\n    const rgb = text.match(/^rgb\\((?<r>\\d+), (?<g>\\d+), (?<b>\\d+)\\)$/).groups;\n    expect(rgb).to.have.all.keys('r','g','b');\n\n    const luma =  0.2126 * rgb.r + 0.7152 * rgb.g  + 0.0722 * rgb.b ;\n    expect(luma).to.be.lessThan(100)\n  });\n});\n```\n\nIf you are familiar with JS testing frameworks, `describe`, `it`, and `expect` should look familiar. We also have\nsemi-complex `before()` and `after()` callbacks to setup and teardown mocha. Lines that are not the tests themselves\nhave comments explaining what the setup and teardown code is doing. If you were familiar with the Spec file from the\n[WebdriverIO example](webdriverio#spec), you will notice a lot more code that isn't tests, as we have to set up a few\nmore WebDriver related items.\n\n## Running the Test Suite\n\nNow that we are all set up with our dependencies and our test script, lets run it!\n\n<Tabs groupId=\"package-manager\"\ndefaultValue=\"yarn\"\nvalues={[\n{label: 'npm', value: 'npm'}, {label: 'Yarn', value: 'yarn'},\n]}>\n<TabItem value=\"npm\">\n\n```sh\nnpm test\n```\n\n</TabItem>\n\n<TabItem value=\"yarn\">\n\n```sh\nyarn test\n```\n\n</TabItem>\n</Tabs>\n\nWe should see output the following output:\n\n```text\n➜  selenium git:(main) ✗ yarn test\nyarn run v1.22.11\n$ mocha\n\n\n  Hello Tauri\n    ✔ should be cordial (120ms)\n    ✔ should be excited\n    ✔ should be easy on the eyes\n\n\n  3 passing (588ms)\n\nDone in 0.93s.\n```\n\nWe can see that our `Hello Tauri` sweet we created with `decribe` had all 3 items we created with `it` pass their\ntests!\n\nWith [Selenium] and some hooking up to a test suite, we just enabled e2e testing without modifying our Tauri\napplication at all!\n\n\n[Selenium]: https://selenium.dev/\n[finished example project]: https://github.com/chippers/hello_tauri\n[example Application setup]: setup\n[Mocha]: https://mochajs.org/\n[Chai]: https://www.chaijs.com/\n[`selenium-webdriver`]: https://www.npmjs.com/package/selenium-webdriver\n","url":"https://tauri.studio/docs/docs/usage/guides/webdriver/example/selenium"},{"id":"prose_docs_usage_guides_webdriver_example_setup_md","title":"Setup Example","sections":["Initializing a Cargo Project","Creating a Minimal Frontend","Adding Tauri to the Cargo Project","Tauri Configuration","Running the Example Application"],"subSections":[],"code":["html","toml","rust","json"],"text":"\nimport HelloTauriWebdriver from '@site/static/img/webdriver/hello-tauri-webdriver.png'\n\nThis example application is going to solely focus on adding WebDriver testing to an already existing project. To have a\nproject to test on in the next two sections, we are going to set up an extremely minimal Tauri application for use in\nour testing. We will not use the Tauri CLI, any frontend dependencies or build steps, and not be bundling the\napplication afterwards. This is to showcase exactly a minimal suite to show off adding WebDriver testing to an existing\napplication.\n\nIf you just want to see the finished example project that utilizes what will be shown in this example guide, then you\ncan see https://github.com/chippers/hello_tauri.\n\n## Initializing a Cargo Project\n\nWe want to create a new binary Cargo project to house this example application. We can easily do this from the command\nline with `cargo new hello-tauri-webdriver --bin` which will scaffold a minimal binary Cargo project for us. This\ndirectory will serve as the working directory for the rest of this guide, so make sure commands you run are inside this\nnew `hello-tauri-webdriver/` directory.\n\n## Creating a Minimal Frontend\n\nWe will create a minimal HTML file to act as the frontend to our example application. We will also be using a few things\nfrom this frontend later during our WebDriver tests.\n\nFirst, let's create our Tauri `distDir` that we know we will need once building the Tauri portion of the application.\n`mkdir dist` should create a new directory called `dist/` in which we will be placing the following `index.html` file.\n\n`dist/index.html`:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Hello Tauri!</title>\n    <style>\n        body {\n            /* Add a nice colorscheme */\n            background-color: #222831;\n            color: #ececec;\n\n            /* Make the body the exact size of the window */\n            margin: 0;\n            height: 100vh;\n            width: 100vw;\n\n            /* Vertically and horizontally center children of the body tag */\n            display: flex;\n            justify-content: center;\n            align-items: center;\n        }\n    </style>\n</head>\n<body>\n<h1>Hello, Tauri!</h1>\n</body>\n</html>\n```\n\n## Adding Tauri to the Cargo Project\n\nNext, we will add some necessary items to make our Cargo project into a Tauri project. First, is adding the dependencies\nto the Cargo Manifest (`Cargo.toml`) so that Cargo knows to pull in our dependencies while building.\n\n`Cargo.toml`:\n\n```toml\n[package]\nname = \"hello-tauri-webdriver\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n# Needed to set up some things for Tauri at build time\n[build-dependencies]\ntauri-build = \"1.0.0-beta.4\"\n\n# The actual Tauri dependency, along with `custom-protocol` to serve the pages.\n[dependencies]\ntauri = { version = \"1.0.0-beta.6\", features = [\"custom-protocol\"] }\n\n# Make --release build a binary that is small (opt-level = \"s\") and fast (lto = true).\n# This is completely optional, but shows that testing the application as close to the\n# typical release settings is possible. Note: this will slow down compilation.\n[profile.release]\nincremental = false\ncodegen-units = 1\npanic = \"abort\"\nopt-level = \"s\"\nlto = true\n```\n\nAs you may have noticed, we added a `[build-dependency]`. To use the build dependency, we must use it from a build\nscript. We will create one now at `build.rs`.\n\n`build.rs`:\n\n```rust\nfn main() {\n    // Only watch the `dist/` directory for recompiling, preventing unnecessary\n    // changes when we change files in other project subdirectories.\n    println!(\"cargo:rerun-if-changed=dist\");\n\n    // Run the Tauri build-time helpers\n    tauri_build::build()\n}\n```\n\nWith all that setup, our Cargo Project now knows how to pull in and build our Tauri dependencies. Let's finish making\nthis minimal example a Tauri application by setting up Tauri in the actual project code. We will be editing\nthe `src/main.rs`\nfile to add this Tauri functionality.\n\n`src/main.rs`:\n\n```rust\nfn main() {\n    tauri::Builder::default()\n        .run(tauri::generate_context!())\n        .expect(\"unable to run Tauri application\");\n}\n```\n\nPretty simple, right?\n\n## Tauri Configuration\n\nWe are going to need 2 things to successfully build the application. First, we need an icon file. You can use any PNG\nfor this next part and copy it into `icon.png`. Typically, this will be provided as part of the scaffolding when you use\nthe Tauri CLI to create a project. To get the default Tauri icon, we can download the icon used by the Hello Tauri\nexample repository with the\ncommand `curl -L \"https://github.com/chippers/hello_tauri/raw/main/icon.png\" --output icon.png`.\n\nThe second thing we will need is a `tauri.conf.json` to specify some important configuration values to Tauri. Again,\nthis would typically come from the `tauri init` scaffolding command, but we will be creating our own minimal config\nhere.\n\n`tauri.conf.json`:\n\n```json\n{\n  \"build\": {\n    \"distDir\": \"dist\"\n  },\n  \"tauri\": {\n    \"bundle\": {\n      \"identifier\": \"studio.tauri.hello_tauri_webdriver\",\n      \"icon\": [\n        \"icon.png\"\n      ]\n    },\n    \"allowlist\": {\n      \"all\": false\n    },\n    \"windows\": [\n      {\n        \"width\": 800,\n        \"height\": 600,\n        \"resizable\": true,\n        \"fullscreen\": false\n      }\n    ]\n  }\n}\n```\n\nI'll go over some of these. You can see the `dist/` directory we created earlier specified as the `distDir` property. We\nset a bundle identifier so that the built application has a unique id, along with setting the `icon.png` as the only\nicon. We aren't using any Tauri apis or features, so we just disable all them in `allowlist` by setting `\"all\": false`.\nThe window values just sets a single window to be created with some reasonable default values.\n\nAt this point, we have a basic Hello World application that when ran, should display a simple greeting.\n\n## Running the Example Application\n\nTo make sure we did it right, let's build this application! We will run this as a `--release` application because we\nwill also run our WebDriver tests with a release profile. Run `cargo run --release` and after some compiling we should\nsee the following application pop up.\n\n<div style={{textAlign: 'center'}}>\n    <img src={HelloTauriWebdriver}/>\n</div>\n\n_Note: If you are modifying the application and want to use the Devtools, then run it without `--release` and \"Inspect\nElement\" should be available in the right click menu._\n\nWe should now be ready to start testing this application with some WebDriver frameworks. This guide will go over both\n[WebdriverIO](webdriverio) and [Selenium](selenium) in that order.","url":"https://tauri.studio/docs/docs/usage/guides/webdriver/example/setup"},{"id":"prose_docs_usage_guides_webdriver_example_webdriverio_md","title":"WebdriverIO","sections":["Create a Directory for the Tests","Initializing a WebdriverIO Project","Config","Spec","Running the Test Suite"],"subSections":[],"code":["sh","text"],"text":"import Alert from '@theme/Alert'\nimport Tabs from '@theme/Tabs'\nimport TabItem from '@theme/TabItem'\n\n<Alert title=\"Example Application\" type=\"info\" icon=\"info-alt\">\n\nThis [WebdriverIO] guide expects you to have already gone through the [example Application setup] in order to follow\nstep-by-step. The general information may still be useful otherwise.\n</Alert>\n\nThis WebDriver testing example will use [WebdriverIO] and its testing suite. It is expected to already have Node.js\ninstalled, along with `npm` or `yarn` although the [finished example project] uses `yarn`.\n\n## Create a Directory for the Tests\n\nLet's start off by creating a space in our project to write these tests. We are going to be using a nested directory for\nthis example project as we will later also go over other frameworks, but typically you will only need to use one. Create\nthe directory we will use with `mkdir -p webdriver/webdriverio`. The rest of this guide will assume you are inside the\n`webdriver/webdriverio` directory.\n\n## Initializing a WebdriverIO Project\n\nWe will be using a pre-existing `package.json` to bootstrap this test suite because we have already chosen specific\n[WebdriverIO] config options and want to showcase a simple working solution. The bottom of this section has a collapsed\nguide on how to set it up from scratch.\n\n`package.json`:\n```json\n{\n  \"name\": \"webdriverio\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"test\": \"wdio run wdio.conf.js\"\n  },\n  \"dependencies\": {\n    \"@wdio/cli\": \"^7.9.1\"\n  },\n  \"devDependencies\": {\n    \"@wdio/local-runner\": \"^7.9.1\",\n    \"@wdio/mocha-framework\": \"^7.9.1\",\n    \"@wdio/spec-reporter\": \"^7.9.0\"\n  }\n}\n```\n\nWe have a script which runs a [WebdriverIO] config as a test suite exposed as the `test` command. We also have various\ndependencies that were added by the `@wdio/cli` command when we first set it up. In short, these dependencies are for\nthe most simple setup using a local WebDriver runner, [Mocha] as the test framework, and a simple Spec Reporter.\n\n<details><summary>Click me if you want to see how to set a project up from scratch</summary>\n\nThe CLI is interactive, and you may choose the tools to work with yourself. Note that you will likely diverge from\nthe rest of the guide, and need to set up the differences yourself.\n\nLet's add the [WebdriverIO] CLI to this npm project.\n\n<Tabs groupId=\"package-manager\"\ndefaultValue=\"yarn\"\nvalues={[\n{label: 'npm', value: 'npm'}, {label: 'Yarn', value: 'yarn'},\n]}>\n<TabItem value=\"npm\">\n\n```sh\nnpm install @wdio/cli\n```\n\n</TabItem>\n\n<TabItem value=\"yarn\">\n\n```sh\nyarn add @wdio/cli\n```\n\n</TabItem>\n</Tabs>\n\nTo then run the interactive config command to set up a [WebdriverIO] test suite, you can then run:\n\n<Tabs groupId=\"package-manager\"\ndefaultValue=\"yarn\"\nvalues={[\n{label: 'npm', value: 'npm'}, {label: 'Yarn', value: 'yarn'},\n]}>\n<TabItem value=\"npm\">\n\n```sh\nnpx wdio config\n```\n\n</TabItem>\n\n<TabItem value=\"yarn\">\n\n```sh\nyarn wdio config\n```\n\n</TabItem>\n</Tabs>\n\n</details>\n\n## Config\n\nYou may have noticed that the `test` script in our `package.json` mentions a file `wdio.conf.js`. That's the [WebdriverIO]\nconfig file which controls most aspects of our testing suite.\n\n`wdio.conf.js`:\n```js\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst { spawn, spawnSync } = require(\"child_process\");\n\n// keep track of the `tauri-driver` child process\nlet tauriDriver;\n\nexports.config = {\n  specs: [\"./test/specs/**/*.js\"],\n  maxInstances: 1,\n  capabilities: [\n    {\n      maxInstances: 1,\n      \"tauri:options\": {\n        application: \"../../target/release/hello-tauri-webdriver\",\n      },\n    },\n  ],\n  reporters: [\"spec\"],\n  framework: \"mocha\",\n  mochaOpts: {\n    ui: \"bdd\",\n    timeout: 60000,\n  },\n\n  // ensure the rust project is built since we expect this binary to exist for the webdriver sessions\n  onPrepare: () => spawnSync(\"cargo\", [\"build\", \"--release\"]),\n\n  // ensure we are running `tauri-driver` before the session starts so that we can proxy the webdriver requests\n  beforeSession: () =>\n    (tauriDriver = spawn(\n      path.resolve(os.homedir(), \".cargo\", \"bin\", \"tauri-driver\"),\n      [],\n      { stdio: [null, process.stdout, process.stderr] }\n    )),\n\n  // clean up the `tauri-driver` process we spawned at the start of the session\n  afterSession: () => tauriDriver.kill(),\n};\n```\n\nIf you are interested in the properties on `exports.config` object, then I [suggest reading the documentation] for it.\nFor non-WDIO specific items, there are comments explaining why we are running commands in `onPrepare`, `beforeSession`,\nand `afterSession`. We also have our specs set to `\"./test/specs/**/*.js\"`, so let's create a spec now.\n\n## Spec\n\nA spec contains the code that is testing your actual application. The test runner will load these specs and automatically\nrun them as it sees fit. Let's create our spec now in the directory we specified.\n\n`test/specs/example.e2e.js`:\n```js\n// calculates the luma from a hex color `#abcdef`\nfunction luma(hex) {\n  if (hex.startsWith(\"#\")) {\n    hex = hex.substring(1);\n  }\n\n  const rgb = parseInt(hex, 16);\n  const r = (rgb >> 16) & 0xff;\n  const g = (rgb >> 8) & 0xff;\n  const b = (rgb >> 0) & 0xff;\n  return  0.2126 * r + 0.7152 * g + 0.0722 * b;\n}\n\ndescribe(\"Hello Tauri\", () => {\n  it(\"should be cordial\", async () => {\n    const header = await $(\"body > h1\");\n    const text = await header.getText();\n    expect(text).toMatch(/^[hH]ello/);\n  });\n\n  it(\"should be excited\", async () => {\n    const header = await $(\"body > h1\");\n    const text = await header.getText();\n    expect(text).toMatch(/!$/);\n  });\n\n  it(\"should be easy on the eyes\", async () => {\n    const body = await $(\"body\");\n    const backgroundColor = await body.getCSSProperty(\"background-color\");\n    expect(luma(backgroundColor.parsed.hex)).toBeLessThan(100);\n  });\n});\n```\n\nThe `luma` function on top is just a helper function for one of our tests and is not related to the actual testing of\nthe application. If you are familiar with other testing frameworks, you may notice similar functions being exposed that\nare used such as `describe`, `it`, and `expect`. The other APIs, such as items like `$` and the methods it exposes is\ncovered by the [WebdriverIO API docs](https://webdriver.io/docs/api).\n\n## Running the Test Suite\n\nNow that we are all set up with a config and a spec, let's run it!\n\n<Tabs groupId=\"package-manager\"\ndefaultValue=\"yarn\"\nvalues={[\n{label: 'npm', value: 'npm'}, {label: 'Yarn', value: 'yarn'},\n]}>\n<TabItem value=\"npm\">\n\n```sh\nnpm test\n```\n\n</TabItem>\n\n<TabItem value=\"yarn\">\n\n```sh\nyarn test\n```\n\n</TabItem>\n</Tabs>\n\nWe should see output the following output:\n\n```text\n➜  webdriverio git:(main) ✗ yarn test\nyarn run v1.22.11\n$ wdio run wdio.conf.js\n\nExecution of 1 workers started at 2021-08-17T08:06:10.279Z\n\n[0-0] RUNNING in undefined - /test/specs/example.e2e.js\n[0-0] PASSED in undefined - /test/specs/example.e2e.js\n\n \"spec\" Reporter:\n------------------------------------------------------------------\n[wry 0.12.1 linux #0-0] Running: wry (v0.12.1) on linux\n[wry 0.12.1 linux #0-0] Session ID: 81e0107b-4d38-4eed-9b10-ee80ca47bb83\n[wry 0.12.1 linux #0-0]\n[wry 0.12.1 linux #0-0] » /test/specs/example.e2e.js\n[wry 0.12.1 linux #0-0] Hello Tauri\n[wry 0.12.1 linux #0-0]    ✓ should be cordial\n[wry 0.12.1 linux #0-0]    ✓ should be excited\n[wry 0.12.1 linux #0-0]    ✓ should be easy on the eyes\n[wry 0.12.1 linux #0-0]\n[wry 0.12.1 linux #0-0] 3 passing (244ms)\n\n\nSpec Files:\t 1 passed, 1 total (100% completed) in 00:00:01\n\nDone in 1.98s.\n```\n\nWe see the Spec Reporter tell us that all 3 tests from the `test/specs/example.e2e.js` file, along with the final report\n`Spec Files:\t 1 passed, 1 total (100% completed) in 00:00:01`.\n\nUsing the [WebdriverIO] test suite, we just easily enabled e2e testing for our Tauri application from just a few lines\nof configuration and a single command to run it! Even better, we didn't have to modify the application at all.\n\n\n[WebdriverIO]: https://webdriver.io/\n[finished example project]: https://github.com/chippers/hello_tauri\n[example Application setup]: setup\n[Mocha]: https://mochajs.org/\n[suggest reading the documentation]: (https://webdriver.io/docs/configurationfile)\n","url":"https://tauri.studio/docs/docs/usage/guides/webdriver/example/webdriverio"},{"id":"prose_docs_usage_patterns_about_patterns_md","title":"A word on patterns","sections":[],"subSections":[],"code":[],"text":"\nTauri patterns are descriptions of use-cases that are entirely configurable within the `src-tauri/tauri.conf.json` file. These are not the limits of what Tauri can do, and there are probably more out there. If you discover one, why not get in touch and help us update this collection!\n\nIf you haven't read about the general design of Tauri, then it would make the most sense for you to visit the [\"Getting started\"](/docs/getting-started/intro) and become familiar with the basic architecture and terminology used in these patterns. \n","url":"https://tauri.studio/docs/docs/usage/patterns/about-patterns"},{"id":"prose_docs_usage_patterns_bridge_md","title":"Bridge","sections":["Description","Diagram","Configuration"],"subSections":[],"code":[],"text":"\nimport Rater from '@theme/Rater'\nimport useBaseUrl from '@docusaurus/useBaseUrl'\n\n<div className=\"row\">\n  <div className=\"col col--4\">\n    <table>\n      <tr>\n        <td>Ease of Use</td>\n        <td><Rater value=\"3\"/></td>\n      </tr>\n      <tr>\n        <td>Extensibility</td>\n        <td><Rater value=\"5\"/></td>\n      </tr>\n      <tr>\n        <td>Performance</td>\n        <td><Rater value=\"4\"/></td>\n      </tr>\n      <tr>\n        <td>Security</td>\n        <td><Rater value=\"4\"/></td>\n      </tr>\n    </table>\n  </div>\n  <div className=\"col col--4 pattern-logo\">\n    <img src={useBaseUrl('img/patterns/Bridge.png')} alt=\"Bridge\" />\n  </div>\n    <div className=\"col col--4\">\n    Pros:\n    <ul>\n      <li>Highly configurable</li>\n      <li>No Rust skills required</li>\n    </ul>\n    Cons:\n    <ul>\n      <li>Some WebAPIs unavailable</li>\n      <li>Challenge to implement</li>\n    </ul>\n  </div>\n</div>\n\n## Description\n\nThe Bridge recipe is a secure pattern where messages are passed between brokers via an implicit bridge using the API. It isolates functionality to scope and passes messages instead of functionality.\n\n## Diagram\n\nimport Mermaid, { colors } from '@theme/Mermaid'\n\n<Mermaid chart={`graph TD\n      H==>F\n      subgraph WEBVIEW\n      F-.-E\n      end\n      D-->E\n      E-->D\n      B-->D\n      D-->B\n      subgraph RUST\n      A==>H\n      A-->B\n      B-.-C\n      B-.-G\n      end\n      A[Binary]\n      B{Rust Broker}\n      C[Subprocess 2]\n      G[Subprocess 1]\n      D(( API BRIDGE ))\n      E{JS Broker}\n      F[Window]\n      H{Bootstrap}\n      style D fill:#ccc,stroke:#333,stroke-width:4px,color:white\n      style RUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\n      style WEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`} />\n\n## Configuration\n\nHere's what you need to add to your tauri.conf.json file:\n```json\n\"tauri\": {\n  \"allowlist\": {                  // all API values are default false\n    \"all\": false,                 // use this flag to enable all API features\n    \"shell\": {\n      \"execute\": false,             // enable application execution\n      \"open\": false,                // open link/path in the default app\n    },\n    \"fs\": {\n      \"listFiles\": false,           // list files in a directory\n      \"readBinaryFile\": false,      // read binary file from local filesystem\n      \"readTextFile\": false,        // read text file from local filesystem\n      \"setTitle\": false,            // set the window title\n      \"writeFile\": false            // write file to local filesystem\n    }\n  }\n}\n\n```\n","url":"https://tauri.studio/docs/docs/usage/patterns/bridge"},{"id":"prose_docs_usage_patterns_cloudbridge_md","title":"Cloudbridge","sections":["Description","Diagram","Configuration"],"subSections":[],"code":[],"text":"\nimport Rater from '@theme/Rater'\nimport useBaseUrl from '@docusaurus/useBaseUrl'\n\n<div className=\"row\">\n  <div className=\"col col--4\">\n    <table>\n      <tr>\n        <td>Ease of Use</td>\n        <td><Rater value=\"1\"/></td>\n      </tr>\n      <tr>\n        <td>Extensibility</td>\n        <td><Rater value=\"5\"/></td>\n      </tr>\n      <tr>\n        <td>Performance</td>\n        <td><Rater value=\"3\"/></td>\n      </tr>\n      <tr>\n        <td>Security</td>\n        <td><Rater value=\"2\"/></td>\n      </tr>\n    </table>\n  </div>\n  <div className=\"col col--4 pattern-logo\">\n    <img src={useBaseUrl('img/patterns/Cloudbridge.png')} alt=\"Cloudbridge\" />\n  </div>\n    <div className=\"col col--4\">\n    Pros:\n    <ul>\n      <li>All available features</li>\n      <li>No Rust skills required</li>\n    </ul>\n    Cons:\n    <ul>\n      <li>Largest bundle size</li>\n      <li>Hard to separate concerns</li>\n    </ul>\n  </div>\n</div>\n\n## Description\n\nThe Cloudbridge recipe combines the flexibility of a localhost and the security of the bridge. With so many features, it can be easy to get lost.\n\n## Diagram\n\nimport Mermaid, { colors } from '@theme/Mermaid'\n\n<Mermaid chart={`graph TD\n      H==>F2\n      H==>D2\n      D2-->F2\n      F2-->D2\n      B-->D\n      D-->B\n      E2-->D\n      D-->E2\n      subgraph WEBVIEW\n      F2\n      E2\n      end\n      subgraph SERVER\n      D2\n      E-->D2\n      end\n      subgraph RUST\n      A==>H\n      A-->B\n      B-.-C\n      end\n      A[Binary]\n      B{Rust Broker}\n      C[Subprocess]\n      D(( API BRIDGE ))\n      E{JS Broker}\n      D2(( localhost ))\n      E[bundled resources]\n      E2{JS Broker}\n      F2[Window]\n      H{Bootstrap}\n      style D fill:#ccc,stroke:#333,stroke-width:4px,color:white\n      style RUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\n      style WEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\n      style SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px\n      `} />\n\n\n## Configuration\n\nHere's what you need to add to your tauri.conf.json file:\n```json\n\"tauri\": {\n  \"allowlist\": {\n    \"all\": true                   // enable entire API\n  }\n}\n```\n","url":"https://tauri.studio/docs/docs/usage/patterns/cloudbridge"},{"id":"prose_docs_usage_patterns_cloudish_md","title":"Cloudish","sections":["Description","Diagram","Configuration"],"subSections":[],"code":[],"text":"\nimport Rater from '@theme/Rater'\nimport useBaseUrl from '@docusaurus/useBaseUrl'\n\n<div className=\"row\">\n  <div className=\"col col--4\">\n    <table>\n      <tr>\n        <td>Ease of Use</td>\n        <td><Rater value=\"5\"/></td>\n      </tr>\n      <tr>\n        <td>Extensibility</td>\n        <td><Rater value=\"3\"/></td>\n      </tr>\n      <tr>\n        <td>Performance</td>\n        <td><Rater value=\"3\"/></td>\n      </tr>\n      <tr>\n        <td>Security</td>\n        <td><Rater value=\"2\"/></td>\n      </tr>\n    </table>\n  </div>\n  <div className=\"col col--4 pattern-logo\">\n    <img src={useBaseUrl('img/patterns/Cloudish.png')} alt=\"Cloudish\" />\n  </div>\n    <div className=\"col col--4\">\n    Pros:\n    <ul>\n      <li>Similar to a SPA web-app</li>\n      <li>No Rust skills required</li>\n    </ul>\n    Cons:\n    <ul>\n      <li>No access to Rust API</li>\n      <li>Uses a localhost server</li>\n    </ul>\n  </div>\n</div>\n\n## Description\n\nThe Cloudish recipe is a pattern for maximum flexibility and app performance. It uses a localhost server, which means that your app will technically be available to other processes, like browsers and potentially other devices on the network. All of your assets are baked into the binary, but served as if they were distinct files.\n\n## Diagram\n\nimport Mermaid, { colors } from '@theme/Mermaid'\n\n<Mermaid chart={`graph TD\n      H==>F\n      H==>D\n      D-->F\n      F-->D\n      subgraph RUST\n      A==>H\n      end\n      subgraph WEBVIEW\n      F\n      end\n      subgraph SERVER\n      D\n      E-->D\n      end\n      A[Binary]\n      D(( localhost ))\n      E[bundled resources]\n      F[Window]\n      H{Bootstrap}\n      style RUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\n      style WEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\n      style SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px`} />\n\n\n## Configuration\n\nHere's what you need to add to your tauri.conf.json file:\n```json\n\"tauri\": {\n  \"allowlist\": {\n    \"all\": false                  // disable entire API\n  }\n}\n\n```\n","url":"https://tauri.studio/docs/docs/usage/patterns/cloudish"},{"id":"prose_docs_usage_patterns_glui_md","title":"GLUI","sections":["Description","Diagram","Configuration"],"subSections":[],"code":[],"text":"\nimport Alert from '@theme/Alert'\nimport useBaseUrl from '@docusaurus/useBaseUrl'\n\n<Alert type=\"warning\" icon=\"info-alt\" title=\"Please note\">\nThis pattern is not available for now.\n</Alert>\n\nimport Rater from '@theme/Rater'\n\n<div className=\"row\">\n  <div className=\"col col--4\">\n    <table>\n      <tr>\n        <td>Ease of Use</td>\n        <td><Rater value=\"0\"/></td>\n      </tr>\n      <tr>\n        <td>Extensibility</td>\n        <td><Rater value=\"0\"/></td>\n      </tr>\n      <tr>\n        <td>Performance</td>\n        <td><Rater value=\"5\"/></td>\n      </tr>\n      <tr>\n        <td>Security</td>\n        <td><Rater value=\"0\"/></td>\n      </tr>\n    </table>\n  </div>\n  <div className=\"col col--4 pattern-logo\">\n    <img src={useBaseUrl('img/patterns/GLUI.png')} alt=\"GLUI\" />\n  </div>\n  <div className=\"col col--4\">\n    Pros:\n    <ul>\n      <li>Framebuffer FTW</li>\n      <li>Window events rigged</li>\n    </ul>\n    Cons:\n    <ul>\n      <li>Broken on your machine</li>\n    </ul>\n  </div>\n</div>\n\n## Description\n\nThe GLUI is a research pattern that we will use internally to test approaches using a GLUTIN window. We’re not sure yet if it will make the final cut as a bona fide alternative to WebView, although early tests with transparent and multiwindow are exciting.\n\n## Diagram\n\nimport Mermaid, { colors } from '@theme/Mermaid'\n\n<Mermaid chart={`graph TD\n      A==>H\n      H==>G\n      A-->D\n      D-->G\n      subgraph GLUTIN\n      G\n      end\n      subgraph RUST\n      A\n      end\n      A[Binary]\n      D(Framebuffer)\n      G[GL Window]\n      H{Bootstrap}\n      style GLUTIN stroke:${colors.blue.dark},stroke-width:4px\n      style RUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px`} />\n\n\n## Configuration\n\nHere's what you need to add to your tauri.conf.json file:\n```json\n\"tauri\": {\n  \"allowlist\": {                  // all API endpoints are default false\n    \"all\": false,                 // disable the api\n  },\n  \"window\": {                     // not yet normative\n    \"glutin\": true,\n    \"webview\": false\n  }\n}\n```\n","url":"https://tauri.studio/docs/docs/usage/patterns/glui"},{"id":"prose_docs_usage_patterns_hermit_md","title":"Hermit","sections":["Description","Diagram","Configuration"],"subSections":[],"code":["json"],"text":"\nimport Rater from '@theme/Rater'\nimport useBaseUrl from '@docusaurus/useBaseUrl'\n\n<div className=\"row\">\n  <div className=\"col col--4\">\n    <table>\n      <tr>\n        <td>Ease of Use</td>\n        <td><Rater value=\"5\"/></td>\n      </tr>\n      <tr>\n        <td>Extensibility</td>\n        <td><Rater value=\"0\"/></td>\n      </tr>\n      <tr>\n        <td>Performance</td>\n        <td><Rater value=\"5\"/></td>\n      </tr>\n      <tr>\n        <td>Security</td>\n        <td><Rater value=\"5\"/></td>\n      </tr>\n    </table>\n  </div>\n  <div className=\"col col--4 pattern-logo\">\n    <img src={useBaseUrl('img/patterns/Hermit.png')} alt=\"Hermit\" />\n  </div>\n    <div className=\"col col--4\">\n    Pros:\n    <ul>\n      <li>Quick to make</li>\n      <li>Smallest size</li>\n    </ul>\n    Cons:\n    <ul>\n      <li>No remote resources</li>\n      <li>No access to API</li>\n    </ul>\n  </div>\n</div>\n\n## Description\n\nThe Hermit recipe is a pattern for ultimate application isolation where all logic is self-contained in the Window and the binary exists merely to bootstrap the Window. There is no communication back to Rust from the Window, there is no localhost server, and the Window has no access to any remote resources. The Hermit is great for interactive Kiosk Mode and standalone HTML based games.\n\n## Diagram\n\nimport Mermaid, { colors } from '@theme/Mermaid'\n\n<Mermaid chart={`graph LR\n      A==>H\n      H==>F\n      subgraph WEBVIEW\n      F\n      end\n      subgraph RUST\n      A\n      end\n      A[fa:fa-cog Binary ]\n      F[fa:fa-window-maximize Window]\n      H{Bootstrap}\n      style RUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\n      style WEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`} />\n\n## Configuration\n\nHere's what you need to add to your tauri.conf.json file:\n\n```json\n\"tauri\": {\n  \"allowlist\": {\n    \"all\": false,       // disable and tree-shake all api functions\n  }\n}\n```\n","url":"https://tauri.studio/docs/docs/usage/patterns/hermit"},{"id":"prose_docs_usage_patterns_lockdown_md","title":"Lockdown","sections":["Description","Diagram","Configuration"],"subSections":[],"code":[],"text":"\nimport Rater from '@theme/Rater'\nimport useBaseUrl from '@docusaurus/useBaseUrl'\n\n<div className=\"row\">\n  <div className=\"col col--4\">\n    <table>\n      <tr>\n        <td>Ease of Use</td>\n        <td><Rater value=\"2\"/></td>\n      </tr>\n      <tr>\n        <td>Extensibility</td>\n        <td><Rater value=\"4\"/></td>\n      </tr>\n      <tr>\n        <td>Performance</td>\n        <td><Rater value=\"5\"/></td>\n      </tr>\n      <tr>\n        <td>Security</td>\n        <td><Rater value=\"5\" color=\"#fff04d\"/></td>\n      </tr>\n    </table>\n  </div>\n  <div className=\"col col--4 pattern-logo\">\n    <img src={useBaseUrl('img/patterns/Lockdown.png')} alt=\"Lockdown\" />\n  </div>\n  <div className=\"col col--4\">\n    Pros:\n    <ul>\n      <li>Highest security rating</li>\n      <li>Elegant and powerful</li>\n    </ul>\n    Cons:\n    <ul>\n      <li>Rust skills required</li>\n      <li>No remote resources</li>\n    </ul>\n  </div>\n</div>\n\n\n## Description\n\nThe Lockdown recipe is a minimal usage of the [Bridge pattern](/docs/usage/patterns/bridge), which only allows interaction between Rust and the Window via expiring JS Promise Closures that are injected into the Window by Rust and nulled as part of the callback.\n\n## Diagram\n\nimport Mermaid, { colors } from '@theme/Mermaid'\n\n<Mermaid chart={`graph TD\n      H==>F\n      G-.->B\n      B-->G\n      subgraph WEBVIEW\n      G-->F\n      end\n      subgraph RUST\n      A-->B\n      A==>H\n      end\n      A[Binary]\n      B[API:Event]\n      F[Window]\n      G((Promise Closure))\n      H{Bootstrap}\n      style RUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\n      style WEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`} />\n\n\n## Configuration\n\nHere's what you need to add to your tauri.conf.json file:\n```json\n\"tauri\": {\n  \"allowlist\": {}                  // all API endpoints are default false\n}\n```\n","url":"https://tauri.studio/docs/docs/usage/patterns/lockdown"},{"id":"prose_docs_usage_patterns_multiwin_md","title":"Multiwin","sections":["Description","Diagram","Configuration"],"subSections":[],"code":[],"text":"\nimport Alert from '@theme/Alert'\nimport useBaseUrl from '@docusaurus/useBaseUrl'\n\nimport Rater from '@theme/Rater'\n\n<div className=\"row\">\n  <div className=\"col col--4\">\n    <table>\n      <tr>\n        <td>Ease of Use</td>\n        <td><Rater value=\"4\"/></td>\n      </tr>\n      <tr>\n        <td>Extensibility</td>\n        <td><Rater value=\"4\"/></td>\n      </tr>\n      <tr>\n        <td>Performance</td>\n        <td><Rater value=\"3\"/></td>\n      </tr>\n      <tr>\n        <td>Security</td>\n        <td><Rater value=\"5\"/></td>\n      </tr>\n    </table>\n  </div>\n  <div className=\"col col--4 pattern-logo\">\n    <img src={useBaseUrl('img/patterns/Multiwin.png')} alt=\"Multiwin\" />\n  </div>\n  <div className=\"col col--4\">\n    Pros:\n    <ul>\n      <li>Windows can be spawned or destroyed at runtime</li>\n      <li>Separation of concerns</li>\n    </ul>\n    Cons:\n    <ul>\n      <li>Somewhat complex</li>\n    </ul>\n  </div>\n</div>\n\n## Description\n\nThe Multiwin recipe will allow you to have multiple windows.\n\n## Diagram\n\nimport Mermaid, { colors } from '@theme/Mermaid'\n\n<Mermaid chart={`graph LR\n      A==>H\n      H==>F\n      H==>G\n      subgraph WEBVIEW\n      F\n      end\n      subgraph WINIT\n      G\n      end\n      subgraph RUST\n      A\n      end\n      A[Binary]\n      F[Window]\n      G[Window]\n      H{Bootstrap}\n      style WINIT stroke:${colors.blue.dark},stroke-width:4px\n      style RUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\n      style WEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`} />\n\n\n## Configuration\n\nHere's what you need to add to your tauri.conf.json file:\n```json\n\"tauri\": {\n  \"allowlist\": {},                  // all API endpoints are default false\n  \"windows\": [{\n    \"title\": \"Window1\",\n    \"label\": \"main\",\n  }, {\n    \"title\": \"Splash\",\n    \"label\": \"splashscreen\"\n  }]\n}\n\n```\n","url":"https://tauri.studio/docs/docs/usage/patterns/multiwin"}]