[{"id":"prose_docs_architecture_md","title":"The Tauri Architecture","headings":["What does the Release flow look like"],"subHeadings":[],"code":[null],"text":"# The Tauri Architecture ## Introduction Tauri is a polyglot and generic toolkit\nthat is very composable and allows engineers to make a wide variety of\napplications. It is used for building applications for Desktop Computers using a\ncombination of Rust tools and HTML rendered in a Webview. Apps built with Tauri\ncan ship with any number of pieces of an optional JS API / Rust API so that\nwebviews can control the system via message passing. In fact, developers can\nextend the default API with their own functionality and bridge the Webview and\nRust-based backend easily. Tauri apps can have custom menus and have tray-type\ninterfaces. They can be updated, and are managed by the user's operating system\nas expected. They are very small, because they use the OS's webview. They do not\nship a runtime, since the final binary is compiled from Rust. This makes the\nreversing of Tauri apps not a trivial task. ## What Tauri is NOT - Tauri is not\na lightweight kernel wrapper...instead it directly uses [WRY](#wry) and\n[TAO](#tao) to do the heavy-lifting in making system calls to the OS. - Tauri is\nnot a VM or virtualized environment...instead it is an application toolkit that\nallows making Webview OS applications. ## Major Components The following section\nbriefly describes the roles of the various parts of Tauri. ### Tauri Core\n[STABLE RUST] ####\n[tauri](https://github.com/tauri-apps/tauri/tree/dev/core/tauri) This is the\nmajor crate that holds everything together. It brings the runtimes, macros,\nutilities and API into one final product. It reads the `tauri.conf.json` file at\ncompile time in order to bring in features and undertake actual configuration of\nthe app (and even the `Cargo.toml` file in the project's folder). It handles\nscript injection (for polyfills / prototype revision) at runtime, hosts the API\nfor systems interaction, and even manages updating. ####\n[tauri-build](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-build)\nApply the macros at build-time in order to rig some special features needed by\n`cargo`. ####\n[tauri-codegen](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-codegen)\n- Embed, hash, and compress assets, including icons for the app as well as the\nsystem-tray. - Parse `tauri.conf.json` at compile time and generate the Config\nstruct. ####\n[tauri-macros](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-macros)\nCreate macros for the context, handler, and commands by leveraging the\n`tauri-codegen` crate. ####\n[tauri-runtime](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime)\nThis is the glue layer between tauri itself and lower level webview libraries.\n####\n[tauri-runtime-wry](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime-wry)\nThis crate opens up direct systems-level interactions specifically for WRY, such\nas printing, monitor detection, and other windowing related tasks.\n`tauri-runtime` implementation for WRY. ####\n[tauri-utils](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-utils)\nThis is common code that is reused in many places and offers useful utilities\nlike parsing configuration files, detecting platform triples, injecting the CSP,\nand managing assets. ### Tauri Tooling ####\n[api](https://github.com/tauri-apps/tauri/tree/dev/tooling/api) [TS -> JS] A\ntypescript library that creates `cjs` and `esm` Javascript endpoints for you to\nimport into your Frontend framework so that the Webview can call and listen to\nbackend activity. We also ship the pure typescript, because for some frameworks\nthis is more optimal. It uses the message passing of webviews to their hosts.\n#### [bundler](https://github.com/tauri-apps/tauri/tree/dev/tooling/bundler)\n[RUST / SHELL] The bundler is a library that builds a Tauri App for the platform\ntriple it detects / is told. At the moment it currently supports macOS, Windows\nand Linux - but in the near future will support mobile platforms as well. May be\nused outside of Tauri projects. ####\n[cli.js](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli.js) [JS]\nWritten in Typescript and packaged such that it can be used with `npm`, `pnpm`,\nand `yarn`, this library provides a node.js runner for common tasks when using\nTauri, like `yarn tauri dev`. For the most part it is a wrapper around\n[cli.rs](https://github.com/tauri-apps/tauri/blob/dev/tooling/cli). ####\n[cli.rs](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli) [RUST] This\nrust executable provides the full interface to all of the required activities\nfor which the CLI is required. It will run on macOS, Windows, and Linux. ####\n[create-tauri-app](https://github.com/tauri-apps/tauri/tree/dev/tooling/create-tauri-app)\n[JS] This is a toolkit that will enable engineering teams to rapidly scaffold\nout a new tauri-apps project using the frontend framework of their choice (as\nlong as it has been configured). # External Crates The Tauri-Apps organisation\nmaintains two \"upstream\" crates from Tauri, namely TAO for creating and managing\napplication windows, and WRY for interfacing with the Webview that lives within\nthe window. ## [TAO](https://github.com/tauri-apps/tao) Cross-platform\napplication window creation library in Rust that supports all major platforms\nlike Windows, macOS, Linux, iOS and Android. Written in Rust, it is a fork of\n[winit](https://github.com/rust-windowing/winit) that we have extended for our\nown needs like menu bar and system tray. ##\n[WRY](https://github.com/tauri-apps/wry) WRY is a cross-platform WebView\nrendering library in Rust that supports all major desktop platforms like\nWindows, macOS, and Linux. Tauri uses WRY as the abstract layer responsible to\ndetermine which webview is used (and how interactions are made). ##\n[tauri-hotkey-rs](https://github.com/tauri-apps/tauri-hotkey-rs) We needed to\nfix hotkey to work on all platforms, because upstream was not being responsive.\n# Additional tooling ##\n[binary-releases](https://github.com/tauri-apps/binary-releases) This is the\ndelivery mechanism for tauri prebuilt binaries: currently the cli.rs (used by\ncli.js) and rustup binaries (used by the deps install command of cli.js). These\nartifacts are automatically created on release. ##\n[tauri-action](https://github.com/tauri-apps/tauri-action) This is a github\nworkflow that builds tauri binaries for all platforms. It is not the fastest out\nthere, but it gets the job done and is highly configurable. Even allowing you to\ncreate a (very basic) tauri app even if tauri is not setup. ##\n[create-pull-request](https://github.com/tauri-apps/create-pull-request) Because\nthis is a very risky (potentially destructive) github action, we forked it in\norder to have strong guarantees that the code we think is running is actually\nthe code that is running. ##\n[vue-cli-plugin-tauri](https://github.com/tauri-apps/vue-cli-plugin-tauri) This\nplugin allows you to very quickly install tauri in a vue-cli project. ##\n[tauri-vscode](https://github.com/tauri-apps/tauri-vscode) This project enhances\nthe VS Code interface with several nice-to-have features. # Tauri Plugins\n[documentation](https://tauri.studio/en/docs/guides/plugin) Generally speaking,\nplugins are authored by third parties (even though there may be official,\nsupported plugins). A plugin generally does 3 things: 1. It provides rust code\nto do \"something\". 2. It provides interface glue to make it easy to integrate\ninto an app. 3. It provides a JS API for interfacing with the rust code. Here\nare several examples of Tauri Plugins: -\nhttps://github.com/tauri-apps/tauri-plugin-sql -\nhttps://github.com/tauri-apps/tauri-plugin-stronghold -\nhttps://github.com/tauri-apps/tauri-plugin-authenticator # Workflows ## What\ndoes the Development flow look like? A developer must first install the\nprerequisite toolchains for creating a Tauri app. At the very least this will\nentail installing rust & cargo, and most likely also a modern version of node.js\nand potentially another package manager. Some platforms may also require other\ntooling and libraries, but this has been documented carefully in the respective\nplatform docs. Because of the many ways to build front-ends, we will stick with\na common node.js based approach for development. (Note: Tauri does not by\ndefault ship a node.js runtime.) The easiest way to do this is to run the\nfollowing: ``` npx create-tauri-app ``` Which will ask you a bunch of questions\nabout the framework you want to install and then create everything you need in a\nsingle folder - some via the placement of template files and some through normal\ninstallation procedures of your framework. > If you don't use this process, you\nwill have to manually install the tauri cli, initialise tauri and manually\nconfigure the `tauri.conf.json` file. Once everything is installed, you can run:\n``` yarn tauri dev -or- npm run tauri dev ``` This will do several things: 1.\nstart the JS Framework devserver 2. begin the long process of downloading and\ncompiling the rust libraries 3. open an application window with devtools enabled\n4. keep a long-lived console alive If you change your HTML/CSS/TS/JS, your\nframework devserver should give you its best shot at instant hot module\nreloading and you will see the changes instantly. If you modify your rust code\nor anything in the Cargo.toml, the window will close while rust recompiles. When\nfinished it will reload. If you need to get deeper insight into your current\nproject, or triage requires investigation of installed components, just run: ```\nyarn tauri info ``` ## What does the Release flow look like? The release flow\nbegins with proper configuration in the `tauri.conf.json` file. In this file,\nthe developer can configure not only the basic behaviour of the application\n(like window size and decoration), they can also provide settings for signing\nand updating. Depending upon the operating system that the developer (or CI) is\nbuilding the application on, there will be an app built for them for that\nsystem. (Cross compilation is not currently available, however there is an\nofficial [GitHub Action](https://github.com/tauri-apps/tauri-action) that can be\nused to build for all platforms.) To kick off this process, just: ``` yarn tauri\nbuild ``` After some time, the process will end and you can see the results in\nthe `./src-tauri/target/release` folder. ## What does the End-User flow look\nlike? End users will be provided with binaries in ways that are appropriate for\ntheir systems. Whether macOS, Linux, or Windows, direct download or store\ninstallations - they will be able to follow procedures for installing and\nremoving that they are used to. ## What does the Updating flow look like? When a\nnew version is ready, the developer publishes the new signed artifacts to a\nserver (that they have configured within `tauri.conf.json`). The application can\npoll this server to see if there is a new release. When there is a new release,\nthe user is prompted to update. The application update is downloaded, verified\n(checksum & signature), updated, closed, and restarted. ## License Tauri itself\nis licensed under MIT or Apache-2.0. If you repackage it and modify any source\ncode, it is your responsibility to verify that you are complying with all\nupstream licenses. Tauri is provided AS-IS with no explicit claim for\nsuitability for any purpose. Here you may peruse our [Software Bill of\nMaterials](https://app.fossa.com/projects/git%2Bgithub.com%2Ftauri-apps%2Ftauri).","url":"https://tauri.studio/docs/architecture"},{"id":"prose_docs_faq_md","title":"Frequently Asked Questions","headings":[],"subHeadings":[],"code":[null],"text":"# error: could not find native static libraryWebView2LoaderStatic, perhaps an -L\nflag is missing? The WebView2 crate build pipeline requires `NuGet` to have a\n`PackageSource` to install the `Microsoft.Web.WebView2` package. If you never\nused `NuGet` before, you might need to create a file named `NuGet.Config` on\n`%APPDATA%/NuGet` folder, with the following contents: ``` ``` This\nconfiguration enables the default `NuGet` registry.","url":"https://tauri.studio/docs/faq"},{"id":"prose_docs_about_architecture_md","title":"The Tauri Architecture","area":"about","section":"about","headings":["What does the Release flow look like"],"subHeadings":[],"code":[null],"text":"# The Tauri Architecture ## Introduction Tauri is a polyglot and generic toolkit\nthat is very composable and allows engineers to make a wide variety of\napplications. It is used for building applications for Desktop Computers using a\ncombination of Rust tools and HTML rendered in a Webview. Apps built with Tauri\ncan ship with any number of pieces of an optional JS API / Rust API so that\nwebviews can control the system via message passing. In fact, developers can\nextend the default API with their own functionality and bridge the Webview and\nRust-based backend easily. Tauri apps can have custom menus and have tray-type\ninterfaces. They can be updated, and are managed by the user's operating system\nas expected. They are very small, because they use the OS's webview. They do not\nship a runtime, since the final binary is compiled from Rust. This makes the\nreversing of Tauri apps not a trivial task. ## What Tauri is NOT - Tauri is not\na lightweight kernel wrapper...instead it directly uses [WRY](#wry) and\n[TAO](#tao) to do the heavy-lifting in making system calls to the OS. - Tauri is\nnot a VM or virtualized environment...instead it is an application toolkit that\nallows making Webview OS applications. ## Major Components The following section\nbriefly describes the roles of the various parts of Tauri. ### Tauri Core\n[STABLE RUST] ####\n[tauri](https://github.com/tauri-apps/tauri/tree/dev/core/tauri) This is the\nmajor crate that holds everything together. It brings the runtimes, macros,\nutilities and API into one final product. It reads the `tauri.conf.json` file at\ncompile time in order to bring in features and undertake actual configuration of\nthe app (and even the `Cargo.toml` file in the project's folder). It handles\nscript injection (for polyfills / prototype revision) at runtime, hosts the API\nfor systems interaction, and even manages updating. ####\n[tauri-build](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-build)\nApply the macros at build-time in order to rig some special features needed by\n`cargo`. ####\n[tauri-codegen](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-codegen)\n- Embed, hash, and compress assets, including icons for the app as well as the\nsystem-tray. - Parse `tauri.conf.json` at compile time and generate the Config\nstruct. ####\n[tauri-macros](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-macros)\nCreate macros for the context, handler, and commands by leveraging the\n`tauri-codegen` crate. ####\n[tauri-runtime](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime)\nThis is the glue layer between tauri itself and lower level webview libraries.\n####\n[tauri-runtime-wry](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime-wry)\nThis crate opens up direct systems-level interactions specifically for WRY, such\nas printing, monitor detection, and other windowing related tasks.\n`tauri-runtime` implementation for WRY. ####\n[tauri-utils](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-utils)\nThis is common code that is reused in many places and offers useful utilities\nlike parsing configuration files, detecting platform triples, injecting the CSP,\nand managing assets. ### Tauri Tooling ####\n[api](https://github.com/tauri-apps/tauri/tree/dev/tooling/api) [TS -> JS] A\ntypescript library that creates `cjs` and `esm` Javascript endpoints for you to\nimport into your Frontend framework so that the Webview can call and listen to\nbackend activity. We also ship the pure typescript, because for some frameworks\nthis is more optimal. It uses the message passing of webviews to their hosts.\n#### [bundler](https://github.com/tauri-apps/tauri/tree/dev/tooling/bundler)\n[RUST / SHELL] The bundler is a library that builds a Tauri App for the platform\ntriple it detects / is told. At the moment it currently supports macOS, Windows\nand Linux - but in the near future will support mobile platforms as well. May be\nused outside of Tauri projects. ####\n[cli.js](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli.js) [JS]\nWritten in Typescript and packaged such that it can be used with `npm`, `pnpm`,\nand `yarn`, this library provides a node.js runner for common tasks when using\nTauri, like `yarn tauri dev`. For the most part it is a wrapper around\n[cli.rs](https://github.com/tauri-apps/tauri/blob/dev/tooling/cli). ####\n[cli.rs](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli) [RUST] This\nrust executable provides the full interface to all of the required activities\nfor which the CLI is required. It will run on macOS, Windows, and Linux. ####\n[create-tauri-app](https://github.com/tauri-apps/tauri/tree/dev/tooling/create-tauri-app)\n[JS] This is a toolkit that will enable engineering teams to rapidly scaffold\nout a new tauri-apps project using the frontend framework of their choice (as\nlong as it has been configured). # External Crates The Tauri-Apps organisation\nmaintains two \"upstream\" crates from Tauri, namely TAO for creating and managing\napplication windows, and WRY for interfacing with the Webview that lives within\nthe window. ## [TAO](https://github.com/tauri-apps/tao) Cross-platform\napplication window creation library in Rust that supports all major platforms\nlike Windows, macOS, Linux, iOS and Android. Written in Rust, it is a fork of\n[winit](https://github.com/rust-windowing/winit) that we have extended for our\nown needs like menu bar and system tray. ##\n[WRY](https://github.com/tauri-apps/wry) WRY is a cross-platform WebView\nrendering library in Rust that supports all major desktop platforms like\nWindows, macOS, and Linux. Tauri uses WRY as the abstract layer responsible to\ndetermine which webview is used (and how interactions are made). ##\n[tauri-hotkey-rs](https://github.com/tauri-apps/tauri-hotkey-rs) We needed to\nfix hotkey to work on all platforms, because upstream was not being responsive.\n# Additional tooling ##\n[binary-releases](https://github.com/tauri-apps/binary-releases) This is the\ndelivery mechanism for tauri prebuilt binaries: currently the cli.rs (used by\ncli.js) and rustup binaries (used by the deps install command of cli.js). These\nartifacts are automatically created on release. ##\n[tauri-action](https://github.com/tauri-apps/tauri-action) This is a github\nworkflow that builds tauri binaries for all platforms. It is not the fastest out\nthere, but it gets the job done and is highly configurable. Even allowing you to\ncreate a (very basic) tauri app even if tauri is not setup. ##\n[create-pull-request](https://github.com/tauri-apps/create-pull-request) Because\nthis is a very risky (potentially destructive) github action, we forked it in\norder to have strong guarantees that the code we think is running is actually\nthe code that is running. ##\n[vue-cli-plugin-tauri](https://github.com/tauri-apps/vue-cli-plugin-tauri) This\nplugin allows you to very quickly install tauri in a vue-cli project. ##\n[tauri-vscode](https://github.com/tauri-apps/tauri-vscode) This project enhances\nthe VS Code interface with several nice-to-have features. # Tauri Plugins\n[documentation](https://tauri.studio/en/docs/guides/plugin) Generally speaking,\nplugins are authored by third parties (even though there may be official,\nsupported plugins). A plugin generally does 3 things: 1. It provides rust code\nto do \"something\". 2. It provides interface glue to make it easy to integrate\ninto an app. 3. It provides a JS API for interfacing with the rust code. Here\nare several examples of Tauri Plugins: -\nhttps://github.com/tauri-apps/tauri-plugin-sql -\nhttps://github.com/tauri-apps/tauri-plugin-stronghold -\nhttps://github.com/tauri-apps/tauri-plugin-authenticator # Workflows ## What\ndoes the Development flow look like? A developer must first install the\nprerequisite toolchains for creating a Tauri app. At the very least this will\nentail installing rust & cargo, and most likely also a modern version of node.js\nand potentially another package manager. Some platforms may also require other\ntooling and libraries, but this has been documented carefully in the respective\nplatform docs. Because of the many ways to build front-ends, we will stick with\na common node.js based approach for development. (Note: Tauri does not by\ndefault ship a node.js runtime.) The easiest way to do this is to run the\nfollowing: ``` npx create-tauri-app ``` Which will ask you a bunch of questions\nabout the framework you want to install and then create everything you need in a\nsingle folder - some via the placement of template files and some through normal\ninstallation procedures of your framework. > If you don't use this process, you\nwill have to manually install the tauri cli, initialise tauri and manually\nconfigure the `tauri.conf.json` file. Once everything is installed, you can run:\n``` yarn tauri dev -or- npm run tauri dev ``` This will do several things: 1.\nstart the JS Framework devserver 2. begin the long process of downloading and\ncompiling the rust libraries 3. open an application window with devtools enabled\n4. keep a long-lived console alive If you change your HTML/CSS/TS/JS, your\nframework devserver should give you its best shot at instant hot module\nreloading and you will see the changes instantly. If you modify your rust code\nor anything in the Cargo.toml, the window will close while rust recompiles. When\nfinished it will reload. If you need to get deeper insight into your current\nproject, or triage requires investigation of installed components, just run: ```\nyarn tauri info ``` ## What does the Release flow look like? The release flow\nbegins with proper configuration in the `tauri.conf.json` file. In this file,\nthe developer can configure not only the basic behaviour of the application\n(like window size and decoration), they can also provide settings for signing\nand updating. Depending upon the operating system that the developer (or CI) is\nbuilding the application on, there will be an app built for them for that\nsystem. (Cross compilation is not currently available, however there is an\nofficial [GitHub Action](https://github.com/tauri-apps/tauri-action) that can be\nused to build for all platforms.) To kick off this process, just: ``` yarn tauri\nbuild ``` After some time, the process will end and you can see the results in\nthe `./src-tauri/target/release` folder. ## What does the End-User flow look\nlike? End users will be provided with binaries in ways that are appropriate for\ntheir systems. Whether macOS, Linux, or Windows, direct download or store\ninstallations - they will be able to follow procedures for installing and\nremoving that they are used to. ## What does the Updating flow look like? When a\nnew version is ready, the developer publishes the new signed artifacts to a\nserver (that they have configured within `tauri.conf.json`). The application can\npoll this server to see if there is a new release. When there is a new release,\nthe user is prompted to update. The application update is downloaded, verified\n(checksum & signature), updated, closed, and restarted. ## License Tauri itself\nis licensed under MIT or Apache-2.0. If you repackage it and modify any source\ncode, it is your responsibility to verify that you are complying with all\nupstream licenses. Tauri is provided AS-IS with no explicit claim for\nsuitability for any purpose. Here you may peruse our [Software Bill of\nMaterials](https://app.fossa.com/projects/git%2Bgithub.com%2Ftauri-apps%2Ftauri).","url":"https://tauri.studio/docs/about/architecture"},{"id":"prose_docs_about_book_md","title":"Get the book","area":"about","section":"about","headings":["Outline","Errata"],"subHeadings":["tl","Introduction","About the Topic","What you will learn","Stuff you","Chapter 1 ","Chapter 2 ","Chapter 3 ","Chapter 4 ","Chapter 5 "],"code":[null],"text":"import useBaseUrl from '@docusaurus/useBaseUrl'\nTauri - From Theory to Practice [{useBaseUrl('img/bookCover.png')}]\nTauri: From Theory to Practice\nArchitecting Next-Gen Native-Apps for all Platforms [v1:Rust Edition]\nAuthors: [Daniel Thompson-Yvetot, Lucas Fernandes Gonçalves Nogueira]\nPublisher: TBD\nRelease: late 2020\n### tl;dr; Visit https://opencollective.com/tauri and preorder your copy of the\nbook today. Your donation will support the ongoing development of Tauri, and you\nwill receive advance digital PDF's for your review as chapters are completed.\nThe final book will ship concurrently with the release of 1.0.0 stable. If you\ndonate 10 USD / month to Tauri, you will get the advance PDF versions as soon as\nthey are released. If you just want to donate once: 15 USD for PDF and e-book,\n30 USD for print version and PDF, 40 USD for all three. All tutorial\nsubscription tiers receive the rolling PDF free of additional charge. ###\nIntroduction In 2020, the manufacture of native-apps has become easier and more\naccessible than ever before. All the same, beginners and seasoned developers\nalike are confronted with tough choices in a rapidly changing landscape of\nsecurity and privacy. This is especially true in the semi-trusted environment of\nuser devices. Tauri takes the guesswork out of the equation, as it was designed\nfrom the ground up to embrace new paradigms of secure development and creative\nflexibility that leverage the language features of Rust and lets you build an\napp using any frontend framework you like. Find out how you can design, build,\naudit and deploy tiny, fast, robust, and secure native applications for the\nmajor Desktop and Mobile platforms, all from the exact same codebase and in\nrecord time - without even needing to know the Rust programming language.\nAuthors Daniel and Lucas, the architects behind Tauri take you on a journey from\ntheory to execution, during which you will learn why Tauri was built and how it\nworks under the hood. Together with guest personalities that specialize in Open\nSource, DevOps, Security and Enterprise Architecture, this book also presents\ndiscourse-formatted philosophical discussions and open-source sustainability\nviewpoints from which your next-gen apps will profit - and your users will\nbenefit. In this book you will follow the authors in the iterative evolution of\na real project from conception to distribution - all with commentary, complete\ncode resources, built, and packaged Native Apps for reference and staged Capture\nthe Flag (CTF) challenges that progress in difficulty as your comprehension of\nthe system grows. ### About the Topic Tauri is a brand new way to make\ncross-platform native-apps for web, desktop and mobile. At this very moment, the\npre-alpha version of this MIT licensed community-based software is being\nprepared for public release: https://github.com/tauri-apps/tauri Tauri\nintroduces novel methods for WebView integration and innovative patterns for\nrobust threat evasion. The 1.0 release will ship with a multipurpose white-box\nanalyzer and decompiler for any kind of binary and an integrated CLI for\ningesting any type of HTML; which, when combined, provides developers and\nsecurity teams with a holistic platform that has never existed as a single unit\nbefore. Tauri bridges communities and opens up new opportunities for everyone\nfrom the front end developer all the way to the low-level security and network\nadministrators. Due to this level of complexity and robustness, it is important\nto publish a reference guide that will necessarily be updated as major versions\nare released. ### What you will learn By the end of this book you will\nunderstand: - The method and reasoning behind the design of Tauri - The options\nyou have when building with Tauri - That having a moral compass is possible in\nsoftware development - Why the Rust language makes the most sense as a binding\nand application layer - Why Electron, Cordova, React Native, Capacitor and\nothers are no longer the best choice - Why a binary review is important And you\nwill be able to: - Transform a simple website project into a Tauri Native-App -\nMake a variety of Tauri Application Types based on the main Patterns - Decompile\nand analyze your App for Security Issues - Publish your App to a variety of App\nStores - Read and write Rust code ### Stuff you'll get if you preorder - Access\nto a real demo App built for all platforms available at respective stores (that\nincludes CTF Flags). - Exclusive One-Pager cheat sheets made available for each\nsection of the book, including the Appendices. - Early access to videos /\nwebcasts. - Discounted participation in the “Capture the Flag” event hosted at\nthe launch of the book. ## Outline This is an early outline of the contents that\nwe expect to publish. Contents subject to change. ### Chapter 1 - Theory (ca. 50\npages - mostly conversational / technical, graphics) ``` 1. Security Starts with\nYou 2. Privacy Ends with ${you} 3. Languages, Dialects and Patterns 4.\nToolchains and Syntactic Sugar 5. Production Methodologies 6. Enterprise\nReadiness 7. Message Queueing 8. Embracing Chaos 9. Distribution Techniques 10.\nLicensing Strategies ``` ### Chapter 2 - Practice (ca. 130 pages w/ charts,\nscreenshots, code samples) ``` 1. Environment Prerequisites - Node, Npm, Yarn,\nRustc, Rustup, Buildtools 2. Development Platform Details - macOS - Windows -\nLinux - Docker - Virtual Machines - CI / CD 3. Tauri Introduction 4. Tauri\nAnatomy 5. Tauri Configuration - Files & Folders - Icons - Splash Screens -\nWindow - `src-tauri/tauri.conf.json` 6. Preparing your code - Transpile dynamic\nimports - Remove webpack chunking - Monolithic Files - Minification strategies\n7. Tauri API - Design Considerations - API Usage Patterns - Custom API Functions\n- Endpoints - All - Answer - Bridge - Event - Execute - List Files - Open - Read\nBinary File - Read Text File - Set Title - Window - Write File 8. Web APIs 9.\nTauri App Extensions - Anatomy - Flow - Registration - Publication - API 10.\nTaskbar Integration (Desktop Only) - Anatomy - Integrations - macOS - Windows -\nLinux 11. Security Features - Baseline Rust Features - Functional Address Space\nLayout Randomization (fASLR) - Ahead of Time (AoT) Compilation - Content\nSecurity Policy (CSP) - One Time Pads (OTP) - Embedded Server: False - API\nTree-Shaking - Matryoschkasumming (with Tauri-Frida) 12. Bridges and Brokers -\nBridge Patterns - Message hashing with OTP - Plugin Pattern - Kamikaze Function\nInjection (KFI) Closures 13. Testing - Unit Testing - Rust - JS - Integration\nTesting - e2e Testing 14. Building - Debugging - Packaging - Minification -\nDistribution Platform Details - macOS (.app / .dmg) - Win (.exe / .msi) - Linux\nArm64 (.appImage / .deb) - Linux x64 (.appImage / .deb) - iOS (.ipa) - Android\n(.apk) - PWA Website (with wasm) - Code Signing - Keystores - Certs -\nFingerprints - Providing License for End Users - Providers - Keys Files -\nSelf-Updater - Anatomy - Service Provisioning - Github - AWS - Homegrown -\nCross-Platform Bundler 15. Tauri-Frida Harness - Introduction to Reverse\nEngineering - Toolchain - Usage - Binary Hooking at Runtime - Pointer Evaluation\n- Spraying, Fuzzing, Spoofing - Report Generation - Recompilation - Post-Binary\nAnalysis 16. Distribution - Git - Mac Store - iOS Store - Play store - Windows\nStore - Snap Store - PureOS Store - .deb channels - .tar.gz - homebrew - Fdroid\n- Cydia - ChromeOS - WASM ``` ### Chapter 3 - Philosophical Discourses (ca. 40\npages of essays, some graphics) ``` 1. Rights and Responsibilities (with Robin\nvan Boven (SFOSC)) - Who You are Responsible To - Being a Vendor Comes with\nDuties - Ubiquitous Resources are Still Precious - Use Policy to Address\nResponsibilities - Take a Hippocratic Development Oath 2. Take a More Secure\nStance (with Liran Tal (SNYK)) - Security Benefits of Frameworks - Encrypt All\nthe Things, All the Time - Constantly Audit Project Dependencies - Harden\nYourself, Your Organization and Your Ecosystem - “Do What You Can Until You Run\nOut of Time.” - [ROBERT C. SEACORD] 3. Production Strategies for Sustainability\n(with Rhys Parry (Independent)) - Develop in the “Perfect” Environment - Minimal\nImpact for Existing Enterprise Architectures - Use Low-Barrier Tools for\nEnsuring Wholestack Security - Test the Right Things Intelligently - Post-Binary\nAnalysis and Redistribution - The Last Mile ``` ### Chapter 4 - Execution (ca.\n100 pages w/ code examples, screenshots, graphics) ``` 1. Base Pattern Evolution\n- Hermit - Bridge - Cloudish - Cloudbridge - Lockdown - Multiwin - GLUI 2.\nAdvanced Patterns - Cryptographic Enclave - Identity Management - Combine an App\nwith a Daemon - IPC / RPC - Integrate with DENO 3. UI Source Complilation -\nReact - Vue - Angular - Svelte - Gatsby 4. Building a Real App - Multiparty\nPassword Manager - Design - Prototyping - Testing - Debugging - Packaging -\nChecksumming 5. Tauri-Frida - White Box Reversing - Analyzing with Frida - Chaos\nExperiments - Interface Jacking - Disk Change - Latency - Process Kill - CPU\nThrottle - Static Analysis Reporting - Binary Repackaging - Inject License Keys\n- Clear Dead Codepoints - Recalculate Integrated Checksum 6. Publishing the App\n- Git - Mac Store - iOS Store - Play store - Windows Store - Snap Store - PureOS\nStore - .deb channels - .tar.gz - homebrew - Fdroid - Cydia - ChromeOS - WASM 7.\nPublishing an Update ``` ### Chapter 5 - Appendices (ca. 120 pages) ``` 1.\nConfiguration Options 2. Files and Repositories 3. Tauri CLI references 4. Tauri\nAPI references 5. ES6 References 6. Rust References 7. App Pattern Charts 8.\nTauri-Frida Reference 9. Glossary 10. Index ``` ## Errata Got something that you\nthink should be in the book? Want to be our publisher? Reach out to us and let\nus know!","url":"https://tauri.studio/docs/about/book"},{"id":"prose_docs_about_governance_md","title":"Governance","area":"about","section":"about","headings":["Sustainability"],"subHeadings":["Organizational Structure","Code of Conduct","Social Contract","Licensing","Trademark"],"code":[],"text":"## Sustainability One of the main goals of the organizational structure of Tauri\nis to guarantee the sustainability of Tauri and the health and well-being of its\ncontributors. The world of Open Source is fraught with peril and discord, and we\nhave taken measures to ensure the longevity of Tauri. This document explains how\nwe go about doing so. ### Organizational Structure Tauri apps is governed by the\ncommunity and work is done in the context of public working groups. Each working\ngroup has a dedicated channel on the Discord server as well as a Team on GitHub.\nOther than that, each WG is free to use whatever type of organizational model it\nchooses. The current working groups are: - WG Governance & Guidance - WG Tech -\nWG Education - WG Media - WG Security - WG Devops With the exception of the\nsecurity working group, which is by invite only and convenes privately, all\nother working groups are public and open to any and all participants. Please\nvisit [this repository](https://github.com/tauri-apps/governance-and-guidance)\nto get more information. ### Code of Conduct Everyone participating in the Tauri\ncommunity is expected to follow a code of conduct that you can at the\n[Governance and Guidance:Code of\nConduct](https://github.com/tauri-apps/governance-and-guidance/blob/master/CODE_OF_CONDUCT.md).\n### Social Contract We have a Social Contract that informs our decision making\nand organization. You can read about it here: [Governance and Guidance:Social\nContract](https://github.com/tauri-apps/governance-and-guidance/blob/master/SOCIAL_CONTRACT.md).\n### Licensing We, the contributors to Tauri Apps, use the MIT and Apache\nlicenses for all code content. Images and bodies of text, unless otherwise noted\nare CC-BY-ND-NC. ### Trademark It is a permissible use of the name \"Tauri App\"\nor the Tauri logo to show that a project uses Tauri. \"Tauri Studio\" is reserved\nfor use by the organization. Any language that gives the impression that the\nTauri organization approves, authorizes or otherwise supports a project, person\nor company is not permissible without written authorization from the Guidance\nand Governance Working Group.","url":"https://tauri.studio/docs/about/governance"},{"id":"prose_docs_about_intro_md","title":"What is Tauri?","area":"about","section":"about","headings":["Security First","Polyglots","Honest Open Source","The Future"],"subHeadings":[],"code":[],"text":"Tauri is a toolkit that helps developers make applications for the major desktop\nplatforms - using virtually any frontend framework in existence. The core is\nbuilt with Rust and the CLI leverages Node.js making Tauri a genuinely polyglot\napproach to creating and maintaining great apps. If you want to know more about\nthe technical details, then please visit the\n[Introduction](/docs/getting-started/beginning-tutorial). If you want to know\nmore about this project's philosophy - then keep reading.\n\n## Security First In today's world, every honest threat model assumes that the\nuser's device has already been compromised. This puts app developers in a\ncomplicated situation, because if the device is already at risk, how can the\nsoftware be trusted? Defense in depth is the approach we've taken. We want you\nto be able to take every precaution possible to minimise the surface area you\npresent to attackers. Tauri lets you choose which API endpoints to ship, whether\nor not you want a localhost server built into your app, and it even randomizes\nfunctional handles at runtime. These and other techniques form a secure baseline\nthat empowers you and your users. Slowing down attackers by making static\nattacks crushingly difficult and isolating systems from one another is the name\nof the game. And if you are coming from the Electron ecosystem - rest assured -\nby default Tauri only ships binaries, not ASAR files. By choosing to build Tauri\nwith security as a guiding force, we give you every opportunity to take a\nproactive security posture. ## Polyglots, not Silos Most contemporary frameworks\nuse a single language paradigm and are therefore trapped in a bubble of\nknowledge and idiom. This can work well for certain niche applications, but it\nalso fosters a kind of tribalism. This can be seen in the way that the React,\nAngular and Vue development communities huddle on their stacks, ultimately\nbreeding very little cross-pollination. This same situation can be seen in the\nRust vs Node vs C++ battlefields, where hardliners take their stances and refuse\nto collaborate across communities. Today, Tauri uses Rust for the backend - but\nin the not too distant future, other backends like Go, Nim, Python, Csharp etc.\nwill be possible. This is because we are maintaining the official Rust bindings\nto the [webview](https://github.com/webview) organisation and plan to let you\nswitch out the backend for your needs. Since our API can be implemented in any\nlanguage with C interop, full compliance is only a PR away. ## Honest Open\nSource None of this would make any sense without a community. Today software\ncommunities are amazing places where people help each other and make awesome\nthings - open source is a very big part of that. Open source means different\nthings to different people, but most will agree that it serves to support\nfreedom. When software doesn't respect your rights, then it can seem unfair and\npotentially compromise your freedoms by operating in unethical ways. This is why\nwe are proud that FLOSS advocates can build applications with Tauri that are\n\"certifiably\" open source and can be included in FSF endorsed GNU/Linux\ndistributions. ## The Future Tauri's future depends on your involvement and\ncontributions. Try it out, file issues, join a working group or make a donation\n- every contribution is important. Please, at any rate, do get in touch!!!","url":"https://tauri.studio/docs/about/intro"},{"id":"prose_docs_about_security_md","title":"Security","area":"about","section":"about","headings":["No Server Required","Language Features of Rust","Dynamic Ahead of Time Compilation ","Function Hardening","System Features","Ecosystem","Future Work"],"subHeadings":["Security Researchers","Functional ASLR","Kamikaze Function Injection","Bridge","One Time Pad Tokenization and Hashing","Allowing API","Content Security Policy Management","Decompilation is Difficult","Build Pipelines and Artifact Authenticity","Resilient PR and Approval Processes","Signed Binaries","Post","Post","Audits"],"code":[],"text":"This guide seeks to explain the high level concepts and Security Features at the\ncore of Tauri's design that make you, your apps and your users safer by default.\nPlease note:\nWhile we take every opportunity to help you harden your application - there are\nalways underlying threats like BIOS attacks, memory rowhammering and other\noperating system vulnerabilities that are constantly being discovered and (in\nthe best cases) responsibly disclosed.\nFurthermore, there are many ways that development teams can cut corners and\neither leak sensitive information or leave doors wide open to any of a range of\nattacks. Security is a never-ending quest, and your users count on you to keep\nthem safe.\nTherefore, we highly recommend that you take some time to consider the security\nramifications of everything that your application does, especially in the\ncontext of running on the semi-hostile platform of end-user devices.\nIf you need help or want a review, you are welcome to contact the Tauri team for\nsecurity consultation.\n### Security Researchers If you feel that there is a security concern or issue\nwith anything in Tauri, please do not publicly comment on your findings.\nInstead, reach out directly to our security team: > security@tauri.studio\nAlthough we do not currently have a budget for Security Bounties, in some cases\nwe will consider rewarding responsible disclosure with our limited resources. ##\nNo Server Required Tauri enables you to construct an application that uses\nweb-technology for the user interface without requiring you to use a server to\ncommunicate with the backend. Even if you used advanced techniques of dynamic\nimports and offload work to the backend, no traffic can be sniffed on TCP ports\nor external processes - because they just aren't there. This reduces not only\nthe physical and virtual footprint of your final binary by a good deal, it also\nreduces the surface area of potential attack vectors by removing them from the\nequation. ## Language Features of Rust By turning to the programming language\nrenowned for its memory-safety and speed, Tauri simply erases whole classes of\nconventional attacks. `Use after free` just isn't something that can happen with\nTauri. ## Dynamic Ahead of Time Compilation (AOT) This process of compilation\nhappens several times during the bootstrapping phase of a Tauri app. By using\nour default dynamic Ahead of Time compiler, you can generate code references\nthat are unique for every session and are still technically static code units.\n## Function Hardening ### Functional ASLR Functional address Space Layout\nRandomization techniques randomize function names at runtime and can implement\nOTP hashing so no two sessions are ever the same. We propose a novel type of\nfunction naming at boot time and optionally after every execution. Using a UID\nfor each function pointer prevents static attacks. ### Kamikaze Function\nInjection This advanced type of fASLR using the `EVENT` API endpoint, is a\npromise wrapped in a closure (with randomized handle) that Rust inserts at\nruntime into the WebView, where its interface is locked within the promise\nresolution handler and is nulled after execution. ### Bridge, don't serve\nInstead of passing potentially unsafe functions, an event bridge can be used to\npass messages and commands to named brokers at each respective side of the\napplication. ### One Time Pad Tokenization and Hashing Hashing important\nmessages with a OTP salt, you are able to encrypt messages between the user\ninterface and the Rust backend. We are currently investigating the use of\nadditional sources of entropy such as the amazing [Infinite Noise\nTRNG](https://13-37.org/en/shop/infinite-noise-trng/). ## System Features ###\nAllowing API You have the ability to pick and choose which API functions are\navailable to the UI and to Rust. If they are not enabled, the code will not be\nshipped with your app, which reduces binary size and attack surface. They are\nopt-in, so you have to consciously choose to progressively enhance your\napplication. ### Content Security Policy Management Preventing unauthorized code\nexecution for websites has long since been \"resolved\" by using CSPs. Tauri can\ninject CSPs into the index.html of the user interface, and when using a\nlocalhost server it will also send these headers to the UI or any other clients\nthat connect with it. ### Decompilation is Difficult This means that your apps\ncannot be easily decompiled as is the case with Electron ASAR files, which makes\nthe process of reverse engineering your project much more time intensive and\nrequires specialist training. ## Ecosystem ### Build Pipelines and Artifact\nAuthenticity The process of releasing our source-code artifacts is highly\nautomated, yet mandates kickoff and review from real humans. Our current release\nstrategy uses a combination of Github Actions and IOTA Tangle publication ###\nResilient PR and Approval Processes Our WG-TECH reviews code changes, tags PRs\nwith scope and make sure that everything stays up to date. And when its time to\npublish a new version, one of the maintainers tags a new release on master,\nwhich: - validates core - runs smoke tests - audits security for crates and npm\n- generates changelogs - creates artifacts - publishes checksums to IOTA -\ncreates a draft release Then the maintainer reviews the release notes, edits if\nnecessary - and a new release is forged. ## Future Work ### Signed Binaries\nBecause the entire project is shipped within a monolithic binary, code can be\nsigned for all distributables. (Currently using external tooling, but we are\nactively working on making the bundler a one-stop-shop.) This makes it virtually\nimpossible for hackers to change an installed Application without the operating\nsystem noticing. [Reference](https://github.com/electron/asar/issues/123) ###\nPost-Binary Analysis Use industrial-grade pentester-tooling (via our forthcoming\nTauri-Frida GUI) to discover and fix security weaknesses in your final binaries.\n### Post-Binary Enhancement After the build is before the delivery, and Tauri\nwill provide you with tools never seen before. Stay tuned! ### Audits We are\ncurrently in the process of our first external audit. When complete, we will\npublish the results here.","url":"https://tauri.studio/docs/about/security"},{"id":"prose_docs_architecture_build_tools_md","title":"Node Build Tools","area":"architecture","section":"architecture","headings":[],"subHeadings":[],"code":[],"text":"This is a stub. Could add notes about Vite, Webpack, Rollup, etc.","url":"https://tauri.studio/docs/architecture/build-tools"},{"id":"prose_docs_architecture_frontend_frameworks_md","title":"Frontend Frameworks","area":"architecture","section":"architecture","headings":[],"subHeadings":[],"code":[],"text":"This is a stub. Could add notes about Vite, Webpack, Rollup, etc.","url":"https://tauri.studio/docs/architecture/frontend-frameworks"},{"id":"prose_docs_architecture_patterns_brownfield_md","title":"Brownfield Pattern","area":"architecture","section":"patterns","headings":["Incompatibilities","Configuration"],"subHeadings":[],"code":["json"],"text":"# Brownfield Pattern _**This is the default pattern.**_ This is the simplest and\nmost straightforward pattern to use Tauri with due to it trying to be the most\ncompatible with existing frontend projects as much as it can. In short, it tries\nto require nothing additional to what an existing web frontend might use inside\na browser. Not _**everything**_ that works in existing browser applications will\nwork out-of the box, see the [Incompatibility section](#incompatibilities) for\nmore details. If you are unfamiliar with Brownfield software development in\ngeneral, the [Brownfield Wikipedia\narticle](https://en.wikipedia.org/wiki/Brownfield_(software_development))\nprovides a nice summary of it. For Tauri, the existing software is current\nbrowser support and behavior instead of legacy systems. ## Incompatibilities The\nfirst incompatibility category is easy, any browser-specific APIs will not work\nproperly inside Tauri (even while using the Brownfield pattern). If the API is\nnot widely supported across browsers, it's likely not going to be supported\nacross all platforms while using Tauri. The second incompatibility category is\nfeatures that are planned for Tauri but are currently not fully implemented.\nHere is a list of examples: * [WebRTC support on\nLinux](https://github.com/tauri-apps/wry/issues/85) * [Some permissions\nAPIs](https://github.com/tauri-apps/wry/issues/81) * [Download Links/Blob as\nURL](https://github.com/tauri-apps/wry/issues/349) * [Better\ni18n](https://github.com/tauri-apps/wry/issues/442) ## Configuration Because the\nBrownfield pattern is the default pattern, no configuration option is required\nto be set. To explicitly set it, you can use the `tauri > pattern` object in the\n`tauri.conf.json` configuration file. ```json { \"tauri\": { \"pattern\": { \"use\":\n\"brownfield\" } } } ``` _**There are no additional configuration options for the\nbrownfield pattern.**_","url":"https://tauri.studio/docs/architecture/patterns/brownfield"},{"id":"prose_docs_architecture_patterns_isolation_md","title":"Isolation Pattern","area":"architecture","section":"patterns","headings":["Why","When","How","Recommendations","Creating the Isolation Application","Configuration"],"subHeadings":["Approximate Steps of an IPC Message","Performance Implications","Limitations"],"code":["html","js","json"],"text":"","url":"https://tauri.studio/docs/architecture/patterns/isolation"},{"id":"prose_docs_architecture_recipes_about_recipes_md","title":"A word on recipes","area":"architecture","section":"recipes","headings":[],"subHeadings":[],"code":[],"text":"Tauri recipes are descriptions of use-cases that are entirely configurable\nwithin the `src-tauri/tauri.conf.json` file. These are not the limits of what\nTauri can do, and there are probably more out there. If you discover one, why\nnot get in touch and help us update this collection! If you haven't read about\nthe general design of Tauri, then it would make the most sense for you to visit\nthe [\"Getting Started\"](/docs/getting-started/beginning-tutorial) and become\nfamiliar with the basic architecture and terminology used in these recipes.","url":"https://tauri.studio/docs/architecture/recipes/about-recipes"},{"id":"prose_docs_architecture_recipes_bridge_md","title":"Bridge","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nBridge [{useBaseUrl('img/recipes/Bridge.svg')}]\nPros:\n * Highly configurable\n * No Rust skills required\n\nCons:\n * Some WebAPIs unavailable\n * Challenge to implement\n\n## Description The Bridge recipe is a secure pattern where messages are passed\nbetween brokers via an implicit bridge using the API. It isolates functionality\nto scope and passes messages instead of functionality. ## Diagram import\nMermaid, { colors } from '@theme/Mermaid' F subgraph WEBVIEW F-.-E end D-->E\nE-->D B-->D D-->B subgraph RUST A==>H A-->B B-.-C B-.-G end A[Binary] B{Rust\nBroker} C[Subprocess 2] G[Subprocess 1] D(( API BRIDGE )) E{JS Broker} F[Window]\nH{Bootstrap} style D fill:#ccc,stroke:#333,stroke-width:4px,color:white style\nRUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\nstyle WEBVIEW\nfill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`} /> ##\nConfiguration Here's what you need to add to your tauri.conf.json file: ```json\n{ \"tauri\": { \"allowlist\": { \"all\": false, \"clipboard\": { \"all\": false,\n\"readText\": false, \"writeText\": false }, \"dialog\": { \"all\": false, \"ask\": false,\n\"confirm\": false, \"message\": false, \"open\": false, \"save\": false }, \"fs\": {\n\"all\": false, \"copyFile\": false, \"createDir\": false, \"readDir\": false,\n\"readFile\": false, \"removeDir\": false, \"removeFile\": false, \"renameFile\": false,\n\"scope\": [], \"writeFile\": false }, \"globalShortcut\": { \"all\": false }, \"http\": {\n\"all\": false, \"request\": false, \"scope\": [] }, \"notification\": { \"all\": false },\n\"os\": { \"all\": false }, \"path\": { \"all\": false }, \"process\": { \"all\": false,\n\"exit\": false, \"relaunch\": false, \"relaunchDangerousAllowSymlinkMacos\": false },\n\"protocol\": { \"all\": false, \"asset\": false, \"assetScope\": [] }, \"shell\": {\n\"all\": false, \"execute\": false, \"open\": false, \"scope\": [], \"sidecar\": false },\n\"window\": { \"all\": false, \"center\": false, \"close\": false, \"create\": false,\n\"hide\": false, \"maximize\": false, \"minimize\": false, \"print\": false,\n\"requestUserAttention\": false, \"setAlwaysOnTop\": false, \"setDecorations\": false,\n\"setFocus\": false, \"setFullscreen\": false, \"setIcon\": false, \"setMaxSize\":\nfalse, \"setMinSize\": false, \"setPosition\": false, \"setResizable\": false,\n\"setSize\": false, \"setSkipTaskbar\": false, \"setTitle\": false, \"show\": false,\n\"startDragging\": false, \"unmaximize\": false, \"unminimize\": false } } } } ```","url":"https://tauri.studio/docs/architecture/recipes/bridge"},{"id":"prose_docs_architecture_recipes_cloudbridge_md","title":"Cloudbridge","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nCloudbridge [{useBaseUrl('img/recipes/Cloudbridge.svg')}]\nPros:\n * All available features\n * No Rust skills required\n\nCons:\n * Largest bundle size\n * Hard to separate concerns\n\n## Description The Cloudbridge recipe combines the flexibility of a localhost\nand the security of the bridge. With so many features, it can be easy to get\nlost. ## Diagram import Mermaid, { colors } from '@theme/Mermaid' F2 H==>D2\nD2-->F2 F2-->D2 B-->D D-->B E2-->D D-->E2 subgraph WEBVIEW F2 E2 end subgraph\nSERVER D2 E-->D2 end subgraph RUST A==>H A-->B B-.-C end A[Binary] B{Rust\nBroker} C[Subprocess] D(( API BRIDGE )) E{JS Broker} D2(( localhost )) E[bundled\nresources] E2{JS Broker} F2[Window] H{Bootstrap} style D\nfill:#ccc,stroke:#333,stroke-width:4px,color:white style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\nstyle SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px `} /> ## Configuration\nHere's what you need to add to your tauri.conf.json file: ```json \"tauri\": {\n\"allowlist\": { \"all\": true // enable entire API } } ```","url":"https://tauri.studio/docs/architecture/recipes/cloudbridge"},{"id":"prose_docs_architecture_recipes_cloudish_md","title":"Cloudish","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nCloudish [{useBaseUrl('img/recipes/Cloudish.svg')}]\nPros:\n * Similar to a SPA web-app\n * No Rust skills required\n\nCons:\n * No access to Rust API\n * Uses a localhost server\n\n## Description The Cloudish recipe is a pattern for maximum flexibility and app\nperformance. It uses a localhost server, which means that your app will\ntechnically be available to other processes, like browsers and potentially other\ndevices on the network. All of your assets are baked into the binary, but served\nas if they were distinct files. ## Diagram import Mermaid, { colors } from\n'@theme/Mermaid' F H==>D D-->F F-->D subgraph RUST A==>H end subgraph WEBVIEW F\nend subgraph SERVER D E-->D end A[Binary] D(( localhost )) E[bundled resources]\nF[Window] H{Bootstrap} style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\nstyle SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px`} /> ## Configuration\nHere's what you need to add to your tauri.conf.json file: ```json \"tauri\": {\n\"allowlist\": { \"all\": false // disable entire API } } ```","url":"https://tauri.studio/docs/architecture/recipes/cloudish"},{"id":"prose_docs_architecture_recipes_glui_md","title":"GLUI","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Alert from '@theme/Alert' import useBaseUrl from '@docusaurus/useBaseUrl'\nThis pattern is not available for now. import Rater from '@theme/Rater'\n\nEase of Use Extensibility Performance Security\n\nGLUI [{useBaseUrl('img/recipes/GLUI.svg')}]\nPros:\n * Framebuffer FTW\n * Window events rigged\n\nCons:\n * Broken on your machine\n\n## Description The GLUI is a research pattern that we will use internally to\ntest approaches using a GLUTIN window. We’re not sure yet if it will make the\nfinal cut as a bona fide alternative to WebView, although early tests with\ntransparent and multiwindow are exciting. ## Diagram import Mermaid, { colors }\nfrom '@theme/Mermaid' H H==>G A-->D D-->G subgraph GLUTIN G end subgraph RUST A\nend A[Binary] D(Framebuffer) G[GL Window] H{Bootstrap} style GLUTIN\nstroke:${colors.blue.dark},stroke-width:4px style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px`} />\n## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": { // all API endpoints are default false \"all\":\nfalse, // disable the api }, \"window\": { // not yet normative \"glutin\": true,\n\"webview\": false } } ```","url":"https://tauri.studio/docs/architecture/recipes/glui"},{"id":"prose_docs_architecture_recipes_hermit_md","title":"Hermit","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":["json"],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nHermit [{useBaseUrl('img/recipes/Hermit.svg')}]\nPros:\n * Quick to make\n * Smallest size\n\nCons:\n * No remote resources\n * No access to API\n\n## Description The Hermit recipe is a pattern for ultimate application isolation\nwhere all logic is self-contained in the Window and the binary exists merely to\nbootstrap the Window. There is no communication back to Rust from the Window,\nthere is no localhost server, and the Window has no access to any remote\nresources. The Hermit is great for interactive Kiosk Mode and standalone HTML\nbased games. ## Diagram import Mermaid, { colors } from '@theme/Mermaid' H H==>F\nsubgraph WEBVIEW F end subgraph RUST A end A[fa:fa-cog Binary ]\nF[fa:fa-window-maximize Window] H{Bootstrap} style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": { \"all\": false, // disable and tree-shake all\napi functions } } ```","url":"https://tauri.studio/docs/architecture/recipes/hermit"},{"id":"prose_docs_architecture_recipes_lockdown_md","title":"Lockdown","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":["json"],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nLockdown [{useBaseUrl('img/recipes/Lockdown.svg')}]\nPros:\n * Highest security rating\n * Elegant and powerful\n\nCons:\n * Rust skills required\n * No remote resources\n\n## Description The Lockdown recipe is a minimal usage of the [Bridge\npattern](./bridge.md), which only allows interaction between Rust and the Window\nvia expiring JS Promise Closures that are injected into the Window by Rust and\nnulled as part of the callback. ## Diagram import Mermaid, { colors } from\n'@theme/Mermaid' F G-.->B B-->G subgraph WEBVIEW G-->F end subgraph RUST A-->B\nA==>H end A[Binary] B[API:Event] F[Window] G((Promise Closure)) H{Bootstrap}\nstyle RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": {} // all API endpoints are default false } ```","url":"https://tauri.studio/docs/architecture/recipes/lockdown"},{"id":"prose_docs_architecture_recipes_multiwin_md","title":"Multiwin","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Alert from '@theme/Alert' import useBaseUrl from '@docusaurus/useBaseUrl'\nimport Rater from '@theme/Rater'\n\nEase of Use Extensibility Performance Security\n\nMultiwin [{useBaseUrl('img/recipes/Multiwin.svg')}]\nPros:\n * Windows can be spawned or destroyed at runtime\n * Separation of concerns\n\nCons:\n * Somewhat complex\n\n## Description The Multiwin recipe will allow you to have multiple windows. ##\nDiagram import Mermaid, { colors } from '@theme/Mermaid' H H==>F H==>G subgraph\nWEBVIEW F end subgraph WINIT G end subgraph RUST A end A[Binary] F[Window]\nG[Window] H{Bootstrap} style WINIT stroke:${colors.blue.dark},stroke-width:4px\nstyle RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": {}, // all API endpoints are default false\n\"windows\": [{ \"title\": \"Window1\", \"label\": \"main\", }, { \"title\": \"Splash\",\n\"label\": \"splashscreen\" }] } ```","url":"https://tauri.studio/docs/architecture/recipes/multiwin"},{"id":"prose_docs_building_app_size_md","title":"Reducing the App Size","area":"building","section":"building","headings":["Checklist","1","2","3","4","5","6","7","8"],"subHeadings":["You can","Think twice before adding a dependency","Why","How","Why","How","Why","How","Why","How","Why","How","Why","How","Unstable Rust Compression Features","Why","How","Why","How"],"code":["css","json","toml","sh"],"text":"# Reducing the App Size At Tauri, we are working on reducing the environmental\nfootprint of applications by using system resources where available, providing\ncompiled systems that don't need runtime evaluation, and offering guides so that\nengineers can go even smaller without sacrificing on performance or security.\nThe point is, by saving resources, we are doing our part to help you help us\nsave the planet -- which is the only bottom line that companies in the 21st\nCentury should care about. So if you are interested in learning how to improve\nyour appsize and performance, read on dear friend: ### You can't improve what\nyou can't measure Before you can optimize your app you need to figure out what\nit is that takes up space in your app! Here are a couple of tools that can\nassist you with that: - **`cargo-bloat`** [`cargo-bloat`][cargo-bloat] is a rust\nutility to figure out what takes the most space in your app. It gives you a\nnice, sorted overview of the biggest rust functions. - **`cargo-expand`**\n[Macros] make your rust code more concise and easier to read, but they are also\nhidden size traps! Use [`cargo-expand`][cargo-expand] to see what all those\nmacros generate under the hood. - **`rollup-plugin-visualizer`**\n[`rollup-plugin-visualizer`][rollup-plugin-visualizer] generates beautiful (and\ninsightful) graphs from your rollup bundle. Very convenient for figuring out\nwhat JavaScript dependencies contribute to your final bundle size the most. -\n**`rollup-plugin-graph`** You noticed a dependency was included in your final\nfrontend bundle, but you are not sure why?\n[`rollup-plugin-graph`][rollup-plugin-graph] generates graphviz compatible\nvisualizations of your entire dependency graph. These are just a couple tools\nthat you might use, make sure to check your frontend bundlers plugin list for\nmore! ### Think twice before adding a dependency ## Checklist - [Reducing the\nApp Size](#reducing-the-app-size) - [You can't improve what you can't\nmeasure](#you-cant-improve-what-you-cant-measure) - [Think twice before adding a\ndependency](#think-twice-before-adding-a-dependency) - [Checklist](#checklist) -\n[1. Minify Javascript](#1-minify-javascript) - [Why?](#why) - [How?](#how) - [2.\nOptimize Dependecies](#2-optimize-dependecies) - [Why?](#why-1) - [How?](#how-1)\n- [3. Optimize Images](#3-optimize-images) - [Why?](#why-2) - [How?](#how-2) -\n[4. Remove Unnecessary Custom Fonts](#4-remove-unnecessary-custom-fonts) -\n[Why?](#why-3) - [How?](#how-3) - [5. Allowlist Config](#5-allowlist-config) -\n[Why?](#why-4) - [How?](#how-4) - [6. Rust Build-time\nOptimizations](#6-rust-build-time-optimizations) - [Why?](#why-5) -\n[How?](#how-5) - [Unstable Rust Compression\nFeatures](#unstable-rust-compression-features) - [7. Stripping](#7-stripping) -\n[Why?](#why-6) - [How?](#how-6) - [8. UPX](#8-upx) - [Why?](#why-7) -\n[How?](#how-7) - [Usage on macOS](#usage-on-macos) ## 1. Minify Javascript ###\nWhy? JavaScript makes up a large portion of a typical Tauri app, so it's\nimportant to make the JavaScript as lightweight as possible. ### How? You can\nchoose among a plethora of JavaScript bundlers, popular choices are [Vite],\n[webpack] and [rollup]. All of them can produce minified JavaScript if\nconfigured correctly, so please consult your bundler documentation for specific\noptions. Generally speaking however, you should make sure to: - **Enable tree\nshaking** This option removes unused JavaScript from your bundle. All popular\nbundlers enable this by default. - **Enable minification** Minification removes\nunnecessary whitespace, shortens variable names and applies various other\noptimizations. Most bundlers enable this by default, a notable exception is\n[rollup] where you need a plugins like [rollup-plugin-terser] or\n[rollup-plugin-uglify]. :::note Minifiers like [terser] and [esbuild] can also\nbe used as standalone tools. ::: - **Disable source maps** Source maps provide a\nnice developer experience when working with languages that compile to JavaScript\nsuch as [TypeScript]. As source maps tend to be quite large though, it's\nimportant that you disable them when building for production. They have no\nbenefit to your end user, so it's effectively dead weight. ## 2. Optimize\nDependecies Many popular libraries have smaller and faster alternatives that you\ncan choose instead. ### Why? Most libraries you use depend on a number of\nlibraries themselves, so a library that looks inconspicuous at first glance\nmight add **several megabytes** worth of code to your app. ### How? You can use\n[Bundlephobia] to find the cost of JavaScript dependencies. Inspecting the cost\nof rust dependencies is generally harder since the compiler will do a number of\noptimizations. If you find a library that seems excessively large, google\naround, chances are someone else already had the same though and created an\nalternative. A good example is [Moment.js] and it's [Many\nalternatives][you-dont-need-momentjs]. But keep in mind: **The best dependency\nis no dependency**, meaning that you should always prefer language builtins over\n3rd party packages. ## 3. Optimize Images ### Why? According to the [Http\nArchive], images are the [biggest contributor to website weight][http archive\nreport, image bytes]. So if your app includes have background images or icons,\nmake sure to optimize them! ### How? You can choose between a variety of manual\noptions ([GIMP], [Photoshop], [Squoosh]) or plugins for your favorite frontend\nbuild tools ([vite-imagetools], [vite-plugin-imagemin],\n[image-minimizer-webpack-plugin]). :::caution The `imagemin` library most of the\nplugins use is [officially unmaintained][imagemin is unmaintained]. ::: - **Use\nmodern image formats** Formats such as `webp` or `avif` offer size reductions of\n**up to 95%** compared to jpeg while maintaining excellent visual accuracy. You\ncan use tools such as [Squoosh] to try different formats on your images. -\n**Size images accordingly** No one will appreciate you shipping the 6K raw image\nwith your app, so make sure to size your image accordingly. Images that appear\nlarge on screen should be sized larger than images that take up less screen\nspace. - **Don't use Responsive Images** In a Web Environment it's recommended\nto use a [Responsive Images] as they will dynamically load the correct image\nsize for each user. You are not building a simple website though: All your\nimages are already downloaded. So using Responsive Images will only bloat your\napp with redundant copies. - **Remove Metadata** Images taken straight from a\ncamera or stock photo side often include metadata about the Camera and Lens\nmodel or Photographer. Not only are those wasted bytes, metadata properties can\nalso hold potentially sensitive information such as the time, day and location\nof the photo. ## 4. Remove Unnecessary Custom Fonts Consider not shipping custom\nfonts with your app and relying on system fonts instead. If you must ship custom\nfonts, make sure they are in modern, optimized formats such as `woff2`. ### Why?\nFonts can be quite large in size, so using the fonts already included in the\nOperating System will reduce your apps footprint. It will also avoid FOUT (Flash\nof Unstyled Text) and make your app feel more \"native\" since it uses the same\nfont as all other apps. If you must include a custom fonts, make sure you\ninclude them in modern formats such as `woff2` as those tend to be way smaller\nthan legacy formats. ### How? Use so called **\"System Font Stacks\"** in your\nCSS. There are number of variations, but here are 3 basic ones to get you\nstarted: - **Sans-serif** ```css font-family: -apple-system, BlinkMacSystemFont,\n'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';\n``` - **Serif** ```css font-family: Iowan Old Style, Apple Garamond,\nBaskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple\nColor Emoji, Segoe UI Emoji, Segoe UI Symbol; ``` - **Monospace** ```css\nfont-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation\nMono, monospace; ``` ## 5. Allowlist Config You can reduce your apps size by\nonly enabling the tauri api features you need in the `allowlist` config. ###\nWhy? The `allowlist` config determines what api features to enable, disabled\nfeatures will **not be compiled into your app**. This is a great way of shedding\nsome extra weight. ### How? And example from a typical `tauri.conf.json`:\n```json { \"tauri\": { \"allowlist\": { \"all\": false, \"fs\": { \"writeFile\": true },\n\"shell\": { \"execute\": true }, \"dialog\": { \"save\": true } } } } ``` ## 6. Rust\nBuild-time Optimizations Configure your cargo project to take advantage of rusts\nsize optimization features. [Why is a rust executable large ?] provides an\nexcellent explanation on why this matters and an in depth walkthrough, while\n[Minimizing Rust Binary Size] is more up to date and has a couple\nrecommendations. ### Why? Rust is notorious for producing rather large binaries,\nbut the compiler offers a number of options to improve the final size. ### How?\nCargo exposes a number of options that determine how the compiler generates your\nbinary. The \"recommended\" options for tauri apps are these: ```toml\n[profile.release] panic = \"abort\" # Strip expensive panic clean-up logic\ncodegen-units = 1 # Compile crates one after another so the compiler can\noptimize better lto = true # Enables link to optimizations opt-level = \"s\" #\nOptimize for binary size ``` :::note There is also `opt-level = \"z\"` available\nto try to reduce the resulting binary size. `\"s\"` and `\"z\"` can sometimes be\nsmaller than the other, so test it with your own application! We've seen smaller\nbinary sizes from `\"s\"` for Tauri example applications, but real world\napplications can always differ. ::: For a detailed explanation of each option\nand a bunch more, refer to the [Cargo books Profiles section][cargo profiles].\n### Unstable Rust Compression Features :::caution The following suggestions are\nall unstable features and require a nightly toolchain. See the [Unstable\nFeatures][cargo unstable features] documentation for more information of what\nthis involves. ::: The following methods involve using unstable compiler\nfeatures and require having a rust nightly toolchain installed. If you don't\nhave the nightly toolchain + `rust-src` nightly component added, try the\nfollowing: ```sh $ rustup toolchain install nightly $ rustup component add\nrust-src --toolchain nightly ``` The Rust Standard Library comes precompiled.\nYou can instead apply the optimization options used for the rest of your binary\n+ dependencies to the std with an unstable flag. This flag requires specifying\nyour target, so know the target triple that you are targeting. ```sh $ cargo\n+nightly build --release -Z build-std --target x86_64-unknown-linux-gnu ``` If\nyou are using `panic = \"abort\"` in your release profile optimizations, then you\nneed to make sure the `panic_abort` crate is compiled with std. Additionally, an\nextra std feature can be used to further reduce the binary size. The following\napplies both: ```sh $ cargo +nightly build --release -Z\nbuild-std=std,panic_abort -Z build-std-features=panic_immediate_abort --target\nx86_64-unknown-linux-gnu ``` See the unstable documentation for more details\nabout [`-Z build-std`][cargo build-std] and [`-Z build-std-features`][cargo\nbuild-std-features]. ## 7. Stripping Use strip utilities to remove debug symbols\nfrom your compiled app. ### Why? Your compiled app will include so-called \"Debug\nSymbols\" that include information such as function and variable names. As your\nend users will most likely not care about debug symbols this is a pretty\nsurefire way to save some bytes! ### How? The easiest way is to use the famous\n`strip` utility to remove this debugging information. ```sh $ strip\ntarget/release/my_application ``` See your local `strip` manpage for more\ninformation and flags that can be used to specify what information gets stripped\nout from the binary. ## 8. UPX UPX, **Ultimate Packer for eXecutables**, is a\ndinosaur amongst the binary packers. This 23-year old, well-maintained piece of\nkit is GPL-v2 licensed with a pretty liberal usage declaration. Our\nunderstanding of the licensing is that you can use it for any purposes\n(commercial or otherwise) without needing to change your license unless you\nmodify the source code of UPX. ### Why? Maybe your target audience has very slow\ninternet, or your app needs to fit on a really small USB stick and all the above\nsteps haven't resulted in the savings you need. Fear not, as we have one last\ntrick up our sleeves: [UPX] compresses your binary and creates a self-extracting\nexecutable that will decompress itself at runtime. ### How? :::caution You\nshould know that this technique might flag your binary as a virus on Windows and\nmacOS - so use at your own discretion, and as always validate with [Frida] and\ndo real distribution testing! ::: #### Usage on macOS ```sh $ brew install upx $\nyarn tauri build $ upx --ultra-brute\nsrc-tauri/target/release/bundle/macos/app.app/Contents/macOS/app Ultimate Packer\nfor eXecutables Copyright (C) 1996 - 2018 UPX 3.95 Markus Oberhumer, Laszlo\nMolnar & John Reiser Aug 26th 2018 File size Ratio Format Name\n-------------------- ------ ----------- ----------- 963140 -> 274448 28.50%\nmacho/amd64 app ``` [cargo-bloat]: https://github.com/RazrFalcon/cargo-bloat\n[Macros]: https://doc.rust-lang.org/book/ch19-06-macros.html [cargo-expand]:\nhttps://github.com/dtolnay/cargo-expand [rollup-plugin-visualizer]:\nhttps://github.com/btd/rollup-plugin-visualizer [rollup-plugin-graph]:\nhttps://github.com/ondras/rollup-plugin-graph [vite]: https://vitejs.dev\n[webpack]: https://webpack.js.org [rollup]: https://rollupjs.org/guide/en/\n[rollup-plugin-terser]: https://github.com/TrySound/rollup-plugin-terser\n[rollup-plugin-uglify]: https://github.com/TrySound/rollup-plugin-uglify\n[terser]: https://terser.org [esbuild]: https://esbuild.github.io [typescript]:\nhttps://www.typescriptlang.org [moment.js]: https://momentjs.com\n[you-dont-need-momentjs]:\nhttps://github.com/you-dont-need/You-Dont-Need-Momentjs [http archive]:\nhttps://httparchive.org [http archive report, image bytes]:\nhttps://httparchive.org/reports/page-weight#bytesImg [imagemin is unmaintained]:\nhttps://github.com/imagemin/imagemin/issues/385 [gimp]: https://www.gimp.org\n[photoshop]: https://www.adobe.com/de/products/photoshop.html [vite-imagetools]:\nhttps://github.com/JonasKruckenberg/imagetools [vite-plugin-imagemin]:\nhttps://github.com/vbenjs/vite-plugin-imagemin [image-minimizer-webpack-plugin]:\nhttps://github.com/webpack-contrib/image-minimizer-webpack-plugin [squoosh]:\nhttps://squoosh.app [responsive images]:\nhttps://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\n[why is a rust executable large ?]:\nhttps://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html\n[minimizing rust binary size]: https://github.com/johnthagen/min-sized-rust\n[cargo unstable features]:\nhttps://doc.rust-lang.org/cargo/reference/unstable.html#unstable-features [cargo\nprofiles]: https://doc.rust-lang.org/cargo/reference/profiles.html [cargo\nbuild-std]: https://doc.rust-lang.org/cargo/reference/unstable.html#build-std\n[cargo build-std-features]:\nhttps://doc.rust-lang.org/cargo/reference/unstable.html#build-std-features\n[Bundlephobia]: https://bundlephobia.com [Frida]: https://frida.re/docs/home/\n[UPX]: https://github.com/upx/upx","url":"https://tauri.studio/docs/building/app-size"},{"id":"prose_docs_building_cross_platform_md","title":"Cross-Platform Compilation","area":"building","section":"building","headings":[],"subHeadings":[],"code":[],"text":"How to use GH Action for Building: a glance at Tauri Action.","url":"https://tauri.studio/docs/building/cross-platform"},{"id":"prose_docs_building_debian_md","title":"Debian packages","area":"building","section":"building","headings":[],"subHeadings":[],"code":["json"],"text":"import Alert from '@theme/Alert' Tauri allows your app to be packaged as a\n`.deb` (Debian package) file. # Bootstrapper Instead of launching the app\ndirectly, you can configure the bundled app to run a script that tries to expose\nthe environment variables to the app; without that you'll have trouble using\nsystem programs because the `PATH` environment variable isn't correct. Enable it\nwith the `useBootstrapper` [/docs/api/config#tauri.bundle.deb.useBootstrapper]\nconfig. # Custom files To include custom files to the debian package, you can\nconfigure a mapping on `tauri.conf.json > tauri > bundle > deb > files` as\nfollows: ```json { \"tauri\": { \"bundle\": { \"deb\": { \"files\": {\n\"/usr/lib/README.md\": \"../README.md\", // copies the README.md file to\n/usr/lib/README.md \"usr/lib/assets\": \"../public/\" // copies the entire public\ndirectory to /usr/lib/assets } } } } } ``` Each `files` object key is the path\non the debian package, and the value is a path to a file or directory relative\nto the `tauri.conf.json` file.","url":"https://tauri.studio/docs/building/debian"},{"id":"prose_docs_building_introduction_md","title":"Introduction","area":"building","section":"building","headings":[],"subHeadings":[],"code":[],"text":"The Tauri Bundler is a Rust harness for compiling your binary, packaging assets,\nand preparing a final bundle. It will detect your operating system and build a\nbundle accordingly. It currently supports: - Linux: .deb, .appimage - macOS:\n.app, .dmg - Windows: .exe, .msi","url":"https://tauri.studio/docs/building/introduction"},{"id":"prose_docs_building_sidecar_md","title":"Sidecar (Embedding External Binaries)","area":"building","section":"building","headings":["Running the sidecar binary on JavaScript","Running the sidecar binary on Rust","Using Node"],"subHeadings":[],"code":["json","bash","javascript","rust"],"text":"import Alert from '@theme/Alert' You may need to embed depending binaries in\norder to make your application work or to prevent users having to install\nadditional dependencies (e.g. Node.js, Python, etc). To bundle the binaries of\nyour choice, you can add the `externalBin` property to the `tauri > bundle`\nobject in your `tauri.conf.json`. See more about tauri.conf.json configuration\nhere [/docs/api/config#tauri.bundle]. `externalBin` expects a list of strings\ntargeting binaries either with absolute or relative paths. Here is a sample to\nillustrate the configuration, this is not a complete `tauri.conf.json` file:\n```json { \"tauri\": { \"bundle\": { \"externalBin\": [\"/absolute/path/to/app\",\n\"relative/path/to/binary\", \"bin/python\"] } } } ``` A binary with the same name\nand a `-$TARGET_TRIPLE` suffix must exist on the specified path. For instance,\n`\"externalBin\": [\"bin/python\"]` requires a\n`src-tauri/bin/python-x86_64-unknown-linux-gnu` executable on Linux. You can\nfind the current platform's target triple running the following command: ```bash\nrustc -Vv | grep host | cut -f2 -d' ' ``` Here's a Node.js script to append the\ntarget triple to a binary: ```javascript const execa = require('execa') const fs\n= require('fs') let extension = '' if (process.platform === 'win32') { extension\n= '.exe' } async function main() { const rustInfo = (await execa('rustc',\n['-vV'])).stdout const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1] if\n(!targetTriple) { console.error('Failed to determine platform target triple') }\nfs.renameSync( `src-tauri/binaries/app${extension}`,\n`src-tauri/binaries/app-${targetTriple}${extension}` ) } main().catch((e) => {\nthrow e }) ``` ## Running the sidecar binary on JavaScript On the JavaScript\ncode, import the `Command` class on the `shell` module and use the `sidecar`\nstatic method: ```javascript import { Command } from '@tauri-apps/api/shell' //\nalternatively, use `window.__TAURI__.shell.Command` // `my-sidecar` is the value\nspecified on `tauri.conf.json > tauri > bundle > externalBin` const command =\nCommand.sidecar('my-sidecar') const output = await command.execute() ``` ##\nRunning the sidecar binary on Rust On the Rust code, import the `Command` struct\nfrom the `tauri::api::process` module: ```rust let (mut rx, mut child) =\nCommand::new_sidecar(\"my-sidecar\") .expect(\"failed to create `my-sidecar` binary\ncommand\") .spawn() .expect(\"Failed to spawn sidecar\");\ntauri::async_runtime::spawn(async move { // read events such as stdout while let\nSome(event) = rx.recv().await { if let CommandEvent::Stdout(line) = event {\nwindow .emit(\"message\", Some(format!(\"'{}'\", line))) .expect(\"failed to emit\nevent\"); // write to stdin child.write(\"message from\nRust\\n\".as_bytes()).unwrap(); } } }); ``` ## Using Node.js on a sidecar The\nTauri [sidecar\nexample](https://github.com/tauri-apps/tauri/tree/dev/examples/sidecar)\ndemonstrates how to use the sidecar API to run a Node.js application on Tauri.\nIt compiles the Node.js code using [pkg](https://github.com/vercel/pkg) and uses\nthe scripts above to run it.","url":"https://tauri.studio/docs/building/sidecar"},{"id":"prose_docs_community_ci_cd_md","title":"CI/CD","area":"community","section":"community","headings":["Continuous Integration","Continuous Deployment"],"subHeadings":["Introduction to immutable checksum","Next Steps"],"code":["yml"],"text":"## Continuous Integration Github Actions has two triggers of which we make heavy\nuse: `push` and `pull_request`. Every commit that made to the repo is a `push`.\nWhen you open a pull request from a branch (call it `great_feature`) to another\nbranch (our working branch, `dev`), each commit to `great_feature` would\npossibly trigger both of these events. We can use a filter to focus on the\nevents we care about though. In our workflows, we only PR (pull request) the\n`dev` and `master` branches. This means that if we filter to only the `dev` and\n`master` branches on commit, we will only run that workflow when we _merge_ a\nPR. A merged PR typically only occurs once a day or less so this will be a good\nfit for the longer running tests, e.g. the smoke tests in our case. Below is how\nthat might look. Unit tests: ```yml # these run fast so we can have them run on\nany commit name: unit tests on: pull_request: push: branches: - dev - master ```\nSmoke tests: ```yml # these run slower so we run only on merges to dev or master\nbranch name: smoke tests on: push: branches: - dev - master ``` Tauri operates\noff the `dev` branch as default, and merges to `master` for release. With these\nGithub Actions set up, we will run the unit tests on every commit to an open PR\n(see `pull_request`). When that PR is merged into `dev`, we will run both the\nunit tests and the smoke tests. ## Continuous Deployment ### Introduction to\nimmutable checksum It is not only possible, but trivial to modify release notes\nand artifacts after it has been published on Github. While there are very valid\nreasons for doing this, it is not exactly a totally trustworthy method - i.e.\nyou have no guarantee that what you are reading is really reflective of the\nunderlying truth or the tarballs. It is technically possible to change downloads\nover the wire or in the box or change checksums in targeted attacks. What we are\nseeking to accomplish is a best case scenario where: 1. Human error is reduced\nto a minimum, but humans are still integral in the actual release 2. Machine\nbuilt assets, changelogs and attached security audits are verifiable with\nchecksums that are published in an immutable, globally available store. To this\nend we fashioned a workflow shown below. As it stands now, we have #3 through #6\nimplemented. We manually do #2 which then feeds into #3 and kicks off the rest\nof the automatic workflow. 1. a human pushes to dev through a pull request (can\nhappen any number of times) - pull request includes a changeset file describing\nthe change and required version bump 2. a pull request is created (or updated)\nto include the change and version bump - this pull request stays open and will\nbe force pushed until it gets merged (and published) - increase the version\nnumber based on changesets - delete all changeset files 3. a codeowner merges\nthe publish PR to dev (no direct push permissible for anyone) - all tests (unit,\ne2e, smoke tests) are run on the PR - failures prevent the publish so they must\npass before merge 4. merge to dev triggers release sequence - changes are\nsquashed and a PR is opened against master 5. when PR to master is merged... -\nvulnerability audit (crates and yarn) and output saved - checksums and metadata\nand output saved - packages are published on npm/cargo, tarball/zip created -\nrelease is created for each package that had updates (if version isn't changed,\nbuild skips the publish steps) - output from audit/checksums is piped into the\nrelease body - tarball / zip attached to release - async process to publish to\nIOTA tangle (feeless) via release tag [note: still have things to resolve here]\n6. release is complete - master has updated code and tagged - GitHub release has\ntarballs, checksums, and changelog (may have multiple releases if more than one\npackage published) [note: is part of step 2 and is not yet implemented] ### Next\nSteps Next steps may include transferring and publishing the built assets to\nadditional places: 1. Tauri's private verdaccio 2. IPFS 3. PureOS Gitlab 4.\nGitHub Packages We can also do some interesting things like signing our\nreleases, including a hash in the release and/or even publishing this\ninformation on a blockchain that it can be easily verified. Publishing on the\nblockchain is another avenue to increase the confidence that what is seen on\nGitHub matches what you have downloaded. The IOTA foundation created a Github\nAction which will publish a release to their blockchain. This has shown promise,\nbut he gave a couple errors to tackle still.","url":"https://tauri.studio/docs/community/ci-cd"},{"id":"prose_docs_community_contributor_guide_md","title":"Contributor Guide","area":"community","section":"community","headings":["Contribution Flow","Hands On Example"],"subHeadings":["A Note About Contributions to the Rust Libraries"],"code":["sh","json","ini"],"text":"todo: make this friendlier and more complete Tauri is a polyglot system that\nuses: - git - Node.js - Rust - GitHub actions It can be developed on macOS,\nLinux and Windows. ## Contribution Flow 1. File an Issue 2. Fork the Repository\n3. Make Your Changes 4. Make a PR ### A Note About Contributions to the Rust\nLibraries When contributing to the Rust libraries `tauri`, `tauri-api`, and\n`tauri-updater`; you will want to setup an environment for RLS (the Rust\nLanguage Server). In the Tauri root directory, there is a `.scripts` folder that\ncontains a set of scripts to automate adding a couple temporary environment\nvariables to your shell/terminal. These environment variables point to\ndirectories in the test fixture which will prevent RLS from crashing on\ncompile-time. This is a necessary step for setting up a development environment\nfor Tauri's Rust libraries. ##### _Example Instructions_ 1. Navigate to the\nTauri Root directory. 2. Execute a script based on your Operating System from\nthis folder: `.scripts/init_env.bat` for Windows Cmd, `.scripts/init_env.ps1`\nfor Windows Powershell, `. .scripts/init_env.sh` for Linux/macOS bash (note the\nfirst `.` in this command). 3. Open your text editor/IDE from this\nshell/terminal. ## Hands On Example Let's make a new example. That's a great way\nto learn. We are going to assume you are on a nixy type of environment like\nLinux or macOS and have all of your development dependencies like rust and node\nalready sorted out. ```sh git clone git@github.com:tauri-apps/tauri.git cd\ntauri/cli/tauri.js yarn mkdir ../../examples/vanillajs && cd \"$_\" ``` ```json\n\"tauri:source\": \"node ../../../cli/tauri.js/bin/tauri\", ``` ```ini\n[dependencies.tauri] path = \"../../../../core/tauri\" features = [ \"all-api\" ]\n```","url":"https://tauri.studio/docs/community/contributor-guide"},{"id":"prose_docs_debugging_debugging_md","title":"Debugging","area":"debugging","section":"debugging","headings":["Rust Console","WebView JS Console","Create a Debug Build","Run Your App From the Terminal"],"subHeadings":[],"code":["rust","sh",null],"text":"import Alert from '@theme/Alert' import Command from '@theme/Command' With all\nthe moving pieces in Tauri, you may run into a problem that requires debugging.\nThere are a handful of locations where error details are printed, and Tauri\nincludes some tools to make the debugging process easier. ## Rust Console When\nyou run a Tauri app in development mode you will have a Rust console available.\nThis is in the terminal where you ran e.g. `tauri dev`. You can use the\nfollowing code to print something to that console from within a Rust file:\n```rust println!(\"Message from Rust: {}\", msg); ``` Sometimes you may have an\nerror in your Rust code, and the Rust compiler can give you lots of information.\nIf, for example, `tauri dev` crashes, you can rerun it like this on Linux and\nmacOS: ```sh RUST_DEBUG=1 tauri dev ``` or like this on MS Windows: ```sh set\nRUST_DEBUG=1 tauri dev ``` This will give you a granular stack trace. Generally\nspeaking, the Rust compiler will help you by giving you detailed information\nabout the issue, such as: ``` error[E0425]: cannot find value `sun` in this\nscope --> src/main.rs:11:5 | 11 | sun += i.to_string().parse::().unwrap(); | ^^^\nhelp: a local variable with a similar name exists: `sum` error: aborting due to\nprevious error For more information about this error, try `rustc --explain\nE0425`. ``` ## WebView JS Console Right click in the WebView, and choose\n`Inspect Element`. This will open up a web-inspector similar to the Chrome or\nFirefox dev tools you are used to. ## Create a Debug Build There are cases where\nyou might need to inspect the JS console in the final bundle, so Tauri provides\na simple command to create a debugging bundle: Like the normal build and dev\nprocesses, the first time you run this it will take more time than subsequent\nruns. The final bundled app will be placed in `src-tauri/target/debug/bundle`.\nThat app will ship with the development console enabled. ## Run Your App From\nthe Terminal You can also run a built app from the terminal, which will also\ngive you the Rust compiler notes (in case of errors) or your `println` messages.\nJust find the file `src-tauri/target/(release|debug)/[app name]` and either\ndouble click it (but be warned, the terminal will close on errors) or just run\nit in directly in your console.","url":"https://tauri.studio/docs/debugging/debugging"},{"id":"prose_docs_development_development_cycle_md","title":"Development Cycle","area":"development","section":"development","headings":[],"subHeadings":["1","2"],"code":[],"text":"import Alert from '@theme/Alert' import Command from '@theme/Command' ### 1.\nStart Your Devserver Now that you have everything setup, you should start your\napplication development server provided by your UI framework or bundler\n(assuming you're using one, of course). Every framework has its own development\ntooling. It is outside of the scope of this document to treat them all or keep\nthem up to date. ### 2. Start Tauri Development Window The first time you run\nthis command, it will take several minutes for the Rust package manager to\ndownload and build all the required packages. Since they are cached, subsequent\nbuilds will be much faster, as only your code will need rebuilding. Once Rust\nhas finished building, the webview will open and it should display your web app.\nYou can make changes to your web app, and if your tooling enables it, the\nwebview should update automatically just like a browser. When you make changes\nto your Rust files, they will be rebuilt automatically and your app will\nrestart. In your project repository, you SHOULD commit the\n\"src-tauri/Cargo.lock\" along with the \"src-tauri/Cargo.toml\" to git because\nCargo uses the lockfile to provide deterministic builds. As a result, it is\nrecommended that all applications check in their Cargo.lock. You SHOULD NOT\ncommit the \"src-tauri/target\" folder or any of its contents.","url":"https://tauri.studio/docs/development/development-cycle"},{"id":"prose_docs_development_security_md","title":"Security","area":"development","section":"development","headings":["Tauri Features to keep you Safer"],"subHeadings":["Secure content loading","Isolation Pattern","Tauri API"],"code":["typescript","rust","json"],"text":"import Alert from '@theme/Alert' Whether you like it or not, today's\napplications live in operating systems that can be -- and regularly are --\ncompromised by any number of attacks. When your insecure application is a\ngateway for such lateral movement into the operating system, you are\ncontributing to the tools that professional hackers have at their disposal.\nDon't be a tool. This is why we have taken every opportunity to help you secure\nyour application, prevent undesired access to system level interfaces, and\nmanufacture bullet-proof applications. Your users assume you are following best\npractices. We make that easy, but you should still read up on it below. ##\nSecurity Is A Community Responsibility (adapted from\n[Electron](https://www.electronjs.org/docs/latest/tutorial/security#security-is-everyones-responsibility))\nIt is important to remember that the security of your Tauri application is the\nresult of the overall security of Tauri itself, all Rust and NPM dependencies,\nyour code, and the devices that run the final application. The Tauri Team does\nits best to do its part, the security community does its part, and you too would\ndo well to follow a few important best practices: - **Keep your application\nup-to-date with the latest Tauri release.** When releasing your app into the\nwild, you are also shipping a bundle that has Tauri in it. Vulnerabilities\naffecting Tauri may impact the security of your application. By updating Tauri\nto the latest version, you ensure that critical vulnerabilities are already\npatched and cannot be exploited in your application. Also be sure to keep your\ncompiler (rustc) and transpilers (nodejs) up to date, because there are often\nsecurity issues that are resolved. - **Evaluate your dependencies.** While NPM\nand Crates.io provide many convenient packages, it is your responsibility to\nchoose trustworthy 3rd-party libraries - or rewrite them in Rust. If you do use\noutdated libraries affected by known vulnerabilities or are unmaintained, your\napplication security and good-night's sleep could be in jeopardy. Use tooling\nlike `npm audit` and `cargo audit` to automate this process and lean on the\nsecurity community's important work. - **Adopt more secure coding practices.**\nThe first line of defense for your application is your own code. Although Tauri\ncan protect you from common web vulnerabilities, such as Cross-Site Scripting\nbased Remote Code Execution, improper configurations can have a security impact.\nEven if this were not the case, it is highly recommended to adopt secure\nsoftware development best practices and perform security testing. We detail what\nthis means in the next section. - **Educate your Users.** True security really\nmeans that unexpected behaviour cannot happen. So in a sense, being more secure\nmeans having the peace of mind in knowing that ONLY those things that you want\nto happen can happen. In the real world, though, this is a utopian \"dream\".\nHowever, by removing as many vectors as possible and building on a solid\nfoundation, your choice for Tauri is a signal to your users that you really care\nabout them, their safety, and their devices. ## Threat Models Tauri applications\nare composed of many pieces at different points of the lifecycle. Here we\ndescribe classical threats and what you SHOULD do about them. - **Upstream\nThreats.** Tauri is a direct dependency of your project, and we maintain strict\nauthorial control of commits, reviews, pull-requests, and releases. We do our\nbest to maintain up-to-date dependencies and take action to either update or\nfork&fix. Other projects may not be so well maintained, and may not even have\never been audited. Please consider their health when integrating them, because\notherwise you may have adopted architectural debt without even knowing it. -\n**Development Threats.** We assume that you, the developer, care for your\ndevelopment environment like a shrine of purity because it is a thing of beauty.\nIt is on you to make sure that your operating system, build toolchains, and\nassociated dependencies are kept up to date. A very real risk all of us face is\nwhat is known as \"supply-chain attacks\", which are usually considered to be\nattacks on direct dependencies of your project. However, there is a growing\nclass of attacks in the wild that directly target development machines, and you\nwould be well-off to address these head-on. One practice that we highly\nrecommend, even if it is a bit more time intensive, is to only ever consume\ncritical dependencies from git using hash revisions at best or named tags as\nsecond best. This holds true for Rust as well as the Node ecosystem. Also,\nconsider requiring all contributors to sign their commits and protect GIT\nbranches and pipelines. - **Buildtime Threats.** Modern organisations use CI/CD\nto manufacture binary artifacts. At Tauri, we even provide a Github Workflow for\nbuilding on multiple platforms. If you create your own CI/CD and depend on\nthird-party tooling, be wary of actions whose versions you have not explicitly\npinned. You should sign your binaries for the platform you are shipping to, and\nwhile this can be complicated and somewhat costly to setup, end-users expect\nthat your app is verifiably from you. - **Runtime Threats** We assume the\nwebview is insecure, which has led Tauri to implement several protections\nregarding webview access to system APIs in the context of loading untrusted\nuserland content. You can read more in detail below, but using the CSP will\nlockdown types of communication that the Webview can undertake. Furthermore,\nthere is a novel \"Isolation\" pattern that prevents untrusted content or scripts\nfrom accessing the API within the Webview. And please, whatever you do, DO NOT\ntrust the results of cryptography using private keys in the Webview. We gave you\nRust for a reason. - **Updater Threats** We have done our best to make shipping\nhot-updates to the app as straightforward and secure as possible. However, if\nyou lose control of the manifest server, the build server, or the binary hosting\nservice - all bets are off. If you are building your own system, consult a\nprofessional OPS architect and build it properly. ## An unsorted list of big ole\nDONT'S: - DON'T accept content over http:// or ws:// - DON'T ship an app with\nthe development console enabled - DON'T forget to [read about\nXSS](https://owasp.org/www-community/attacks/xss/) - DON'T ship any kind of\nlocalhost server unless the app needs to talk to other devices - DON'T consume\nJS from a CDN without using an integrity checksum ## Security Researchers\nNothing is perfect, attack vectors will be found, and if you have found one - we\nwant to know about it. If you have a discovery, PLEASE DO NOT FILE A PUBLIC\nISSUE OR MAKE A PULL REQUEST. Please discretely reach out to a member of the\nteam via Discord or Email for verification, vulnerability acceptance, and\nremediation timeline. We believe in - and participate in - responsible\ndisclosure. At this time we do not have a bug-bounty programme in place, but are\nactively considering it. ## Tauri Features to keep you Safer ### Secure content\nloading Tauri restricts the [Content Security Policy\n(CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) of your HTML\npages. Local scripts are hashed, styles and external scripts are referenced\nusing a cryptographic nonce, which prevents unallowed content from being loaded.\nThe CSP protection is only enabled if\n[`tauri.security.csp`](/docs/api/config/#tauri.security.csp) is set on the Tauri\nconfiguration file. You should make it as restricted as possible, only allowing\nthe webview to load assets from hosts you trust and preferably own. At compile\ntime, Tauri appends its nonces and hashes to the relevant CSP attributes\nautomatically, so you only need to worry about what is unique to your\napplication. See script-src\n[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src],\nstyle-src\n[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src]\nand CSP Sources\n[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources]\nfor more information about this protection. With the CSP protection enabled,\nusing inline `style` attributes it not allowed. Avoid loading remote content\nsuch as scripts served over a CDN as they introduce an attack vector, but any\nuntrusted file can introduce new and subtle attack vectors. ### Isolation\nPattern The [Isolation pattern](../architecture/patterns/isolation.md) is a way\nto inject a secondary, ideally minimal, JavaScript application in between your\nfrontend application and Tauri Core. This minimal Isolation application can then\nbe used to securely verify and modify IPC messages before they reach Tauri Core.\n[The Isolation pattern guide](../architecture/patterns/isolation.md) has more\ninformation. ### Tauri API The [Tauri\nAPI](https://www.npmjs.com/package/@tauri-apps/api) provides functions to access\ncommon native functionality such as filesystem access, HTTP requests, system\nnotifications and child processes usage. They provide an easy path to JavaScript\ndevelopers to access the operating system, but they should be used carefully.\n#### Prefer specific commands When accessing a native API, you should prefer\nwriting a dedicated command to implement your business logic instead of writing\neverything on the frontend layer. For instance, see the following frontend API\nusage: ```typescript import { writeFile, Dir } from '@tauri-apps/api/fs' await\nwriteFile({ path: 'report.txt', contents: 'the file content' }, { dir: Dir.App,\n}) ``` If you do not enable the [isolation pattern](#Isolation-pattern), an\nattacker with remote code execution can overwrite the contents of `report.txt`\nsince that API is generic and enabled. If you use a dedicated command, this is\nnot an issue: ```rust #[tauri::command] async fn write_report(app:\ntauri::AppHandle) -> Result<(), String> { let app_dir =\napp.path_resolver().app_dir().expect(\"failed to get app dir\"); let report_path =\napp_dir.join(\"report.txt\"); std::fs::write(&report_path, \"the file content\")\n.map_err(|e| e.to_string()); Ok(()) } fn main() { tauri::Builder::default()\n.invoke_handler(tauri::generate_handler![write_report])\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ```typescript import { invoke } from\n'@tauri-apps/api/tauri' await invoke('write_report') ``` This example command\nwritten on the backend cannot be exploited. Tauri recommends using the webview\nas only a user interface layer, keeping important logic on the core layer. ####\nThe allowlist When using the API package, you **must** enable only the\ninterfaces your application is using. See [the allowlist\nconfiguration](/docs/api/config/#tauri.allowlist) for options to restrict which\nAPIs are enabled. This not only reduces surface area, but also treeshakes out\nunneeded functionality -- which reduces final binary size. #### API scoping Some\nAPI modules provides a configuration to scope the API access and restrict the\nsystem resources accessed. ##### Filesystem You can restrict the folders and\nfiles that can be accessed when using the `fs` module. The scope array lists\nwhat paths are allowed using glob patterns and predefined variables that\nresolves to a system base directory. The variables are: `$AUDIO`, `$CACHE`,\n`$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`, `$DOCUMENT`, `$DOWNLOAD`, `$EXE`,\n`$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`, `$RUNTIME`, `$TEMPLATE`, `$VIDEO`,\n`$RESOURCE`, `$APP` and `$CWD`. ```json { \"tauri\": { \"allowlist\": { \"fs\": {\n\"scope\": [\"$APP/db/*\", \"$RESOURCE/check.png\"] } } } } ``` ###### Asset protocol\nYou can restrict the folders and files that can be accessed when using the\n`asset` protocol. The scope array has the same syntax as the `fs` scope array:\n```json { \"tauri\": { \"allowlist\": { \"path\": { \"all\": true }, \"protocol\": {\n\"asset\": true, \"assetScope\": ['$APP/assets/*'] } } } } ``` ```typescript import\n{ appDir, join } from '@tauri-apps/api/path' import { convertFileSrc } from\n'@tauri-apps/api/tauri' const appDirPath = await appDir() // this path is\nallowed - is matches $APP/assets/* // you can use this on tags or window.fetch()\ncalls const allowedPath = convertFileSrc(await join(appDirPath, 'assets',\n'tauri.mp4')) // this path is not allowed - it does not match $APP/assets/*\nconst disallowedPath = convertFileSrc(await join(appDirPath, 'tauri.mp4')) ```\n###### HTTP You can restrict the URLs and paths that can be accessed when using\nthe `http` module: ```json { \"tauri\": { \"allowlist\": { \"http\": { \"scope\":\n[\"https://api.github.com/repos/tauri-apps/*\"] } } } } ``` ```typescript import {\nfetch } from '@tauri-apps/api/http' // this promise is resolved await\nfetch('https://api.github.com/repos/tauri-apps/tauri') // this promise is\nrejected - the URL is not allowed on the scope await\nfetch('https://api.github.com/repos/electron/electron') ``` ###### Shell To\nprevent unrestricted access to process spawning, Tauri offers a configuration to\ndefine programs and command line arguments that are allowed to be used. While it\ncan make userland ergonomics less simple, is good security hygiene to lock down\nshell commands from spawning other, unexpected commands. ```json { \"tauri\": {\n\"allowlist\": { \"shell\": { \"scope\": [ { \"name\": \"install-dep\", \"cmd\": \"apt-get\",\n\"args\": [ \"install\", { \"validator\": \"(gcc|rustc)$\" } ] } ], // allows using the\n`open` API only using arguments that match this regex // `true` is also a valid\nvalue, which defines the regex as `https?://`. \"open\":\n\"^https://github.com/tauri-apps/\" } } } } ``` ```typescript import { Command,\nopen } from '@tauri-apps/api/shell' // this command is allowed new\nCommand('install-dep', ['install', 'rustc']).spawn() // this command is not\nfound - does not match the `name` value of the scope definition new\nCommand('install-my-dep', ['install', 'rustc']).spawn() // this command is\nrejected - does not match validator regex for the second argument new\nCommand('install-dep', ['install', 'tar']).spawn() // this command is rejected -\nextra argument new Command('install-dep', ['install', 'rustc', '-y']).spawn() //\nthis open() usage is allowed because it matches the `open` regex await\nopen('https://github.com/tauri-apps/tauri') // this open() call is rejected -\ndoes not match validator regex open('https://docs.rs/tauri/latest/tauri') ```","url":"https://tauri.studio/docs/development/security"},{"id":"prose_docs_development_updating_dependencies_md","title":"Updating Dependencies","area":"development","section":"development","headings":["Automatic updates","Manual updates"],"subHeadings":["Update NPM Packages"],"code":[],"text":"import Alert from '@theme/Alert' Especially during the alpha and beta phases,\nyou are expected to keep all Tauri dependencies and toolchains up to date. There\nis no support for any versions other than latest. ## Automatic updates The Tauri\nJS CLI has a command to install and update all needed dependencies, just run\n`tauri deps install` or `tauri deps update`. ## Manual updates ### Update NPM\nPackages If you are using the `tauri` package: ```bash $ yarn upgrade\n@tauri-apps/cli @tauri-apps/api --latest $ npm install @tauri-apps/cli@latest\n@tauri-apps/api@latest ``` You can also detect what the latest version of Tauri\nis on the command line, using: - `npm outdated @tauri-apps/cli` - `yarn outdated\n@tauri-apps/cli` Alternatively, if you are using the `vue-cli-plugin-tauri`\napproach: ```bash $ yarn upgrade vue-cli-plugin-tauri --latest $ npm install\nvue-cli-plugin-tauri@latest ``` ### Update Cargo Packages Go to\n`src-tauri/Cargo.toml` and change `tauri` to `tauri = { version = \"%version%\" }`\nwhere `%version%` is the version number shown above. (You can just use the\n`MAJOR.MINOR`) version, like `0.9`. Then do the following: ```bash $ cd\nsrc-tauri $ cargo update -p tauri ``` You can also run `cargo outdated -r tauri`\nto get direct information about the core library's latest version.","url":"https://tauri.studio/docs/development/updating-dependencies"},{"id":"prose_docs_distribution_linux_md","title":"Linux Application Distribution","area":"distribution","section":"distribution","headings":["Limitations","Debian","AppImage"],"subHeadings":[],"code":["json"],"text":"Tauri applications for Linux are distributed either with a [Debian\npackage](https://wiki.debian.org/Packaging) (a file with the `.deb` extension)\nor as an [AppImage](https://appimage.org/) when building using the Tauri CLI. ##\nLimitations Core libraries such as glibc frequently break compability with older\nsystems. For this reason, you must build your Tauri application using the oldest\nbase system you intend to support. A relatively old system such as Ubuntu 18.04\nis more suited than Ubuntu 21.04, as the binary compiled on Ubuntu 21.04 will\nhave a higher requirement of the glibc version, so when running on an older\nsystem you will face a runtime error like `/usr/lib/libc.so.6: version\n'GLIBC_2.33' not found`. We recommend using a Docker container or GitHub Actions\nto build your Tauri application for Linux. See the issues\n[#1355](https://github.com/tauri-apps/tauri/issues/1355) and\n[rust-lang/rust#57497](https://github.com/rust-lang/rust/issues/57497), in\naddition to the [AppImage\nguide](https://docs.appimage.org/reference/best-practices.html#binaries-compiled-on-old-enough-base-system)\nfor more information. ## Debian The stock Debian package generated by the Tauri\nbundler has everything you need to ship your application to Debian-based Linux\ndistributions, defining your application's icons, generating a Desktop file and\nspecifying the dependencies `libwebkit2gtk-4.0-37` and `libgtk-3-0`, along with\n`libappindicator3-1` if your app uses the system tray. If you need extended\ncontrol over the Debian package, you can provide a list of folders or files to\nmove to the package. The configuration object maps the path in the Debian\npackage to the path to the file on your filesystem, relative to the core binary\ncrate folder (`./src-tauri` by default). Here's an example configuration:\n```json { \"tauri\": { \"bundle\": { \"deb\": { \"files\": { \"usr/share/my-app\":\n\"../assets/\", // copy the entire assets directory to /usr/share/my-app\n\"/usr/share/doc/my-app/README.md\": \"../README.md\", // copy a single file } } } }\n} ``` ## AppImage AppImage is a distribution format that does not rely on the\nsystem installed packages and instead bundles all dependencies and files needed\nby the application. For this reason, the output file is larger but easier to\ndistribute since it is supported on many Linux distributions and can be executed\nwithout installation, just making the file executable (`$ chmod a+x\nMyProject.AppImage`) and running it (`./MyProject.AppImage`). AppImages are\nconvenient, simplifying the distribution process if you cannot make a package\ntargeting the distribution's package manager, but you should carefully use it as\nthe file size grows from the 2-6MBs range to 70+MBs.","url":"https://tauri.studio/docs/distribution/linux"},{"id":"prose_docs_distribution_macos_md","title":"macOS Application Distribution","area":"distribution","section":"distribution","headings":["Binary targets","Application bundle customization","Code signing and notarization"],"subHeadings":[],"code":[],"text":"Tauri applications for macOS are distributed either with an [Application\nBundle](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html)(`.app`\nfiles) or an Apple Disk Image (`.dmg` files). The Tauri CLI automatically\nbundles your application code in these formats, providing options to code sign\nand notarize your application. ## Binary targets You can compile your\napplication targeting Apple Silicon, Intel-based Mac computers or universal\nmacOS binaries. By default, the CLI builds a binary targetting your machine's\narchitecture, but if you are using an Apple Silicon macOS you can compile Intel\nand universal binaries using the `target` option: - `tauri build --target\naarch64-apple-darwin`: targets Apple Silicon for your application; - `tauri\nbuild --target x86_64-apple-darwin`: targets Intel-based Mac computers; - `tauri\nbuild --target universal-apple-darwin`: targets [universal macOS\nbinaries](https://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary).\n:::caution - Apple Silicon binaries only runs on Mac computers with Apple\nSilicon. - Intel-based binaries only runs on Intel-based Mac computers and on\nApple Silicion computers under the Rosetta translation. - Universal macOS\nbinaries runs on both architectures. ::: ## Application bundle customization The\nTauri configuration file provides the following options to customize your\napplication bundle: - **Bundle name**:\n[`package.productName`](/docs/api/config/#package.productName). - **Bundle\nversion**: [`package.version`](/docs/api/config/#package.version). -\n**Application category**:\n[`tauri.bundle.category`](/docs/api/config/#tauri.bundle.category). -\n**Copyright**:\n[`tauri.bundle.copyright`](/docs/api/config/#tauri.bundle.copyright). - **Bundle\nicon**: first `.icns` file listed on the\n[`tauri.bundle.icon`](/docs/api/config/#tauri.bundle.icon) array. - **Minimum\nsystem version**:\n[`tauri.bundle.macOS.minimumSystemVersion`](/docs/api/config/#tauri.bundle.macOS.minimumSystemVersion).\n- DMG license file**:\n[`tauri.bundle.macOS.license`](/docs/api/config/#tauri.bundle.macOS.license). -\n[**Entitlements.plist\nfile**](https://developer.apple.com/documentation/bundleresources/entitlements):\n[`tauri.bundle.macOS.entitlements`](/docs/api/config/#tauri.bundle.macOS.entitlements).\n- **Exception domain**: an insecure domain that your application can access such\nas a `localhost` or a remote `http` domain. It is a convenience configuration\naround `NSAppTransportSecurity > NSExceptionDomains` setting\n`NSExceptionAllowsInsecureHTTPLoads` and `NSIncludesSubdomains` to true. See\n[`tauri.bundle.macOS.exceptionDomain`](/docs/api/config/#tauri.bundle.macOS.exceptionDomain).\n- **Bootstrapper**: Instead of launching the app directly, you can configure the\nbundled app to run a script that tries to expose the environment variables to\nthe app; without that you'll have trouble using system programs because the\n`PATH` environment variable isn't correct. Enable it with\n[`tauri.bundle.macOS.useBootstrapper`](/docs/api/config#tauri.bundle.deb.useBootstrapper).\n:::note These options generate the application bundle [Info.plist\nfile](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html).\nYou can extend the generated file with your own `Info.plist` file stored on the\nTauri folder (`src-tauri` by default). The CLI will merge both `.plist` files on\nproduction, and the core layer will embed it on the binary on development. :::\n## Code signing and notarization See the [Code signing guide](./sign-macos.md).","url":"https://tauri.studio/docs/distribution/macos"},{"id":"prose_docs_distribution_publishing_md","title":"App Publishing","area":"distribution","section":"distribution","headings":[],"subHeadings":["1","2"],"code":[],"text":"import Alert from '@theme/Alert' import Command from '@theme/Command' ### 1.\nBuild Your Web App Now that you are ready to package your project, you will need\nto run your framework's or bundler's build command (assuming you're using one,\nof course). Every framework has its own publishing tooling. It is outside of the\nscope of this document to treat them all or keep them up to date. ### 2. Bundle\nyour application with Tauri This command will embed your web assets into a\nsingle binary with your Rust code. The binary itself will be located in\n`src-tauri/target/release/[app name]`, and installers will be located in\n`src-tauri/target/release/bundle/`. Like the `tauri dev` command, the first time\nyou run this, it will take some time to collect the Rust crates and build\neverything - but on subsequent runs it will only need to rebuild your code,\nwhich is much quicker.","url":"https://tauri.studio/docs/distribution/publishing"},{"id":"prose_docs_distribution_sign_macos_md","title":"Code Signing macOS Applications","area":"distribution","section":"distribution","headings":["Requirements","tl","Signing Tauri apps"],"subHeadings":["Creating a signing certificate","Downloading a certificate","Signing the Tauri application","Building the application","Example"],"code":["yml"],"text":"import Alert from '@theme/Alert' This guide provides information on code signing\nand notarization for macOS applications. If you are not utilizing GitHub Actions\nto perform builds of OSX DMGs, you will need to ensure the environment variable\nCI=true exists. For more information refer to Issue #592\n[https://github.com/tauri-apps/tauri/issues/592]. ## Requirements - Xcode 11 or\nabove. - An Apple Developer account enrolled to the [Apple Developer\nProgram](https://developer.apple.com/programs/). ## tl;dr The Tauri code signing\nand notarization process is configured through the following environment\nvariables: - `APPLE_SIGNING_IDENTITY`: the name of the keychain entry that\ncontains the signing certificate. - `APPLE_CERTIFICATE`: base64 string of the\n`.p12` certificate, exported from the keychain. Useful if you don't have the\ncertificate on the keychain (e.g. CI machines). - `APPLE_CERTIFICATE_PASSWORD`:\nthe password for the `.p12` certificate. - `APPLE_ID` and `APPLE_PASSWORD`: your\nApple account email and an [app-specific\npassword](https://support.apple.com/en-ca/HT204397). Only required to notarize\nthe app. - `APPLE_API_ISSUER` and `APPLE_API_KEY`: authentication with an App\nStore Connect API key instead of the Apple ID. Only required to notarize the\napp. ## Signing Tauri apps The first step to sign a macOS application is getting\na signing certificate from the Apple Developer Program. ### Creating a signing\ncertificate To create a new signing certificate you must generate a Certificate\nSigning Request (CSR) file from your Mac computer. [This\nguide](https://help.apple.com/developer-account/#/devbfa00fef7) describes the\nprocess to create a CSR. On your Apple Developer account, navigate to the\n[Certificates, IDs & Profiles\npage](https://developer.apple.com/account/resources/certificates/list) and click\non the `Add` button to open the interface to create a new certificate. Choose\nthe appropriate certificate type (`Apple Distribution` to submit apps to the App\nStore, and `Developer ID Application` to ship apps outside of the App Store).\nUpload your CSR and the certificate will be created. Only the Apple Developer\n`Account Holder` can create Developer ID Application certificates, but it can be\nassociated to a different Apple ID by creating a CSR with a different user email\naddress. ### Downloading a certificate On [Certificates, IDs & Profiles\npage](https://developer.apple.com/account/resources/certificates/list), click on\nthe certificate you want to use and then click on the `Download` button. It will\nsave a `.cer` file that once opened, installs the certificate on the keychain.\nThe name of the keychain entry represents the `signing identity`, which can also\nbe found by executing `$ security find-identity -v -p codesigning`. A signing\ncertificate is only valid if associated with your Apple ID. An invalid\ncertificate won't be listed on the Keychain Access > My Certificates tab or the\n$ security find-identity -v -p codesigning output. ### Signing the Tauri\napplication The signing configuration is provided to the Tauri bundler via\nenvironment variables. You will need to configure the certificate to use and an\noptional authentication configuration to notarize the application. ####\nCertificate environment variables - `APPLE_SIGNING_IDENTITY`: this is the\n`signing identity` we highlighted above. It must be defined to sign apps both\nlocally and on CI machines. Additionally, to simplify the process of code\nsigning on CI, Tauri can install the certificate on the keychain for you if you\ndefine the `APPLE_CERTIFICATE` and `APPLE_CERTIFICATE_PASSWORD` environment\nvariables. 1. Open the `Keychain Access` app and find your certificate's\nkeychain entry. 2. Expand the entry, double click on the key item and select\n`Export \"$KEYNAME\"`. 3. Select the path to save the `.p12` file and define the\nexported certificate password. 4. Convert the `.p12` file to base64 running the\nfollowing script on the terminal: `openssl base64 -in /path/to/certificate.p12\n-out certificate-base64.txt`. 5. Set the contents of the\n`certificate-base64.txt` file to the `APPLE_CERTIFICATE` environment variable.\n6. Set the certificate password to the `APPLE_CERTIFICATE_PASSWORD` environment\nvariable. #### Authentication environment variables These variables are only\nrequired to notarize the application. Notarization is required when using a\nDeveloper ID Application certificate. - `APPLE_ID` and `APPLE_PASSWORD`: to\nauthenticate with your Apple ID, set the `APPLE_ID` to your Apple account email\n(example: `export APPLE_ID=tauri@icloud.com`) and the `APPLE_PASSWORD` to an\n[app-specific password](https://support.apple.com/en-ca/HT204397) for the Apple\naccount. - `APPLE_API_ISSUER` and `APPLE_API_KEY`: alternatively, you can\nauthenticate using an App Store Connect API key. Open the App Store Connect's\n[Users and Access page](https://appstoreconnect.apple.com/access/users), select\nthe `Keys` tab and click on the `Add` button; select a name and the `Developer`\naccess. The `APPLE_API_ISSUER` (`Issuer ID`) is presented above the keys table,\nand the `APPLE_API_KEY` is the value on the `Key ID` column on that table. You\nalso need to download the private key, which can only be done once and is only\nvisible after a page reload (the button is shown on the table row for the newly\ncreated key). The private key file must be saved on `./private_keys`,\n`~/private_keys`, `~/.private_keys` or `~/.appstoreconnect/private_keys`, as\nstated on the `$ xcrun altool --help` command. ### Building the application With\nall these environment variables set, the Tauri bundler will automatically sign\nand notarize your application when you run the `tauri build` command. ###\nExample The following example uses GitHub Actions to sign an application using\nthe [Tauri action](https://github.com/tauri-apps/tauri-action). On GitHub, we\nfirst define the environment variables we listed above as GitHub Secrets. You\ncan view this guide\n[https://docs.github.com/en/actions/reference/encrypted-secrets] to learn about\nGitHub secrets. Once we have established the GitHub Secrets we will create a\nGitHub publish workflow in `.github/workflows/main.yml`: ```yml name: \"publish\"\non: push: branches: - release jobs: publish-tauri: strategy: fail-fast: false\nmatrix: platform: [macos-latest] runs-on: ${{ matrix.platform }} steps: - uses:\nactions/checkout@v2 - name: setup node uses: actions/setup-node@v2 with:\nnode-version: 12 - name: install Rust stable uses: actions-rs/toolchain@v1 with:\ntoolchain: stable - name: install app dependencies and build it run: yarn &&\nyarn build - uses: tauri-apps/tauri-action@v0 env: GITHUB_TOKEN: ${{\nsecrets.GITHUB_TOKEN }} ENABLE_CODE_SIGNING: ${{ secrets.APPLE_CERTIFICATE }}\nAPPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }} APPLE_CERTIFICATE_PASSWORD:\n${{ secrets.APPLE_CERTIFICATE_PASSWORD }} APPLE_SIGNING_IDENTITY: ${{\nsecrets.APPLE_IDENTITY_ID }} APPLE_ID: ${{ secrets.APPLE_ID }} APPLE_PASSWORD:\n${{ secrets.APPLE_PASSWORD }} with: tagName: app-v__VERSION__ # the action\nautomatically replaces \\_\\_VERSION\\_\\_ with the app version releaseName: \"App\nv__VERSION__\" releaseBody: \"See the assets to download this version and\ninstall.\" releaseDraft: true prerelease: false ``` The workflow pulls the\nsecrets from GitHub and define them as environment variables before building the\napplication using the Tauri action. The output is a GitHub release with the\nsigned and notarized macOS application.","url":"https://tauri.studio/docs/distribution/sign-macos"},{"id":"prose_docs_distribution_sign_windows_md","title":"Windows - Code signing guide locally & with Github Actions","area":"distribution","section":"distribution","headings":["A","B","C","GitHub Secrets","Workflow Modifications"],"subHeadings":[],"code":[null],"text":"import Alert from '@theme/Alert' # Intro Code-signing will add a level of\nauthenticity to your application, while it is not required it can often improve\nthe user experience for your users. # Prerequisites - Windows - you can likely\nuse other platforms, but this tutorial is using Powershell native features. -\nCode signing certificate - you can aqquire one of these on services such as\nDigicert.com, Comodo.com, & Godaddy.com. In this guide we are using Comodo.com -\nA working tauri application # Getting Started There are a few things we will\nhave to do to get our windows installation prepared for code signing. This\nincludes converting our certificate to a speific format, installing this\ncertificate, & then decoding required information from certificate that is\nrequired by tauri. ## A. Convert your `.cer` to `.pfx` 1. You will need the\nfollowing: - certificate file (mine is `cert.cer`) - private key file (mine is\n`private-key.key`) 2. Open up a command prompt and change to your current\ndirectory using `cd Documents/Certs` 3. Convert your `.cer` to a `.pfx` using\n`openssl pkcs12 -export -in cert.cer -inkey private-key.key -out\ncertificate.pfx` 4. You will be prompted to enter an export password **DON'T\nFORGET IT!** ## B. Import your `.pfx` file into the keystore. We will now need\nto import our `.pfx` file. 1. Assign your export password to a variable using\n`$WINDOWS_PFX_PASSWORD = 'MYPASSWORD'` 2. Now Import the certificate using\n`Import-PfxCertificate -FilePath Certs/certificate.pfx -CertStoreLocation\nCert:\\CurrentUser\\My -Password (ConvertTo-SecureString -String\n$env:WINDOWS_PFX_PASSWORD -Force -AsPlainText)` ## C. Prepare Variables 1. We\nwill need the SHA-1 thumbprint of the certificate, you can get this using\n`openssl pkcs12 -info -in certificate.pfx` and look under for following ``` Bag\nAttributes localKeyID: A1 B1 A2 B2 A3 B3 A4 B4 A5 B5 A6 B6 A7 B7 A8 B8 A9 B9 A0\nB0 ``` 2. You will capture the `localKeyID` but with no spaces, in this example\nit would be `A1B1A2B2A3B3A4B4A5B5A6B6A7B7A8B8A9B9A0B0`. This is our\n`certificateThumbprint`. 3. We will need the SHA digest algorythm used for your\ncertificate (Hint: this is likely `sha256` 4. We will also need a timestamp url,\nthis is a time server used to verify the time of the certificate signing. Im\nusing `http://timestamp.comodoca.com` but whoever you got your certificate from\nlikely has one aswell. # Prepare `tauri.conf.json` file 1. Now that we have our\n`certificateThumbprint`, `digestAlgorithm`, & `timestampUrl` we will open up the\n`tauri.conf.json`. 2. In the `tauri.conf.json` you will look for the `tauri` ->\n`bundle` -> `windows` section. You will see there are three variable for the\ninformation we have captured. Fill it out like below. ``` \"windows\": {\n\"certificateThumbprint\": \"A1B1A2B2A3B3A4B4A5B5A6B6A7B7A8B8A9B9A0B0\",\n\"digestAlgorithm\": \"sha256\", \"timestampUrl\": \"http://timestamp.comodoca.com\" }\n``` 3. Save, and run `yarn | yarn build` 4. In the console output you will see\nthe following output. ``` info: signing app info: running signtool \"C:\\\\Program\nFiles (x86)\\\\Windows Kits\\\\10\\\\bin\\\\10.0.19041.0\\\\x64\\\\signtool.exe\" info: \"Done\nAdding Additional Store\\r\\nSuccessfully signed: APPLICATION FILE PATH HERE ```\nwhich shows you have successfully signed the `.exe`. And thats it! You have\nsuccessfully signed your .exe file. # BONUS: Sign your application with GitHub\nActions. We can also create a workflow to sign the application with GitHub\nactions, this will help automate your Publish time. ## GitHub Secrets We will\nneed to add a few GitHub secrets for the proper configuration of the GitHub\nAction. These can be named however you would like. - You can view\n[this](https://docs.github.com/en/actions/reference/encrypted-secrets) guide for\nhow to add GitHub secrets. The secrets we used are as follows | GitHub Secrets |\nValue for Variable | | :---: | :---: | |WINDOWS_CERTIFICATE| Base64 encoded\nversion of your .pfx certificate, can be done using this command `certutil\n-encode certificate.pfx base64cert.txt` |\n|WINDOWS_CERTIFICATE_PASSWORD|Certificate export password used on creation of\ncertificate .pfx| ## Workflow Modifications 1. We will need to add a step in the\nworkflow to properly import the certificate into the windows environment. This\nwork flow accomplishes the following 1. Assign GitHub secrets to environment\nvariables 2. Create a new `certificate` directory 3. Import\n`WINDOWS_CERTIFICATE` into tempCert.txt 4. Use `certutil` to decode the\ntempCert.txt from base64 into a `.pfx` file. 5. Remove tempCert.txt 6. Import\nthe `.pfx` file into the Cert store of Windows & convert the\n`WINDOWS_CERTIFICATE_PASSWORD` to a secure string to be used in the import\ncommand. 2. We will be using the tauri-action publish template available\n[here](https://github.com/tauri-apps/tauri-action) ``` name: \"publish\" on: push:\nbranches: - release jobs: publish-tauri: strategy: fail-fast: false matrix:\nplatform: [macos-latest, ubuntu-latest, windows-latest] runs-on: ${{\nmatrix.platform }} steps: - uses: actions/checkout@v2 - name: setup node uses:\nactions/setup-node@v1 with: node-version: 12 - name: install Rust stable uses:\nactions-rs/toolchain@v1 with: toolchain: stable - name: install webkit2gtk\n(ubuntu only) if: matrix.platform == 'ubuntu-latest' run: | sudo apt-get update\nsudo apt-get install -y webkit2gtk-4.0 - name: install app dependencies and\nbuild it run: yarn && yarn build - uses: tauri-apps/tauri-action@v0 env:\nGITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tagName: app-v__VERSION__ # the\naction automatically replaces \\_\\_VERSION\\_\\_ with the app version releaseName:\n\"App v__VERSION__\" releaseBody: \"See the assets to download this version and\ninstall.\" releaseDraft: true prerelease: false ``` 3. Right above `-name:\ninstall app dependencies and build it` you will want to add the following step\n``` - name: import windows certificate if: matrix.platform == 'windows-latest'\nenv: WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}\nWINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }} run: |\nNew-Item -ItemType directory -Path certificate Set-Content -Path\ncertificate/tempCert.txt -Value $env:WINDOWS_PFX certutil -decode\ncertificate/tempCert.txt certificate/certificate.pfx Remove-Item -path\ncertificate -include tempCert.txt Import-PfxCertificate -FilePath\ncertificate/certificate.pfx -CertStoreLocation Cert:\\CurrentUser\\My -Password\n(ConvertTo-SecureString -String $env:WINDOWS_PFX_PASSWORD -Force -AsPlainText)\n``` 4. Save, and push to your repo. 5. You workflow will now be able to import\nyour windows certificate and import it into the github runner, allowing for\nautomated code-signing!","url":"https://tauri.studio/docs/distribution/sign-windows"},{"id":"prose_docs_distribution_updater_md","title":"Updater","area":"distribution","section":"distribution","headings":["Update Requests","Built","Javascript API","Events","Update Server JSON Format","Update File JSON Format","macOS","Windows","Linux"],"subHeadings":["Initialize updater and check if a new version is available","Listen New Update Available","Emit Install and Download","Listen Install Progress"],"code":["js","json","none","bash"],"text":"# Configuration Once you have your Tauri project ready, you need to configure\nthe updater. Add this in tauri.conf.json ```json \"updater\": { \"active\": true,\n\"endpoints\": [ \"https://releases.myapp.com/{{target}}/{{current_version}}\" ],\n\"dialog\": true, \"pubkey\": \"\" } ``` The required keys are \"active\" and\n\"endpoints\", others are optional. \"active\" must be a boolean. By default, it's\nset to false. \"endpoints\" must be an array. The string `{{target}}` and\n`{{current_version}}` are automatically replaced in the URL allowing you\ndetermine [server-side](#update-server-json-format) if an update is available.\nIf multiple endpoints are specified, the updater will fallback if a server is\nnot responding within the pre-defined timeout. \"dialog\" if present must be a\nboolean. By default, it's set to true. If enabled, [events](#events) are\nturned-off as the updater will handle everything. If you need the custom events,\nyou MUST turn off the built-in dialog. \"pubkey\" if present must be a valid\npublic-key generated with Tauri cli. See [Signing updates](#signing-updates). ##\nUpdate Requests Tauri is indifferent to the request the client application\nprovides for update checking. `Accept: application/json` is added to the request\nheaders because Tauri is responsible for parsing the response. For the\nrequirements imposed on the responses and the body format of an update, response\nsee [Server Support](#server-support). Your update request must *at least*\ninclude a version identifier so that the server can determine whether an update\nfor this specific version is required. It may also include other identifying\ncriteria such as operating system version, to allow the server to deliver as\nfine-grained an update as you would like. How you include the version identifier\nor other criteria is specific to the server that you are requesting updates\nfrom. A common approach is to use query parameters,\n[Configuration](#configuration) shows an example of this. ## Built-in dialog By\ndefault, updater uses a built-in dialog API from Tauri. ![New\nUpdate](https://i.imgur.com/UMilB5A.png) The dialog release notes is represented\nby the update `note` provided by the [server](#server-support). If the user\naccepts, the download and install are initialized. The user will be then\nprompted to restart the application. ## Javascript API **Attention, you need to\n_disable built-in dialog_ in your [tauri configuration](#configuration),\notherwise, events aren't emitted and the javascript API will NOT work.** ```js\nimport { checkUpdate, installUpdate } from \"@tauri-apps/api/updater\"; import {\nrelaunch } from \"@tauri-apps/api/process\"; try { const {shouldUpdate, manifest}\n= await checkUpdate(); if (shouldUpdate) { // display dialog await\ninstallUpdate(); // install complete, restart app await relaunch(); } }\ncatch(error) { console.log(error); } ``` ## Events **Attention, you need to\n_disable built-in dialog_ in your [tauri configuration](#configuration),\notherwise, events aren't emitted.** To know when an update is ready to be\ninstalled, you can subscribe to these events: ### Initialize updater and check\nif a new version is available #### If a new version is available, the event\n`tauri://update-available` is emitted. Event: `tauri://update` ### Rust ```rust\nwindow.emit(\"tauri://update\".to_string(), None); ``` ### Javascript ```js import\n{ emit } from \"@tauri-apps/api/event\"; emit(\"tauri://update\"); ``` ### Listen\nNew Update Available Event: `tauri://update-available` Emitted data: ```none\nversion Version announced by the server date Date announced by the server body\nNote announced by the server ``` ### Rust ```rust\nwindow.listen(\"tauri://update-available\".to_string(), move |msg| { println!(\"New\nversion available: {:?}\", msg); }) ``` ### Javascript ```js import { listen }\nfrom \"@tauri-apps/api/event\"; listen(\"tauri://update-available\", function (res)\n{ console.log(\"New version available: \", res); }); ``` ### Emit Install and\nDownload You need to emit this event to initialize the download and listen to\nthe [install progress](#listen-install-progress). Event:\n`tauri://update-install` ### Rust ```rust\nwindow.emit(\"tauri://update-install\".to_string(), None); ``` ### Javascript\n```js import { emit } from \"@tauri-apps/api/event\";\nemit(\"tauri://update-install\"); ``` ### Listen Install Progress Event:\n`tauri://update-status` Emitted data: ```none status [ERROR/PENDING/DONE] error\nString/null ``` PENDING is emitted when the download is started and DONE when\nthe install is complete. You can then ask to restart the application. ERROR is\nemitted when there is an error with the updater. We suggest to listen to this\nevent even if the dialog is enabled. ### Rust ```rust\nwindow.listen(\"tauri://update-status\".to_string(), move |msg| { println!(\"New\nstatus: {:?}\", msg); }) ``` ### Javascript ```js import { listen } from\n\"@tauri-apps/api/event\"; listen(\"tauri://update-status\", function (res) {\nconsole.log(\"New status: \", res); }); ``` # Server Support Your server should\ndetermine whether an update is required based on the [Update\nRequest](#update-requests) your client issues. If an update is required your\nserver should respond with a status code of [200\nOK](http://tools.ietf.org/html/rfc2616#section-10.2.1) and include the [update\nJSON](#update-server-json-format) in the body. To save redundantly downloading\nthe same version multiple times your server must not inform the client to\nupdate. If no update is required your server must respond with a status code of\n[204 No Content](http://tools.ietf.org/html/rfc2616#section-10.2.5). ## Update\nServer JSON Format When an update is available, Tauri expects the following\nschema in response to the update request provided: ```json { \"url\":\n\"https://mycompany.example.com/myapp/releases/myrelease.tar.gz\", \"version\":\n\"0.0.1\", \"notes\": \"Theses are some release notes\", \"pub_date\":\n\"2020-09-18T12:29:53+01:00\", \"signature\": \"\" } ``` The only required keys are\n\"url\" and \"version\", the others are optional. \"pub_date\" if present must be\nformatted according to ISO 8601. \"signature\" if present must be a valid\nsignature generated with Tauri cli. See [Signing updates](#signing-updates). ##\nUpdate File JSON Format The alternate update technique uses a plain JSON file\nmeaning you can store your update metadata on S3, gist, or another static file\nstore. Tauri will check against the name/version field and if the version is\nsmaller than the current one and the platform is available, the update will be\ntriggered. The format of this file is detailed below: ```json { \"name\":\"v1.0.0\",\n\"notes\":\"Test version\", \"pub_date\":\"2020-06-22T19:25:57Z\", \"platforms\": {\n\"darwin\": { \"signature\":\"\",\n\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.app.tar.gz\"\n}, \"linux\": { \"signature\":\"\",\n\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.AppImage.tar.gz\"\n}, \"win64\": { \"signature\":\"\",\n\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.x64.msi.zip\"\n} } } ``` # Bundler (Artifacts) The Tauri bundler will automatically generate\nupdate artifacts if the updater is enabled in `tauri.conf.json` If the bundler\ncan locate your private and pubkey, your update artifacts will be automatically\nsigned. The signature can be found in the `sig` file. The signature can be\nuploaded to GitHub safely or made public as long as your private key is secure.\nYou can see how it's [bundled with the\nCI](https://github.com/tauri-apps/tauri/blob/5b6c7bb6ee3661f5a42917ce04a89d94f905c949/.github/workflows/artifacts-updater.yml#L44)\nand a [sample\ntauri.conf.json](https://github.com/tauri-apps/tauri/blob/5b6c7bb6ee3661f5a42917ce04a89d94f905c949/examples/updater/src-tauri/tauri.conf.json#L52)\n## macOS On MACOS we create a .tar.gz from the whole application. (.app) ```none\ntarget/release/bundle └── osx └── app.app └── app.app.tar.gz (update bundle) └──\napp.app.tar.gz.sig (if signature enabled) ``` ## Windows On Windows we create a\n.zip from the MSI, when downloaded and validated, we run the MSI install.\n```none target/release └── app.x64.msi └── app.x64.msi.zip (update bundle) └──\napp.x64.msi.zip.sig (if signature enabled) ``` ## Linux On Linux, we create a\n.tar.gz from the AppImage. ```none target/release/bundle └── appimage └──\napp.AppImage └── app.AppImage.tar.gz (update bundle) └── app.AppImage.tar.gz.sig\n(if signature enabled) ``` # Signing updates We offer a built-in signature to\nensure your update is safe to be installed. To sign your updates, you need two\nthings. The *Public-key* (pubkey) should be added inside your `tauri.conf.json`\nto validate the update archive before installing. The *Private key* (privkey) is\nused to sign your update and should NEVER be shared with anyone. Also, if you\nlost this key, you'll NOT be able to publish a new update to the current user\nbase (if pubkey is set in tauri.conf.json). It's important to save it at a safe\nplace and you can always access it. To generate your keys you need to use the\nTauri cli. ```bash tauri sign -g -w ~/.tauri/myapp.key ``` You have multiple\noptions available ```bash Tauri updates signer. USAGE: tauri sign [FLAGS]\n[OPTIONS] FLAGS: --force Overwrite private key even if it exists on the\nspecified path -g, --generate Generate keypair to sign files -h, --help Prints\nhelp information --no-password Set empty password for your private key -V,\n--version Prints version information OPTIONS: -p, --password Set private key\npassword when signing -k, --private-key Load the private key from a string -f,\n--private-key-path Load the private key from a file --sign-file Sign the\nspecified file -w, --write-keys Write private key to a file ``` *** Environment\nvariables used to sign with the Tauri `bundler`: If they are set, and\n`tauri.conf.json` expose the public key, the bundler will automatically generate\nand sign the updater artifacts. `TAURI_PRIVATE_KEY` Path or String of your\nprivate key `TAURI_KEY_PASSWORD` Your private key password (optional)","url":"https://tauri.studio/docs/distribution/updater"},{"id":"prose_docs_getting_started_beginning_tutorial_md","title":"Your First Tauri App","area":"getting-started","section":"getting-started","headings":["Vue CLI Plugin Tauri"],"subHeadings":["1","1","2","3","Recipes"],"code":["bash","sh",null],"text":"import Alert from '@theme/Alert' import Command from '@theme/Command' import\nLink from '@docusaurus/Link' :::caution You must have completed all the steps\nrequired for setting up the development environment on your machine. If you\nhaven't done this yet, please see the [setup page for your operating\nsystem](/docs/getting-started/prerequisites). ::: There are two ways to\nintegrate with Tauri depends on your need: - [Start a new Tauri\nproject](#1-start-a-new-tauri-project) - Or [add Tauri to existing\nproject](#1-add-tauri-to-existing-project) ### 1. Start a New Tauri Project\n```bash yarn create tauri-app #OR npx create-tauri-app ``` Just follow the\ninstructions and choose the web frontend framework you prefer.\n`create-tauri-app` will create a template project depends on your inputs. You\ncan go straight to [check `tauri\ninfo`](#3-check-tauri-info-to-make-sure-everything-is-set-up-properly) after\nthis. ### 1. Add Tauri to Existing Project: The Tauri CLI tool helps you build\nyour project, so install it at first. You can install Tauri CLI [using\n`Node.js`](#install-tauri-cli-package-as-a-dev-dependency) or [using\n`Rust`](#alternatively-install-tauri-cli-as-a-cargo-subcommand) #### Install\nTauri CLI package as a dev dependency: ```bash cd project-folder # Not required\nif you already have a package.json: # yarn init # OR # npm init yarn add -D\n@tauri-apps/cli # OR npm install -D @tauri-apps/cli ``` :::note You can install\nTauri as both a local and a global dependency, but we recommend installing it\nlocally. ::: If you decide to use Tauri as a local package with npm (not yarn),\nyou will have to define a custom script to your package.json: ```js\ntitle=package.json { // This content is just a sample \"scripts\": { \"tauri\":\n\"tauri\" } } ``` #### Alternatively, install Tauri CLI as a cargo subcommand:\nThis will install `tauri-cli` as a Cargo subcommand on the cargo binary folder\n(by default on `$HOME/.cargo/bin`): ```bash cargo install tauri-cli --locked\n--version ^1.0.0-rc ``` For more installation options, see [`cargo\ninstall`](https://doc.rust-lang.org/cargo/commands/cargo-install.html#description)\n#### Install Tauri API Package as a Dependency (optional): The `@tauri-apps/api`\npackage is recommended for projects using ES modules or modern build tools such\nas Webpack or Vite. It is the most secure way to access the Tauri APIs. ```bash\nyarn add @tauri-apps/api # OR npm install @tauri-apps/api ``` ### 2. Initialize\nTauri in Your App This command will place a new folder in your current working\ndirectory, `src-tauri`. ```sh └── src-tauri ├── .gitignore ├── Cargo.toml ├──\nrustfmt.toml ├── tauri.conf.json ├── icons │ ├── 128x128.png │ ├──\n128x128@2x.png │ ├── 32x32.png │ ├── Square107x107Logo.png │ ├──\nSquare142x142Logo.png │ ├── Square150x150Logo.png │ ├── Square284x284Logo.png │\n├── Square30x30Logo.png │ ├── Square310x310Logo.png │ ├── Square44x44Logo.png │\n├── Square71x71Logo.png │ ├── Square89x89Logo.png │ ├── StoreLogo.png │ ├──\nicon.icns │ ├── icon.ico │ └── icon.png └── src ├── build.rs ├── cmd.rs └──\nmain.rs ``` ### 3. Check `tauri info` to Make Sure Everything Is Set up\nProperly: Which should return something like: ``` Operating System -\nDarwin(16.7.0) - darwin/x64 Node.js environment Node.js - 12.16.3\n@tauri-apps/cli - 1.0.0-rc.0 @tauri-apps/api - 1.0.0-rc.0 Global packages npm -\n6.14.15 pnpm - Not installed yarn - 1.22.17 Rust environment rustup - 1.24.3\nrustc - 1.58.1 cargo - 1.58.0 toolchain - stable-x86_64-unknown-linux-gnu App\ndirectory structure /node_modules /src-tauri /src /public App tauri.rs -\n1.0.0-rc.0 build-type - bundle CSP - default-src 'self' distDir - ../public\ndevPath - ../public framework - Svelte bundler - Rollup ``` This information can\nbe very helpful when triaging problems. ### Recipes We've also defined prebuilt\nconfigurations called \"Recipes\". They may help you to customize Tauri to fit\nyour needs. [See more about recipes](../architecture/recipes/about-recipes.md).\n## Vue CLI Plugin Tauri If you are using Vue CLI, it is recommended to use the\nofficial [CLI plugin](https://github.com/tauri-apps/vue-cli-plugin-tauri).","url":"https://tauri.studio/docs/getting-started/beginning-tutorial"},{"id":"prose_docs_getting_started_prerequisites_md","title":"Prerequisites","area":"getting-started","section":"getting-started","headings":[],"subHeadings":[],"code":[],"text":"import OSList from '@theme/OSList' - Rust - Node (optional) - OS specific build\ntooling, eg. `build-essential`, `xcode-select` or `C++ build tools` For more\ninformation on platform-specific build tooling, see these guides to get started.\nAfter that, you'll be ready to [make your first Tauri\napp](/docs/getting-started/beginning-tutorial)!","url":"https://tauri.studio/docs/getting-started/prerequisites"},{"id":"prose_docs_getting_started_setting_up_linux_md","title":"Setting Up Linux","area":"getting-started","section":"getting-started","headings":["1","2","3","4","Continue"],"subHeadings":["Optional dependencies","Node","Optional Node","WSL Version 1","WSL Version 2"],"code":["sh","bash"],"text":"import Alert from '@theme/Alert' import Icon from '@theme/Icon' import { Intro }\nfrom '@theme/SetupDocs' import Tabs from '@theme/Tabs'; import TabItem from\n'@theme/TabItem'; ## 1. System Dependencies  ```sh $ sudo apt update && sudo apt\ninstall libwebkit2gtk-4.0-dev \\ build-essential \\ curl \\ wget \\ libssl-dev \\\nlibgtk-3-dev \\ libappindicator3-dev \\ patchelf \\ librsvg2-dev ``` ```sh $ sudo\npacman -Syu && sudo pacman -S --needed \\ webkit2gtk \\ base-devel \\ curl \\ wget \\\nopenssl \\ appmenu-gtk-module \\ gtk3 \\ libappindicator-gtk3 \\ patchelf \\ librsvg\n\\ libvips ``` ```sh $ sudo dnf check-update && sudo dnf install\nwebkit2gtk3-devel.x86_64 \\ openssl-devel \\ curl \\ wget \\ libappindicator-gtk3 \\\npatchelf \\ librsvg2-devel \\ && sudo dnf group install \"C Development Tools and\nLibraries\" ``` ### Optional dependencies: - `libappindicator`: needed to use the\nsystem tray feature. - `patchelf` and `librsvg`: needed to bundle `AppImage`. ##\n2. Node.js Runtime and Package Manager  ### Node.js (npm included) We recommend\nusing nvm to manage your Node.js runtime. It allows you to easily switch\nversions and update Node.js. ```sh $ curl -o-\nhttps://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash ``` We\nhave audited this bash script, and it does what it says it is supposed to do.\nNevertheless, before blindly curl-bashing a script, it is always wise to look at\nit first. Here is the file as a mere download link\n[https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh]. Once nvm is\ninstalled, close and reopen your terminal, then install the latest version of\nNode.js and npm: ```sh $ nvm install node --latest-npm $ nvm use node ``` If you\nhave any problems with nvm, please consult their project readme\n[https://github.com/nvm-sh/nvm]. ### Optional Node.js Package Manager You may\nwant to use an alternative to npm: - Yarn [https://yarnpkg.com/getting-started],\nis preferred by Tauri's team - pnpm [https://pnpm.js.org/en/installation] ## 3.\nRustc and Cargo Package Manager  The following command will install rustup\n[https://rustup.rs/], the official installer for Rust\n[https://www.rust-lang.org/]. ```bash $ curl --proto '=https' --tlsv1.2 -sSf\nhttps://sh.rustup.rs | sh ``` We have audited this bash script, and it does what\nit says it is supposed to do. Nevertheless, before blindly curl-bashing a\nscript, it is always wise to look at it first. Here is the file as a mere\ndownload link [https://sh.rustup.rs]. To make sure that Rust has been installed\nsuccessfully, run the following command: ```sh $ rustc --version latest update\non 2019-12-19, rust version 1.40.0 ``` You may need to restart your terminal if\nthe command does not work. ## 4. For Windows Subsystem for Linux (WSL) Users  In\norder to run a graphical application with WSL, you need to download **one** of\nthese X servers: Xming, Cygwin X, and vcXsrv. Since vcXsrv has been used\ninternally, it's the one we recommend to install. ### WSL Version 1 Open the X\nserver and then run `export DISPLAY=:0` in the terminal. You should now be able\nto run any graphical application via the terminal. ### WSL Version 2 You'll need\nto run a command that is slightly more complex than WSL 1: `export DISPLAY=$(cat\n/etc/resolv.conf | grep nameserver | awk '{print $2}'):0` and you need to add\n`-ac` to the X server as an argument. Note: if for some reason this command\ndoesn't work you can use an alternative command such as: `export DISPLAY=$(cat\n/etc/resolv.conf | grep nameserver | sed 's/.* //g'):0` or you can manually find\nthe Address using `cat /etc/resolve.conf | grep nameserver`. Don't forget that\nyou'll have to use the \"export\" command anytime you want to use a graphical\napplication, for each newly opened terminal. You can download some examples to\ntry with `sudo apt-get install x11-apps`. xeyes is always a good one. It can be\nhandy when troubleshooting WSL issues. ## Continue Now that you have set up the\nLinux-specific dependencies for Tauri, learn how to [add Tauri to your\nproject](/docs/getting-started/beginning-tutorial).","url":"https://tauri.studio/docs/getting-started/setting-up-linux"},{"id":"prose_docs_getting_started_setting_up_macos_md","title":"Setting Up macOS","area":"getting-started","section":"getting-started","headings":["1","2","3","Continue"],"subHeadings":["Node","Optional Node"],"code":["sh",null],"text":"import Alert from '@theme/Alert' import { Intro } from '@theme/SetupDocs' import\nIcon from '@theme/Icon' ## 1. System Dependencies  Make sure `xcode` is\ninstalled. ```sh $ xcode-select --install ``` ## 2. Node.js Runtime and Package\nManager  ### Node.js (npm included) We recommend using nvm to manage your\nNode.js runtime. It allows you to easily switch versions and update Node.js.\n```sh $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh\n| bash ``` We have audited this bash script, and it does what it says it is\nsupposed to do. Nevertheless, before blindly curl-bashing a script, it is always\nwise to look at it first. Here is the file as a mere download link\n[https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh]. Once nvm is\ninstalled, close and reopen your terminal, then install the latest version of\nNode.js and npm: ```sh $ nvm install node --latest-npm $ nvm use node ``` If you\nhave any problems with nvm, please consult their project readme\n[https://github.com/nvm-sh/nvm]. ### Optional Node.js Package Manager You may\nwant to use an alternative to npm: - Yarn [https://yarnpkg.com/getting-started],\nis preferred by Tauri's team - pnpm [https://pnpm.js.org/en/installation] ## 3.\nRustc and Cargo Package Manager  The following command will install rustup\n[https://rustup.rs/], the official installer for Rust\n[https://www.rust-lang.org/]. ``` $ curl --proto '=https' --tlsv1.2 -sSf\nhttps://sh.rustup.rs | sh ``` We have audited this bash script, and it does what\nit says it is supposed to do. Nevertheless, before blindly curl-bashing a\nscript, it is always wise to look at it first. Here is the file as a mere\ndownload link [https://sh.rustup.rs]. To make sure that Rust has been installed\nsuccessfully, run the following command: ```sh $ rustc --version latest update\non 2019-12-19, rust version 1.40.0 ``` You may need to restart your terminal if\nthe command does not work. ## Continue Now that you have set up the\nmacOS-specific dependencies for Tauri, learn how to [add Tauri to your\nproject](/docs/getting-started/beginning-tutorial).","url":"https://tauri.studio/docs/getting-started/setting-up-macos"},{"id":"prose_docs_getting_started_setting_up_windows_md","title":"Setting Up Windows","area":"getting-started","section":"getting-started","headings":["1","2","3","4","Continue"],"subHeadings":["Node","Optional Node"],"code":["powershell"],"text":"import Alert from '@theme/Alert' import Icon from '@theme/Icon' import { Intro }\nfrom '@theme/SetupDocs' :::note For those using the Windows Subsystem for Linux\n(WSL) please refer to our [Linux specific\ninstructions](/docs/getting-started/setting-up-linux) instead. ::: ## 1. System\nDependencies  You'll need to install Microsoft Visual Studio C++ build tools.\nDownload the installer here\n[https://visualstudio.microsoft.com/visual-cpp-build-tools/], and then run it.\nWhen it asks you what packages you would like to install, select C++ Build Tools\nand make sure the Windows SDK is selected. This is a big download (over 1GB) and\ntakes the most time, so go grab a coffee. You may need to uninstall the 2017\nversion of the build tools if you have them. There are reports of Tauri not\nworking with both the 2017 and 2019 versions installed. ## 2. Node.js Runtime\nand Package Manager  ### Node.js (npm included) We recommend using nvm-windows\n[https://github.com/coreybutler/nvm-windows#installation--upgrades] to manage\nyour Node.js runtime. It allows you to easily switch versions and update\nNode.js. Then run the following from an Administrative PowerShell and press Y\nwhen prompted: ```powershell # BE SURE YOU ARE IN AN ADMINISTRATIVE PowerShell!\nnvm install latest nvm use {{latest}} # Replace with your latest downloaded\nversion ``` This will install the most recent version of Node.js with npm. ###\nOptional Node.js Package Manager You may want to use an alternative to npm: -\nYarn [https://yarnpkg.com/getting-started], is preferred by Tauri's team - pnpm\n[https://pnpm.js.org/en/installation] ## 3. Rustc and Cargo Package Manager  Now\nyou will need to install Rust [https://www.rust-lang.org/]. The easiest way to\ndo this is to use rustup [https://rustup.rs/], the official installer. - 64-bit\ndownload link [https://win.rustup.rs/x86_64] - 32-bit download link\n[https://win.rustup.rs/i686] Download and install the proper variant for your\ncomputer's architecture. ## 4. Install WebView2 WebView2 is pre-installed in\nWindows 11. Finally, you will need to install WebView2. The best way to do this\nis to download and run the Evergreen Bootstrapper from [this\npage](https://developer.microsoft.com/en-us/microsoft-edge/webview2/#download-section).\nIf you have problems of any kind after following these instructions, we\nrecommend that you reboot your computer before developing a Tauri project to\nensure that everything works as expected. ## Continue Now that you have set up\nthe Windows-specific dependencies for Tauri, learn how to [add Tauri to your\nproject](/docs/getting-started/beginning-tutorial).","url":"https://tauri.studio/docs/getting-started/setting-up-windows"},{"id":"prose_docs_guides_cli_md","title":"Making Your Own CLI","area":"guides","section":"guides","headings":["Base Configuration","Adding Arguments","Subcommands","Reading the matches","Complete documentation"],"subHeadings":["Positional Arguments","Named Arguments","Flag Arguments","Rust","JavaScript"],"code":["rust","js"],"text":"import Alert from '@theme/Alert' Tauri enables your app to have a CLI through\nclap [https://github.com/clap-rs/clap], a robust command line argument parser.\nWith a simple CLI definition in your `tauri.conf.json` file, you can define your\ninterface and read its argument matches map on JavaScript and/or Rust. ## Base\nConfiguration Under `tauri.conf.json`, you have the following structure to\nconfigure the interface: ```js title=src-tauri/tauri.conf.json { \"tauri\": {\n\"cli\": { \"description\": \"\", // command description that's shown on help\n\"longDescription\": \"\", // command long description that's shown on help\n\"beforeHelp\": \"\", // content to show before the help text \"afterHelp\": \"\", //\ncontent to show after the help text \"args\": [], // list of arguments of the\ncommand, we'll explain it later \"subcommands\": { \"subcommand-name\": { //\nconfigures a subcommand that is accessible // with `$ ./app subcommand-name\n--arg1 --arg2 --etc` // configuration as above, with \"description\", \"args\", etc.\n} } } } } ``` All JSON configurations here are just samples, many other fields\nhave been omitted for the sake of clarity. ## Adding Arguments The `args` array\nrepresents the list of arguments accepted by its command or subcommand. You can\nfind more details about the way to configure them here [/docs/api/config#tauri].\n### Positional Arguments A positional argument is identified by its position in\nthe list of arguments. With the following configuration: ```json\ntitle=src-tauri/tauri.conf.json:tauri.cli { \"args\": [ { \"name\": \"source\",\n\"index\": 1, \"takesValue\": true }, { \"name\": \"destination\", \"index\": 2,\n\"takesValue\": true } ] } ``` Users can run your app as `$ ./app tauri.txt\ndest.txt` and the arg matches map will define `source` as `\"tauri.txt\"` and\n`destination` as `\"dest.txt\"`. ### Named Arguments A named argument is a (key,\nvalue) pair where the key identifies the value. With the following\nconfiguration: ```json title=src-tauri/tauri.conf.json:tauri.cli { \"args\": [ {\n\"name\": \"type\", \"short\": \"t\", \"takesValue\": true, \"multiple\": true,\n\"possibleValues\": [\"foo\", \"bar\"] } ] } ``` Users can run your app as `$ ./app\n--type foo bar`, `$ ./app -t foo -t bar` or `$ ./app --type=foo,bar` and the arg\nmatches map will define `type` as `[\"foo\", \"bar\"]`. ### Flag Arguments A flag\nargument is a standalone key whose presence or absence provides information to\nyour application. With the following configuration: ```js\ntitle=src-tauri/tauri.conf.json:tauri.cli { \"args\": [ \"name\": \"verbose\",\n\"short\": \"v\", \"multipleOccurrences\": true ] } ``` Users can run your app as `$\n./app -v -v -v`, `$ ./app --verbose --verbose --verbose` or `$ ./app -vvv` and\nthe arg matches map will define `verbose` as `true`, with `occurrences = 3`. ##\nSubcommands Some CLI applications has additional interfaces as subcommands. For\ninstance, the `git` CLI has `git branch`, `git commit` and `git push`. You can\ndefine additional nested interfaces with the `subcommands` array: ```js\ntitle=src-tauri/tauri.conf.json:tauri { \"cli\": { ... \"subcommands\": { \"branch\":\n{ \"args\": [] }, \"push\": { \"args\": [] } } } } ``` Its configuration is the same\nas the root application configuration, with the `description`,\n`longDescription`, `args`, etc. ## Reading the matches ### Rust ```rust use\ntauri::api::cli::get_matches; fn main() { let context =\ntauri::generate_context!(); let cli_config =\ncontext.config().tauri.cli.clone().unwrap(); match get_matches(&cli_config) { //\n`matches` here is a Struct with { args, subcommand }. // `args` is `HashMap`\nwhere `ArgData` is a struct with { value, occurances }. // `subcommand` is\n`Option>` where `SubcommandMatches` is a struct with { name, matches }.\nOk(matches) => { println!(\"{:?}\", matches) } Err(_) => {} };\ntauri::Builder::default() .run(context) .expect(\"error while running tauri\napplication\"); } ``` ### JavaScript ```js import { getMatches } from\n'@tauri-apps/api/cli' getMatches().then((matches) => { // do something with the\n{ args, subcommand } matches }) ``` ## Complete documentation You can find more\nabout the CLI configuration here [/docs/api/config#tauri].","url":"https://tauri.studio/docs/guides/cli"},{"id":"prose_docs_guides_command_md","title":"Creating Rust Commands","area":"guides","section":"guides","headings":["Basic Example","Passing Arguments","Returning Data","Error Handling","Async Commands","Accessing the Window in Commands","Accessing an AppHandle in Commands","Accessing managed state","Creating Multiple Commands","Complete Example"],"subHeadings":[],"code":["rust","js"],"text":"import Alert from '@theme/Alert' Tauri provides a simple yet powerful \"command\"\nsystem for calling Rust functions from your web app. Commands can accept\narguments and return values. They can also return errors and be `async`. ##\nBasic Example Commands are defined in your `src-tauri/src/main.rs` file. To\ncreate a command, just add a function and annotate it with `#[tauri::command]`:\n```rust #[tauri::command] fn my_custom_command() { println!(\"I was invoked from\nJS!\"); } ``` You will have to provide a list of your commands to the builder\nfunction like so: ```rust // Also in main.rs fn main() {\ntauri::Builder::default() // This is where you pass in your commands\n.invoke_handler(tauri::generate_handler![my_custom_command])\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ``` Now, you\ncan invoke the command from your JS code: ```js // With the Tauri API npm\npackage: import { invoke } from '@tauri-apps/api/tauri' // With the Tauri global\nscript, enabled when `tauri.conf.json > build > withGlobalTauri` is set to true:\nconst invoke = window.__TAURI__.invoke // Invoke the command\ninvoke('my_custom_command') ``` ## Passing Arguments Your command handlers can\ntake arguments: ```rust #[tauri::command] fn my_custom_command(invoke_message:\nString) { println!(\"I was invoked from JS, with this message: {}\",\ninvoke_message); } ``` Arguments should be passed as a JSON object with\ncamelCase keys: ```js invoke('my_custom_command', { invokeMessage: 'Hello!' })\n``` Arguments can be of any type, as long as they implement\n[serde::Deserialize](https://serde.rs/derive.html). ## Returning Data Command\nhandlers can return data as well: ```rust #[tauri::command] fn\nmy_custom_command() -> String { \"Hello from Rust!\".into() } ``` The `invoke`\nfunction returns a promise that resolves with the returned value: ```js\ninvoke('my_custom_command').then((message) => console.log(message)) ``` Returned\ndata can be of any type, as long as it implements\n[Serde::Serialize](https://serde.rs/derive.html). ## Error Handling If your\nhandler could fail and needs to be able to return an error, have the function\nreturn a `Result`: ```rust #[tauri::command] fn my_custom_command() -> Result {\n// If something fails Err(\"This failed!\".into()) // If it worked Ok(\"This\nworked!\".into()) } ``` If the command returns an error, the promise will reject,\notherwise it resolves: ```js invoke('my_custom_command') .then((message) =>\nconsole.log(message)) .catch((error) => console.error(error)) ``` ## Async\nCommands Async commands are executed on a separate thread using the async\nruntime [https://docs.rs/tauri/1.0.0-rc.0/tauri/async_runtime/fn.spawn.html].\nCommands without the async keyword are executed on the main thread, unless\ndefined with #[tauri::command(async)]. If your command needs to run\nasynchronously, simply declare it as `async`: ```rust #[tauri::command] async fn\nmy_custom_command() { // Call another async function and wait for it to finish\nlet result = some_async_function().await; println!(\"Result: {}\", result); } ```\nSince invoking the command from JS already returns a promise, it works just like\nany other command: ```js invoke('my_custom_command').then(() =>\nconsole.log('Completed!')) ``` ## Accessing the Window in Commands Commands can\naccess the `Window` instance that invoked the message: ```rust #[tauri::command]\nasync fn my_custom_command(window: tauri::Window) { println!(\"Window: {}\",\nwindow.label()); } ``` ## Accessing an AppHandle in Commands Commands can access\nan `AppHandle` instance: ```rust #[tauri::command] async fn\nmy_custom_command(app_handle: tauri::AppHandle) { let app_dir =\napp_handle.path_resolver().app_dir(); use tauri::GlobalShortcutManager;\napp_handle.global_shortcut_manager().register(\"CTRL + U\", move || {}); } ``` ##\nAccessing managed state Tauri can manage state using the `manage` function on\n`tauri::Builder`. The state can be accessed on a command using `tauri::State`:\n```rust struct MyState(String); #[tauri::command] fn my_custom_command(state:\ntauri::State) { assert_eq!(state.0 == \"some state value\", true); } fn main() {\ntauri::Builder::default() .manage(MyState(\"some state value\".into()))\n.invoke_handler(tauri::generate_handler![my_custom_command])\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ## Creating Multiple Commands The\n`tauri::generate_handler!` macro takes an array of commands. To register\nmultiple commands, you cannot call invoke_handler multiple times. Only the last\ncall will be used. You must pass each command to a single call of\n`tauri::generate_handler!`. ```rust #[tauri::command] fn cmd_a() -> String {\n\"Command a\" } #[tauri::command] fn cmd_b() -> String { \"Command b\" } fn main() {\ntauri::Builder::default() .invoke_handler(tauri::generate_handler![cmd_a,\ncmd_b]) .run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ## Complete Example Any or all of the above features can be\ncombined: ```rust title=main.rs // Definition in main.rs struct Database;\n#[derive(serde::Serialize)] struct CustomResponse { message: String, other_val:\nusize, } async fn some_other_function() -> Option { Some(\"response\".into()) }\n#[tauri::command] async fn my_custom_command( window: tauri::Window, number:\nusize, database: tauri::State<'_, Database>, ) -> Result { println!(\"Called from\n{}\", window.label()); let result: Option = some_other_function().await; if let\nSome(message) = result { Ok(CustomResponse { message, other_val: 42 + number, })\n} else { Err(\"No result\".into()) } } fn main() { tauri::Builder::default()\n.manage(Database {})\n.invoke_handler(tauri::generate_handler![my_custom_command])\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ```js // Invocation from JS invoke('my_custom_command', {\nnumber: 42, }) .then((res) => console.log(`Message: ${res.message}, Other Val:\n${res.other_val}`) ) .catch((e) => console.error(e)) ```","url":"https://tauri.studio/docs/guides/command"},{"id":"prose_docs_guides_events_md","title":"Events","area":"guides","section":"guides","headings":["Frontend","Backend"],"subHeadings":["Global events","Window","Global events","Window"],"code":["ts","rust"],"text":"The Tauri event system is a multi-producer multi-consumer communication\nprimitive that allows message passing between the frontend and the backend. It\nis analogous to the command system, but payload type check must be written on\nthe event handler and it simplifies communication from the backend to the\nfrontend, working like a channel. A Tauri application can listen and emit to\nglobal and window-specific events. Usage from the frontend and the backend are\ndescribed below. ## Frontend The event system is accessible on the frontend on\nthe `event` and `window` modules of the `@tauri-apps/api` package. ### Global\nevents To use the global event channel, import the `event` module and use the\n`emit` and `listen` functions: ```ts import { emit, listen } from\n'@tauri-apps/api/event' // listen to the `click` event and get a function to\nremove the event listener // there's also a `once` function that subscribes to\nan event and automatically unsubscribes the listener on the first event const\nunlisten = await listen('click', event => { // event.event is the event name\n(useful if you want to use a single callback fn for multiple event types) //\nevent.payload is the payload object }) // emits the `click` event with the\nobject payload emit('click', { theMessage: 'Tauri is awesome!' }) ``` ###\nWindow-specific events Window-specific events are exposed on the `window`\nmodule. ```ts import { appWindow, WebviewWindow } from '@tauri-apps/api/window'\n// emit an event that are only visible to the current window\nappWindow.emit('event', { message: 'Tauri is awesome!' }) // create a new\nwebview window and emit an event only to that window const webview = new\nWebviewWindow('window') webview.emit('event') ``` ## Backend On the backend, the\nglobal event channel is exposed on the `App` struct, and window-specific events\ncan be emitted using the `Window` trait. ### Global events ```rust use\ntauri::Manager; // the payload type must implement `Serialize`. // for global\nevents, it also must implement `Clone`. #[derive(Clone, serde::Serialize)]\nstruct Payload { message: String, } fn main() { tauri::Builder::default()\n.setup(|app| { // listen to the `event-name` (emitted on any window) let id =\napp.listen_global(\"event-name\", |event| { println!(\"got event-name with payload\n{:?}\", event.payload()); }); // unlisten to the event using the `id` returned on\nthe `listen_global` function // an `once_global` API is also exposed on the\n`App` struct app.unlisten(id); // emit the `event-name` event to all webview\nwindows on the frontend app.emit_all(\"event-name\", Payload { message: \"Tauri is\nawesome!\".into() }).unwrap(); Ok(()) }) .run(tauri::generate_context!())\n.expect(\"failed to run app\"); } ``` ### Window-specific events To use the\nwindow-specific event channel, a `Window` object can be obtained on a command\nhandler or with the `get_window` function: ```rust use tauri::{Manager, Window};\n// the payload type must implement `Serialize`. #[derive(serde::Serialize)]\nstruct Payload { message: String, } // init a background process on the command,\nand emit periodic events only to the window that used the command\n#[tauri::command] fn init_process(window: Window) { std::thread::spawn(move || {\nloop { window.emit(\"event-name\", Payload { message: \"Tauri is awesome!\".into()\n}).unwrap(); } }); } fn main() { tauri::Builder::default() .setup(|app| { //\n`main` here is the window label; it is defined on the window creation or under\n`tauri.conf.json` // the default value is `main`. note that it must be unique\nlet main_window = app.get_window(\"main\").unwrap(); // listen to the `event-name`\n(emitted on the `main` window) let id = main_window.listen(\"event-name\", |event|\n{ println!(\"got window event-name with payload {:?}\", event.payload()); }); //\nunlisten to the event using the `id` returned on the `listen` function // an\n`once` API is also exposed on the `Window` struct main_window.unlisten(id); //\nemit the `event-name` event to the `main` window main_window.emit(\"event-name\",\nPayload { message: \"Tauri is awesome!\".into() }).unwrap(); Ok(()) })\n.invoke_handler(tauri::generate_handler![init_process])\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ```","url":"https://tauri.studio/docs/guides/events"},{"id":"prose_docs_guides_icons_md","title":"Icons","area":"guides","section":"guides","headings":[],"subHeadings":[],"code":["sh","json"],"text":"import Command from '@theme/Command' import Alert from '@theme/Alert' Tauri\nships with a default iconset based on its logo. This is probably NOT what you\nwant when you ship your application. To remedy this common situation, Tauri\nprovides the `icon` command that will take an input file (\"./app-icon.png\" by\ndefault) and create all the icons needed for the various platforms: ```sh\nOptions --help, -h Displays this message --log, l Logging [boolean] --icon, i\nSource icon (png, 1240x1240 with transparency) --target, t Target folder\n(default: 'src-tauri/icons') --compression, c Compression type\n[pngquant|optipng|zopfli] ``` These will be placed in your `src-tauri/icons`\nfolder where they will automatically be included in your built app. If you need\nto source your icons from some other location, you can edit this part of the\n`src-tauri/tauri.conf.json` file: ```json { \"tauri\": { \"bundle\": { \"icon\": [\n\"icons/32x32.png\", \"icons/128x128.png\", \"icons/128x128@2x.png\",\n\"icons/icon.icns\", \"icons/icon.ico\" ] } } } ``` - icon.icns = macOS - icon.ico =\nMS Windows - \\*.png = Linux","url":"https://tauri.studio/docs/guides/icons"},{"id":"prose_docs_guides_menu_md","title":"Window Menu","area":"guides","section":"guides","headings":[],"subHeadings":["Creating a menu","Adding the menu to all windows","Adding the menu to a specific window","Listening to events on custom menu items","Updating menu items"],"code":["rust"],"text":"Native application menus can be attached to a window. ### Creating a menu To\ncreate a native window menu, import the `Menu`, `Submenu`, `MenuItem` and\n`CustomMenuItem` types. The `MenuItem` enum contains a collection of\nplatform-specific items (currently not implemented on Windows). The\n`CustomMenuItem` allows you to create your own menu items and add special\nfunctionality to them. ```rust use tauri::{CustomMenuItem, Menu, MenuItem,\nSubmenu}; ``` Create a `Menu` instance: ```rust // here `\"quit\".to_string()`\ndefines the menu item id, and the second parameter is the menu item label. let\nquit = CustomMenuItem::new(\"quit\".to_string(), \"Quit\"); let close =\nCustomMenuItem::new(\"close\".to_string(), \"Close\"); let submenu =\nSubmenu::new(\"File\", Menu::new().add_item(quit).add_item(close)); let menu =\nMenu::new() .add_native_item(MenuItem::Copy)\n.add_item(CustomMenuItem::new(\"hide\", \"Hide\")) .add_submenu(submenu); ``` ###\nAdding the menu to all windows The defined menu can be set to all windows using\nthe `menu` API on the `tauri::Builder` struct: ```rust use\ntauri::{CustomMenuItem, Menu, MenuItem, Submenu}; fn main() { let menu =\nMenu::new(); // configure the menu tauri::Builder::default() .menu(menu)\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Adding the menu to a specific window You can create a\nwindow and set the menu to be used. This allows defining a specific menu set for\neach application window. ```rust use tauri::{CustomMenuItem, Menu, MenuItem,\nSubmenu}; use tauri::WindowBuilder; fn main() { let menu = Menu::new(); //\nconfigure the menu tauri::Builder::default() .create_window(\n\"main-window\".to_string(), tauri::WindowUrl::App(\"index.html\".into()), move\n|window_builder, webview_attributes| { (window_builder.menu(menu),\nwebview_attributes) }, ) .run(tauri::generate_context!()) .expect(\"error while\nrunning tauri application\"); } ``` ### Listening to events on custom menu items\nEach `CustomMenuItem` triggers an event when clicked. Use the `on_menu_event`\nAPI to handle them, either on the global `tauri::Builder` or on an specific\nwindow. #### Listening to events on global menus ```rust use\ntauri::{CustomMenuItem, Menu, MenuItem}; fn main() { let menu = vec![]; //\ninsert the menu array here tauri::Builder::default() .menu(menu)\n.on_menu_event(|event| { match event.menu_item_id() { \"quit\" => {\nstd::process::exit(0); } \"close\" => { event.window().close().unwrap(); } _ => {}\n} }) .run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` #### Listening to events on window menus ```rust use\ntauri::{CustomMenuItem, Menu, MenuItem}; use tauri::{Manager, WindowBuilder}; fn\nmain() { let menu = vec![]; // insert the menu array here\ntauri::Builder::default() .create_window( \"main-window\".to_string(),\ntauri::WindowUrl::App(\"index.html\".into()), move |window_builder,\nwebview_attributes| { (window_builder.menu(menu), webview_attributes) }, )\n.setup(|app| { let window = app.get_window(\"main-window\").unwrap(); let window_\n= window.clone(); window.on_menu_event(move |event| { match\nevent.menu_item_id().as_str() { \"quit\" => { std::process::exit(0); } \"close\" =>\n{ window_.close().unwrap(); } _ => {} } }); Ok(()) })\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Updating menu items The `Window` struct has a\n`menu_handle` method, which allows updating menu items: ```rust fn main() {\ntauri::Builder::default() .setup(|app| { let main_window =\napp.get_window(\"main\").unwrap(); let menu_handle = main_window.menu_handle();\nstd::thread::spawn(move || { // you can also `set_selected`, `set_enabled` and\n`set_native_image` (macOS only). menu_handle.get_item(\"item_id\").set_title(\"New\ntitle\"); }) Ok(()) }) } ```","url":"https://tauri.studio/docs/guides/menu"},{"id":"prose_docs_guides_multiwindow_md","title":"Multiwindow","area":"guides","section":"guides","headings":[],"subHeadings":[],"code":[],"text":"Manage multiple windows on a single application.","url":"https://tauri.studio/docs/guides/multiwindow"},{"id":"prose_docs_guides_plugin_md","title":"Tauri Plugins","area":"guides","section":"guides","headings":["Using a Plugin","Writing a Plugin","Writing a Plugin"],"subHeadings":["API package","Conventions","Advanced"],"code":["rust","sh","ts"],"text":"Plugins allow you to hook into the Tauri application lifecycle and introduce new\ncommands. ## Using a Plugin To use a plugin, just pass the plugin instance to\nthe App's `plugin` method: ```rust fn main() { tauri::Builder::default()\n.plugin(my_awesome_plugin::init()) .run(tauri::generate_context!())\n.expect(\"failed to run app\"); } ``` ## Writing a Plugin Plugins are reusable\nextensions to the Tauri API that solve common problems. They are also a very\nconvenient way to structure your own code base! If you intend to share your\nplugin with others, we provide a ready-made template! With the tauri-cli\ninstalled just run: ```sh tauri plugin init --name awesome ``` ### API package\nBy default consumers of your plugin can call provided commands like this: ```ts\nimport { invoke } from '@tauri-apps/api' invoke('plugin:awesome|do_something')\n``` where `awesome` will be replaced by your plugin name. This isn't very\nconvenient however, so it's common for plugins to provide a so called _API\npackage_, a JavaScript package that provides convenient access to your commands.\n> An example of this is the\n[tauri-plugin-store](https://github.com/tauri-apps/tauri-plugin-store), that\nprovides a convenient class structure to accessing a store. > You can scaffold a\nplugin with attached API package like this: ```sh tauri plugin init --name\nawesome --api ``` ## Writing a Plugin Using the `tauri::plugin::Builder` you can\ndefine plugins similar to how you define your app: ```rust use\ntauri::plugin::{Builder, TauriPlugin}; // the plugin custom command handlers if\nyou choose to extend the API. #[tauri::command] // this will be accessible with\n`invoke('plugin:awesome|initialize')`. // where `awesome` is the plugin name. fn\ninitialize() {} #[tauri::command] // this will be accessible with\n`invoke('plugin:awesome|do_something')`. fn do_something() {} pub fn init() ->\nTauriPlugin { Builder::new(\"awesome\")\n.invoke_handler(tauri::generate_handler![initialize, do_something]) .build() }\n``` Plugins can setup and maintain state, just like your app can: ```rust use\ntauri::{ AppHandle, Runtime, State plugin::{Builder, TauriPlugin} };\n#[derive(Default)] struct MyState { } #[tauri::command] // this will be\naccessible with `invoke('plugin:awesome|do_something')`. fn do_something(_app:\nAppHandle, state: State<'_, MyState>) { // you can access `MyState` here! }\nBuilder::new(\"awesome\") .invoke_handler(tauri::generate_handler![initialize,\ndo_something]) .setup(|app_handle| { // setup plugin specific state here\napp.manage(MyState::default()) Ok(()) }) .build() ``` ### Conventions - The\ncrate exports an `init` method to create the plugin. - Plugins should have a\nclear name with `tauri-plugin-` prefix. - Include `tauri-plugin` keyword in\n`Cargo.toml`/`package.json`. - Document your plugin in English. - Add an example\napp showcasing your plugin. ### Advanced Instead of relying on the\n`tauri::plugin::TauriPlugin` struct returned by `tauri::plugin::Builder::build`,\nyou can implement the `tauri::plugin::Plugin` yourself. This allows you to have\nfull control over the associated data. Note that each function on the `Plugin`\ntrait is optional, except the `name` function. ```rust use\ntauri::{plugin::{Plugin, Result as PluginResult}, Runtime, PageLoadPayload,\nWindow, Invoke, AppHandle}; struct MyAwesomePlugin { invoke_handler: Box) + Send\n+ Sync>, // plugin state, configuration fields } // the plugin custom command\nhandlers if you choose to extend the API. #[tauri::command] // this will be\naccessible with `invoke('plugin:awesome|initialize')`. // where `awesome` is the\nplugin name. fn initialize() {} #[tauri::command] // this will be accessible\nwith `invoke('plugin:awesome|do_something')`. fn do_something() {} impl\nMyAwesomePlugin { // you can add configuration fields here, // see\nhttps://doc.rust-lang.org/1.0.0/style/ownership/builders.html pub fn new() ->\nSelf { Self { invoke_handler: Box::new(tauri::generate_handler![initialize,\ndo_something]), } } } impl Plugin for MyAwesomePlugin { /// The plugin name.\nMust be defined and used on the `invoke` calls. fn name(&self) -> &'static str {\n\"awesome\" } /// The JS script to evaluate on initialization. /// Useful when\nyour plugin is accessible through `window` /// or needs to perform a JS task on\napp initialization /// e.g. \"window.awesomePlugin = { ... the plugin interface\n}\" fn initialization_script(&self) -> Option { None } /// initialize plugin with\nthe config provided on `tauri.conf.json > plugins > $yourPluginName` or the\ndefault value. fn initialize(&mut self, app: &AppHandle, config:\nserde_json::Value) -> PluginResult<()> { Ok(()) } /// Callback invoked when the\nWindow is created. fn created(&mut self, window: Window) {} /// Callback invoked\nwhen the webview performs a navigation. fn on_page_load(&mut self, window:\nWindow, payload: PageLoadPayload) {} /// Extend the invoke handler. fn\nextend_api(&mut self, message: Invoke) { (self.invoke_handler)(message) } } ```","url":"https://tauri.studio/docs/guides/plugin"},{"id":"prose_docs_guides_splashscreen_md","title":"Splashscreen","area":"guides","section":"guides","headings":[],"subHeadings":["Setup","Waiting for Webpage","Waiting for Rust"],"code":["diff",null],"text":"import Link from '@docusaurus/Link' If your webpage could take some time to\nload, or if you need to run an initialization procedure in Rust before\ndisplaying your main window, a splashscreen could improve the loading experience\nfor the user. ### Setup First, create a `splashscreen.html` in your `distDir`\nthat contains the HTML code for a splashscreen. Then, update your\n`tauri.conf.json` like so: ```diff \"windows\": [ { \"title\": \"Tauri App\", \"width\":\n800, \"height\": 600, \"resizable\": true, \"fullscreen\": false, + \"visible\": false\n// Hide the main window by default }, // Add the splashscreen window + { +\n\"width\": 400, + \"height\": 200, + \"decorations\": false, + \"url\":\n\"splashscreen.html\", + \"label\": \"splashscreen\" + } ] ``` Now, your main window\nwill be hidden and the splashscreen window will show when your app is launched.\nNext, you'll need a way to close the splashscreen and show the main window when\nyour app is ready. How you do this depends on what you are waiting for before\nclosing the splashscreen. ### Waiting for Webpage If you are waiting for your\nweb code, you'll want to create a `close_splashscreen` [command](command.md).\n```rust title=src-tauri/main.rs use tauri::Manager; // Create the command:\n#[tauri::command] fn close_splashscreen(window: tauri::Window) { // Close\nsplashscreen if let Some(splashscreen) = window.get_window(\"splashscreen\") {\nsplashscreen.close().unwrap(); } // Show main window\nwindow.get_window(\"main\").unwrap().show().unwrap(); } // Register the command:\nfn main() { tauri::Builder::default() // Add this line\n.invoke_handler(tauri::generate_handler![close_splashscreen])\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ``` Then, you\ncan call it from your JS: ```js // With the Tauri API npm package: import {\ninvoke } from '@tauri-apps/api/tauri' // With the Tauri global script: const\ninvoke = window.__TAURI__.invoke document.addEventListener('DOMContentLoaded',\n() => { // This will wait for the window to load, but you could // run this\nfunction on whatever trigger you want invoke('close_splashscreen') }) ``` ###\nWaiting for Rust If you are waiting for Rust code to run, put it in the `setup`\nfunction handler so you have access to the `App` instance: ```rust\ntitle=src-tauri/main.rs use tauri::Manager; fn main() {\ntauri::Builder::default() .setup(|app| { let splashscreen_window =\napp.get_window(\"splashscreen\").unwrap(); let main_window =\napp.get_window(\"main\").unwrap(); // we perform the initialization code on a new\ntask so the app doesn't freeze tauri::async_runtime::spawn(async move { //\ninitialize your app here instead of sleeping :) println!(\"Initializing...\");\nstd::thread::sleep(std::time::Duration::from_secs(2)); println!(\"Done\ninitializing.\"); // After it's done, close the splashscreen and display the main\nwindow splashscreen_window.close().unwrap(); main_window.show().unwrap(); });\nOk(()) }) .run(tauri::generate_context!()) .expect(\"failed to run app\"); } ```","url":"https://tauri.studio/docs/guides/splashscreen"},{"id":"prose_docs_guides_system_tray_md","title":"System Tray","area":"guides","section":"guides","headings":[],"subHeadings":["Setup","Creating a system tray","Configuring a system tray context menu","Configure the app system tray","Listening to system tray events","Updating system tray"],"code":["json","rust"],"text":"Native application system tray. ### Setup Configure the `systemTray` object on\n`tauri.conf.json`: ```json { \"tauri\": { \"systemTray\": { \"iconPath\":\n\"icons/icon.png\", \"iconAsTemplate\": true } } } ``` The `iconPath` is pointed to\na PNG file on macOS and Linux, and a `.ico` file must exist for Windows support.\nThe `iconAsTemplate` is a boolean value that determines whether the image\nrepresents a\n[template](https://developer.apple.com/documentation/appkit/nsimage/1520017-template?language=objc)\nimage on macOS. ### Creating a system tray To create a native system tray,\nimport the `SystemTray` type: ```rust use tauri::SystemTray; ``` Initialize a\nnew tray instance: ```rust let tray = SystemTray::new(); ``` ### Configuring a\nsystem tray context menu Optionally you can add a context menu that is visible\nwhen the tray icon is right clicked. Import the `SystemTrayMenu`,\n`SystemTrayMenuItem` and `CustomMenuItem` types: ```rust use\ntauri::{CustomMenuItem, SystemTrayMenu, SystemTrayMenuItem}; ``` Create the\n`SystemTrayMenu`: ```rust // here `\"quit\".to_string()` defines the menu item id,\nand the second parameter is the menu item label. let quit =\nCustomMenuItem::new(\"quit\".to_string(), \"Quit\"); let hide =\nCustomMenuItem::new(\"hide\".to_string(), \"Hide\"); let tray_menu =\nSystemTrayMenu::new() .add_item(quit)\n.add_native_item(SystemTrayMenuItem::Separator) .add_item(hide); ``` Add the\ntray menu to the `SystemTray` instance: ```rust let tray =\nSystemTray::new().with_menu(tray_menu); ``` ### Configure the app system tray\nThe created `SystemTray` instance can be set using the `system_tray` API on the\n`tauri::Builder` struct: ```rust use tauri::{CustomMenuItem, SystemTray,\nSystemTrayMenu}; fn main() { let tray_menu = SystemTrayMenu::new(); // insert\nthe menu items here let system_tray = SystemTray::new() .with_menu(tray_menu);\ntauri::Builder::default() .system_tray(system_tray)\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Listening to system tray events Each `CustomMenuItem`\ntriggers an event when clicked. Also, Tauri emits tray icon click events. Use\nthe `on_system_tray_event` API to handle them: ```rust use\ntauri::{CustomMenuItem, SystemTray, SystemTrayMenu}; use tauri::Manager; fn\nmain() { let tray_menu = SystemTrayMenu::new(); // insert the menu items here\ntauri::Builder::default() .system_tray(SystemTray::new().with_menu(tray_menu))\n.on_system_tray_event(|app, event| match event { SystemTrayEvent::LeftClick {\nposition: _, size: _, .. } => { println!(\"system tray received a left click\"); }\nSystemTrayEvent::RightClick { position: _, size: _, .. } => { println!(\"system\ntray received a right click\"); } SystemTrayEvent::DoubleClick { position: _,\nsize: _, .. } => { println!(\"system tray received a double click\"); }\nSystemTrayEvent::MenuItemClick { id, .. } => { match id.as_str() { \"quit\" => {\nstd::process::exit(0); } \"hide\" => { let window =\napp.get_window(\"main\").unwrap(); window.hide().unwrap(); } _ => {} } } _ => {}\n}) .run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Updating system tray The `AppHandle` struct has a\n`tray_handle` method, which returns a handle to the system tray allowing\nupdating tray icon and context menu items: #### Updating context menu items\n```rust use tauri::{CustomMenuItem, SystemTray, SystemTrayMenu}; use\ntauri::Manager; fn main() { let tray_menu = SystemTrayMenu::new(); // insert the\nmenu items here tauri::Builder::default()\n.system_tray(SystemTray::new().with_menu(tray_menu)) .on_system_tray_event(|app,\nevent| match event { SystemTrayEvent::MenuItemClick { id, .. } => { // get a\nhandle to the clicked menu item // note that `tray_handle` can be called\nanywhere, // just get a `AppHandle` instance with `app.handle()` on the setup\nhook // and move it to another function or thread let item_handle =\napp.tray_handle().get_item(&id); match id.as_str() { \"hide\" => { let window =\napp.get_window(\"main\").unwrap(); window.hide().unwrap(); // you can also\n`set_selected`, `set_enabled` and `set_native_image` (macOS only).\nitem_handle.set_title(\"Show\").unwrap(); } _ => {} } } _ => {} })\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` #### Updating tray icon Note that `tauri::Icon` must be a\n`Path` variant on Linux, and `Raw` variant on Windows and macOS. ```rust\napp.tray_handle().set_icon(tauri::Icon::Raw(include_bytes!(\"../path/to/myicon.ico\"))).unwrap();\n```","url":"https://tauri.studio/docs/guides/system-tray"},{"id":"prose_docs_guides_window_customization_md","title":"Window Customization","area":"guides","section":"guides","headings":["Configuration","Creating a Custom Titlebar"],"subHeadings":["CSS","HTML","JS"],"code":["css","html","js"],"text":"` tag: ```html\nminimize [https://api.iconify.design/mdi:window-minimize.svg]\nmaximize [https://api.iconify.design/mdi:window-maximize.svg]\nclose [https://api.iconify.design/mdi:close.svg]\n``` Note that you may need to move the rest of your content down so that the\ntitlebar doesn't cover it. ### JS Finally, you'll need to make the buttons work:\n```js import { appWindow } from '@tauri-apps/api/window' document\n.getElementById('titlebar-minimize') .addEventListener('click', () =>\nappWindow.minimize()) document .getElementById('titlebar-maximize')\n.addEventListener('click', () => appWindow.toggleMaximize()) document\n.getElementById('titlebar-close') .addEventListener('click', () =>\nappWindow.close()) ```","url":"https://tauri.studio/docs/guides/window-customization"},{"id":"prose_docs_testing_webdriver_ci_md","title":"Continuous Integration","area":"testing","section":"webdriver","headings":[],"subHeadings":[],"code":["yaml"],"text":"Utilizing Linux and some programs to create a fake display, it is possible to\nrun [WebDriver] tests with [`tauri-driver`] on your CI. The following example\nwill use the [WebdriverIO] example we [previously built together] and GitHub\nActions. This means the following assumptions: 1. The Tauri application is in\nthe repository root and the binary builds when running `cargo build --release`.\n2. The [WebDriverIO] test runner is in the `webdriver/webdriverio` directory and\nruns when `yarn test` is used in that directory. The following is a commented\nGitHub Actions workflow file at `.github/workflows/webdriver.yml` ```yaml # run\nthis action when the repository is pushed to on: [ push ] # the name of our\nworkflow name: WebDriver jobs: # a single job named test test: # the display\nname the test job name: WebDriverIO Test Runner # we want to run on the latest\nlinux environment runs-on: ubuntu-latest # the steps our job runs **in order**\nsteps: # checkout the code on the workflow runner - uses: actions/checkout@v2 #\ninstall system dependencies that Tauri needs to compile on Linux. # note the\nextra dependencies for `tauri-driver` to run which are `webkit2gtk-driver` and\n`xvfb` - name: Tauri dependencies run: >- sudo apt-get update && sudo apt-get\ninstall -y libgtk-3-dev libgtksourceview-3.0-dev webkit2gtk-4.0\nlibappindicator3-dev webkit2gtk-driver xvfb # install the latest Rust stable -\nname: Rust stable uses: actions-rs/toolchain@v1 with: toolchain: stable # we run\nour rust tests before the webdriver tests to avoid testing a broken application\n- name: Cargo test uses: actions-rs/cargo@v1 with: command: test # build a\nrelease build of our application to be used during our WebdriverIO tests - name:\nCargo build uses: actions-rs/cargo@v1 with: command: build args: --release #\ninstall the latest stable node version at the time of writing - name: Node v16\nuses: actions/setup-node@v2 with: node-version: 16.x # install our Node.js\ndependencies with Yarn - name: Yarn install run: yarn install working-directory:\nwebdriver/webdriverio # install the latest version of `tauri-driver`. # note:\nthe tauri-driver version is independent of any other Tauri versions - name:\nInstall tauri-driver uses: actions-rs/cargo@v1 with: command: install args:\ntauri-driver # run the WebdriverIO test suite. # we run it through `xvfb-run`\n(the dependency we installed earlier) to have a fake # display server which\nallows our application to run headless without any changes to the code - name:\nWebdriverIO run: xvfb-run yarn test working-directory: webdriver/webdriverio ```\n[WebDriver]: https://www.w3.org/TR/webdriver/ [`tauri-driver`]:\nhttps://crates.io/crates/tauri-driver [WebdriverIO]: https://webdriver.io/\n[previously built together]: example/webdriverio","url":"https://tauri.studio/docs/testing/webdriver/ci"},{"id":"prose_docs_testing_webdriver_introduction_md","title":"Introduction","area":"testing","section":"webdriver","headings":["System Dependencies","Example Application"],"subHeadings":["Linux","Windows"],"code":["sh"],"text":"import Alert from '@theme/Alert' Webdriver support for Tauri is still in\npre-alpha. Tooling that is dedicated to it such as [tauri-driver] is still in\nactive development and may change as necessary over time. Additionally, only\nWindows and Linux are currently supported. [WebDriver] is a standardized\ninterface to interact with web documents that is primarily intended for\nautomated testing. Tauri supports the [WebDriver] interface by leveraging the\nnative platform's [WebDriver] server underneath a cross-platform wrapper\n[`tauri-driver`]. ## System Dependencies Install the latest [`tauri-driver`] or\nupdate an existing installation by running: ```sh cargo install tauri-driver ```\nBecause we currently utilize the platform's native [WebDriver] server, there are\nsome requirements for running [`tauri-driver`] on supported platforms. Platform\nsupport is currently limited to Linux and Windows. ### Linux We use\n`WebKitWebDriver` on linux platforms. Check if this binary exists already\n(command `which WebKitWebDriver`) as some distributions bundle it with the\nregular webkit package. Other platforms may have a separate package for them\nsuch as `webkit2gtk-driver` on Debian based distributions. ### Windows Make sure\nto grab the version of [Microsoft Edge Driver] that matches your Windows' Edge\nversion that the application is being built and tested on. On up-to-date Window\ninstalls, this should almost always be the latest stable version. If the two\nversions do not match, you may experience your WebDriver testing suite hanging\nwhile trying to connect. The download contains a binary called\n`msedgedriver.exe`. [`tauri-driver`] looks for that binary in the `$PATH` so\nmake sure it's either available on the path or use the `--native-driver` option\non [`tauri-driver`]. On Windows CI machines, you may want to download this\nautomatically as part of the CI setup process to ensure the Edge and Edge Driver\nversions stay in sync. A guide on how to do this may be added at a later date.\n## Example Application The [next section](example/setup) of the guide will show\nstep-by-step how to create a minimal example application that is tested with\nWebDriver. If you prefer to just see the result of the guide and look over a\nfinished minimal codebase that utilizes it then you can look at\nhttps://github.com/chippers/hello_tauri. That example also comes with a CI\nscript to test with GitHub actions, but you may still be interested in the\n[WebDriver CI](ci) guide as it explains the concept a bit more. [WebDriver]:\nhttps://www.w3.org/TR/webdriver/ [`tauri-driver`]:\nhttps://crates.io/crates/tauri-driver [tauri-driver]:\nhttps://crates.io/crates/tauri-driver [Microsoft Edge Driver]:\nhttps://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/","url":"https://tauri.studio/docs/testing/webdriver/introduction"},{"id":"prose_docs_testing_webdriver_example_selenium_md","title":"Selenium","area":"testing","parentSection":"webdriver","section":"example","headings":["Create a Directory for the Tests","Initializing a Selenium Project","Testing","Running the Test Suite"],"subHeadings":[],"code":["sh",null,"text"],"text":"import Alert from '@theme/Alert' import Tabs from '@theme/Tabs' import TabItem\nfrom '@theme/TabItem' This [Selenium] guide expects you to have already gone\nthrough the [example Application setup] in order to follow step-by-step. The\ngeneral information may still be useful otherwise. This WebDriver testing\nexample will use [Selenium] and a popular Node.js testing suite. It is expected\nto already have Node.js installed, along with `npm` or `yarn` although the\n[finished example project] uses `yarn`. ## Create a Directory for the Tests\nLet's start off by creating a space in our project to write these tests. We are\ngoing to be using a nested directory for this example project as we will later\nalso go over other frameworks, but typically you will only need to use one.\nCreate the directory we will use with `mkdir -p webdriver/selenium`. The rest of\nthis guide will assume you are inside the `webdriver/selenium` directory. ##\nInitializing a Selenium Project We will be using a pre-existing `package.json`\nto bootstrap this test suite because we have already chosen specific\ndependencies to use and want to showcase a simple working solution. The bottom\nof this section has a collapsed guide on how to set it up from scratch.\n`package.json`: ```json { \"name\": \"selenium\", \"version\": \"1.0.0\", \"private\":\ntrue, \"scripts\": { \"test\": \"mocha\" }, \"dependencies\": { \"chai\": \"^4.3.4\",\n\"mocha\": \"^9.0.3\", \"selenium-webdriver\": \"^4.0.0-beta.4\" } } ``` We have a\nscript which runs [Mocha] as a test framework exposed as the `test` command. We\nalso have various dependencies that we will be using to run the tests. [Mocha]\nas the testing framework, [Chai] as the assertion library, and\n[`selenium-webdriver`] which is the Node.js [Selenium] package. Click me if you\nwant to see how to set a project up from scratch If you wanted to install the\ndependencies from scratch, just run the following command. ```sh npm install\nmocha chai selenium-webdriver ``` ```sh yarn add mocha chai selenium-webdriver\n``` I suggest also adding a `\"test\": \"mocha\"` item in the `package.json`\n`\"scripts\"` key so that running mocha can be called simply with ```sh npm test\n``` ```sh yarn test ``` ## Testing Unlike the [WebdriverIO Test\nSuite](webdriverio#config), Selenium does not come out of the box with a Test\nSuite and leaves it up to the developer to build those out. We chose [Mocha]\nwhich is pretty neutral, and not related to WebDrivers at all, so our script\nwill need to do a bit of work to set up everything for us in the right order.\n[Mocha] expects a testing file at `test/test.js` by default, so let's create\nthat file now. `test/test.js`: ```js const os = require(\"os\"); const path =\nrequire(\"path\"); const { expect } = require(\"chai\"); const { spawn, spawnSync }\n= require(\"child_process\"); const { Builder, By, Capabilities } =\nrequire(\"selenium-webdriver\"); // create the path to the expected application\nbinary const application = path.resolve( __dirname, \"..\", \"..\", \"..\", \"target\",\n\"release\", \"hello-tauri-webdriver\" ); // keep track of the webdriver instance we\ncreate let driver; // keep track of the tauri-driver process we start let\ntauriDriver; before(async function() { // set timeout to 2 minutes to allow the\nprogram to build if it needs to this.timeout(120000) // ensure the program has\nbeen built spawnSync(\"cargo\", [\"build\", \"--release\"]); // start tauri-driver\ntauriDriver = spawn( path.resolve(os.homedir(), \".cargo\", \"bin\",\n\"tauri-driver\"), [], { stdio: [null, process.stdout, process.stderr] } ); const\ncapabilities = new Capabilities(); capabilities.set(\"tauri:options\", {\napplication }); capabilities.setBrowserName(\"wry\"); // start the webdriver\nclient driver = await new Builder() .withCapabilities(capabilities)\n.usingServer(\"http://localhost:4444/\") .build(); }); after(async function() { //\nstop the webdriver session await driver.quit(); // kill the tauri-driver process\ntauriDriver.kill(); }); describe(\"Hello Tauri\", () => { it(\"should be cordial\",\nasync () => { const text = await driver.findElement(By.css(\"body >\nh1\")).getText(); expect(text).to.match(/^[hH]ello/); }); it(\"should be excited\",\nasync () => { const text = await driver.findElement(By.css(\"body >\nh1\")).getText(); expect(text).to.match(/!$/); }); it(\"should be easy on the\neyes\", async () => { // selenium returns color css values as rgb(r, g, b) const\ntext = await driver.findElement(By.css(\"body\")).getCssValue(\"background-color\");\nconst rgb = text.match(/^rgb\\((?\\d+), (?\\d+), (?\\d+)\\)$/).groups;\nexpect(rgb).to.have.all.keys('r','g','b'); const luma = 0.2126 * rgb.r + 0.7152\n* rgb.g + 0.0722 * rgb.b ; expect(luma).to.be.lessThan(100) }); }); ``` If you\nare familiar with JS testing frameworks, `describe`, `it`, and `expect` should\nlook familiar. We also have semi-complex `before()` and `after()` callbacks to\nsetup and teardown mocha. Lines that are not the tests themselves have comments\nexplaining what the setup and teardown code is doing. If you were familiar with\nthe Spec file from the [WebdriverIO example](webdriverio#spec), you will notice\na lot more code that isn't tests, as we have to set up a few more WebDriver\nrelated items. ## Running the Test Suite Now that we are all set up with our\ndependencies and our test script, lets run it! ```sh npm test ``` ```sh yarn\ntest ``` We should see output the following output: ```text ➜ selenium\ngit:(main) ✗ yarn test yarn run v1.22.11 $ mocha Hello Tauri ✔ should be cordial\n(120ms) ✔ should be excited ✔ should be easy on the eyes 3 passing (588ms) Done\nin 0.93s. ``` We can see that our `Hello Tauri` sweet we created with `decribe`\nhad all 3 items we created with `it` pass their tests! With [Selenium] and some\nhooking up to a test suite, we just enabled e2e testing without modifying our\nTauri application at all! [Selenium]: https://selenium.dev/ [finished example\nproject]: https://github.com/chippers/hello_tauri [example Application setup]:\nsetup [Mocha]: https://mochajs.org/ [Chai]: https://www.chaijs.com/\n[`selenium-webdriver`]: https://www.npmjs.com/package/selenium-webdriver","url":"https://tauri.studio/docs/testing/webdriver/example/selenium"},{"id":"prose_docs_testing_webdriver_example_setup_md","title":"Setup Example","area":"testing","parentSection":"webdriver","section":"example","headings":["Initializing a Cargo Project","Creating a Minimal Frontend","Adding Tauri to the Cargo Project","Tauri Configuration","Running the Example Application"],"subHeadings":[],"code":["html","toml","rust","json"],"text":"HELLO, TAURI!","url":"https://tauri.studio/docs/testing/webdriver/example/setup"},{"id":"prose_docs_testing_webdriver_example_webdriverio_md","title":"WebdriverIO","area":"testing","parentSection":"webdriver","section":"example","headings":["Create a Directory for the Tests","Initializing a WebdriverIO Project","Config","Spec","Running the Test Suite"],"subHeadings":[],"code":["sh","text"],"text":"import Alert from '@theme/Alert' import Tabs from '@theme/Tabs' import TabItem\nfrom '@theme/TabItem' This [WebdriverIO] guide expects you to have already gone\nthrough the [example Application setup] in order to follow step-by-step. The\ngeneral information may still be useful otherwise. This WebDriver testing\nexample will use [WebdriverIO] and its testing suite. It is expected to already\nhave Node.js installed, along with `npm` or `yarn` although the [finished\nexample project] uses `yarn`. ## Create a Directory for the Tests Let's start\noff by creating a space in our project to write these tests. We are going to be\nusing a nested directory for this example project as we will later also go over\nother frameworks, but typically you will only need to use one. Create the\ndirectory we will use with `mkdir -p webdriver/webdriverio`. The rest of this\nguide will assume you are inside the `webdriver/webdriverio` directory. ##\nInitializing a WebdriverIO Project We will be using a pre-existing\n`package.json` to bootstrap this test suite because we have already chosen\nspecific [WebdriverIO] config options and want to showcase a simple working\nsolution. The bottom of this section has a collapsed guide on how to set it up\nfrom scratch. `package.json`: ```json { \"name\": \"webdriverio\", \"version\":\n\"1.0.0\", \"private\": true, \"scripts\": { \"test\": \"wdio run wdio.conf.js\" },\n\"dependencies\": { \"@wdio/cli\": \"^7.9.1\" }, \"devDependencies\": {\n\"@wdio/local-runner\": \"^7.9.1\", \"@wdio/mocha-framework\": \"^7.9.1\",\n\"@wdio/spec-reporter\": \"^7.9.0\" } } ``` We have a script which runs a\n[WebdriverIO] config as a test suite exposed as the `test` command. We also have\nvarious dependencies that were added by the `@wdio/cli` command when we first\nset it up. In short, these dependencies are for the most simple setup using a\nlocal WebDriver runner, [Mocha] as the test framework, and a simple Spec\nReporter. Click me if you want to see how to set a project up from scratch The\nCLI is interactive, and you may choose the tools to work with yourself. Note\nthat you will likely diverge from the rest of the guide, and need to set up the\ndifferences yourself. Let's add the [WebdriverIO] CLI to this npm project. ```sh\nnpm install @wdio/cli ``` ```sh yarn add @wdio/cli ``` To then run the\ninteractive config command to set up a [WebdriverIO] test suite, you can then\nrun: ```sh npx wdio config ``` ```sh yarn wdio config ``` ## Config You may have\nnoticed that the `test` script in our `package.json` mentions a file\n`wdio.conf.js`. That's the [WebdriverIO] config file which controls most aspects\nof our testing suite. `wdio.conf.js`: ```js const os = require(\"os\"); const path\n= require(\"path\"); const { spawn, spawnSync } = require(\"child_process\"); //\nkeep track of the `tauri-driver` child process let tauriDriver; exports.config =\n{ specs: [\"./test/specs/**/*.js\"], maxInstances: 1, capabilities: [ {\nmaxInstances: 1, \"tauri:options\": { application:\n\"../../target/release/hello-tauri-webdriver\", }, }, ], reporters: [\"spec\"],\nframework: \"mocha\", mochaOpts: { ui: \"bdd\", timeout: 60000, }, // ensure the\nrust project is built since we expect this binary to exist for the webdriver\nsessions onPrepare: () => spawnSync(\"cargo\", [\"build\", \"--release\"]), // ensure\nwe are running `tauri-driver` before the session starts so that we can proxy the\nwebdriver requests beforeSession: () => (tauriDriver = spawn(\npath.resolve(os.homedir(), \".cargo\", \"bin\", \"tauri-driver\"), [], { stdio: [null,\nprocess.stdout, process.stderr] } )), // clean up the `tauri-driver` process we\nspawned at the start of the session afterSession: () => tauriDriver.kill(), };\n``` If you are interested in the properties on `exports.config` object, then I\n[suggest reading the documentation] for it. For non-WDIO specific items, there\nare comments explaining why we are running commands in `onPrepare`,\n`beforeSession`, and `afterSession`. We also have our specs set to\n`\"./test/specs/**/*.js\"`, so let's create a spec now. ## Spec A spec contains\nthe code that is testing your actual application. The test runner will load\nthese specs and automatically run them as it sees fit. Let's create our spec now\nin the directory we specified. `test/specs/example.e2e.js`: ```js // calculates\nthe luma from a hex color `#abcdef` function luma(hex) { if\n(hex.startsWith(\"#\")) { hex = hex.substring(1); } const rgb = parseInt(hex, 16);\nconst r = (rgb >> 16) & 0xff; const g = (rgb >> 8) & 0xff; const b = (rgb >> 0)\n& 0xff; return 0.2126 * r + 0.7152 * g + 0.0722 * b; } describe(\"Hello Tauri\",\n() => { it(\"should be cordial\", async () => { const header = await $(\"body >\nh1\"); const text = await header.getText(); expect(text).toMatch(/^[hH]ello/);\n}); it(\"should be excited\", async () => { const header = await $(\"body > h1\");\nconst text = await header.getText(); expect(text).toMatch(/!$/); }); it(\"should\nbe easy on the eyes\", async () => { const body = await $(\"body\"); const\nbackgroundColor = await body.getCSSProperty(\"background-color\");\nexpect(luma(backgroundColor.parsed.hex)).toBeLessThan(100); }); }); ``` The\n`luma` function on top is just a helper function for one of our tests and is not\nrelated to the actual testing of the application. If you are familiar with other\ntesting frameworks, you may notice similar functions being exposed that are used\nsuch as `describe`, `it`, and `expect`. The other APIs, such as items like `$`\nand the methods it exposes is covered by the [WebdriverIO API\ndocs](https://webdriver.io/docs/api). ## Running the Test Suite Now that we are\nall set up with a config and a spec, let's run it! ```sh npm test ``` ```sh yarn\ntest ``` We should see output the following output: ```text ➜ webdriverio\ngit:(main) ✗ yarn test yarn run v1.22.11 $ wdio run wdio.conf.js Execution of 1\nworkers started at 2021-08-17T08:06:10.279Z [0-0] RUNNING in undefined -\n/test/specs/example.e2e.js [0-0] PASSED in undefined -\n/test/specs/example.e2e.js \"spec\" Reporter:\n------------------------------------------------------------------ [wry 0.12.1\nlinux #0-0] Running: wry (v0.12.1) on linux [wry 0.12.1 linux #0-0] Session ID:\n81e0107b-4d38-4eed-9b10-ee80ca47bb83 [wry 0.12.1 linux #0-0] [wry 0.12.1 linux\n#0-0] » /test/specs/example.e2e.js [wry 0.12.1 linux #0-0] Hello Tauri [wry\n0.12.1 linux #0-0] ✓ should be cordial [wry 0.12.1 linux #0-0] ✓ should be\nexcited [wry 0.12.1 linux #0-0] ✓ should be easy on the eyes [wry 0.12.1 linux\n#0-0] [wry 0.12.1 linux #0-0] 3 passing (244ms) Spec Files: 1 passed, 1 total\n(100% completed) in 00:00:01 Done in 1.98s. ``` We see the Spec Reporter tell us\nthat all 3 tests from the `test/specs/example.e2e.js` file, along with the final\nreport `Spec Files: 1 passed, 1 total (100% completed) in 00:00:01`. Using the\n[WebdriverIO] test suite, we just easily enabled e2e testing for our Tauri\napplication from just a few lines of configuration and a single command to run\nit! Even better, we didn't have to modify the application at all. [WebdriverIO]:\nhttps://webdriver.io/ [finished example project]:\nhttps://github.com/chippers/hello_tauri [example Application setup]: setup\n[Mocha]: https://mochajs.org/ [suggest reading the documentation]:\nhttps://webdriver.io/docs/configurationfile","url":"https://tauri.studio/docs/testing/webdriver/example/webdriverio"}]