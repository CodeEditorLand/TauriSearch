[{"id":"prose_docs_architecture_md","title":"The Tauri Architecture","headings":["What does the Release flow look like"],"subHeadings":[],"code":[null],"text":"# The Tauri Architecture ## Introduction Tauri is a polyglot and generic toolkit\nthat is very composable and allows engineers to make a wide variety of\napplications. It is used for building applications for Desktop Computers using a\ncombination of Rust tools and HTML rendered in a Webview. Apps built with Tauri\ncan ship with any number of pieces of an optional JS API / Rust API so that\nwebviews can control the system via message passing. In fact, developers can\nextend the default API with their own functionality and bridge the Webview and\nRust-based backend easily. Tauri apps can have custom menus and have tray-type\ninterfaces. They can be updated, and are managed by the user's operating system\nas expected. They are very small, because they use the OS's webview. They do not\nship a runtime, since the final binary is compiled from Rust. This makes the\nreversing of Tauri apps not a trivial task. ## What Tauri is NOT - Tauri is not\na lightweight kernel wrapper...instead it directly uses [WRY](#wry) and\n[TAO](#tao) to do the heavy-lifting in making system calls to the OS. - Tauri is\nnot a VM or virtualized environment...instead it is an application toolkit that\nallows making Webview OS applications. ## Major Components The following section\nbriefly describes the roles of the various parts of Tauri. ### Tauri Core\n[STABLE RUST] ####\n[tauri](https://github.com/tauri-apps/tauri/tree/dev/core/tauri) This is the\nmajor crate that holds everything together. It brings the runtimes, macros,\nutilities and API into one final product. It reads the `tauri.conf.json` file at\ncompile time in order to bring in features and undertake actual configuration of\nthe app (and even the `Cargo.toml` file in the project's folder). It handles\nscript injection (for polyfills / prototype revision) at runtime, hosts the API\nfor systems interaction, and even manages updating. ####\n[tauri-build](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-build)\nApply the macros at build-time in order to rig some special features needed by\n`cargo`. ####\n[tauri-codegen](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-codegen)\n- Embed, hash, and compress assets, including icons for the app as well as the\nsystem-tray. - Parse `tauri.conf.json` at compile time and generate the Config\nstruct. ####\n[tauri-macros](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-macros)\nCreate macros for the context, handler, and commands by leveraging the\n`tauri-codegen` crate. ####\n[tauri-runtime](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime)\nThis is the glue layer between tauri itself and lower level webview libraries.\n####\n[tauri-runtime-wry](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime-wry)\nThis crate opens up direct systems-level interactions specifically for WRY, such\nas printing, monitor detection, and other windowing related tasks.\n`tauri-runtime` implementation for WRY. ####\n[tauri-utils](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-utils)\nThis is common code that is reused in many places and offers useful utilities\nlike parsing configuration files, detecting platform triples, injecting the CSP,\nand managing assets. ### Tauri Tooling ####\n[api](https://github.com/tauri-apps/tauri/tree/dev/tooling/api) [TS -> JS] A\ntypescript library that creates `cjs` and `esm` Javascript endpoints for you to\nimport into your Frontend framework so that the Webview can call and listen to\nbackend activity. We also ship the pure typescript, because for some frameworks\nthis is more optimal. It uses the message passing of webviews to their hosts.\n#### [bundler](https://github.com/tauri-apps/tauri/tree/dev/tooling/bundler)\n[RUST / SHELL] The bundler is a library that builds a Tauri App for the platform\ntriple it detects / is told. At the moment it currently supports macOS, Windows\nand Linux - but in the near future will support mobile platforms as well. May be\nused outside of Tauri projects. ####\n[cli.js](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli.js) [JS]\nWritten in Typescript and packaged such that it can be used with `npm`, `pnpm`,\nand `yarn`, this library provides a node.js runner for common tasks when using\nTauri, like `yarn tauri dev`. For the most part it is a wrapper around\n[cli.rs](https://github.com/tauri-apps/tauri/blob/dev/tooling/cli.rs). ####\n[cli.rs](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli.rs) [RUST]\nThis rust executable provides the full interface to all of the required\nactivities for which the CLI is required. It will run on macOS, Windows, and\nLinux. ####\n[create-tauri-app](https://github.com/tauri-apps/tauri/tree/dev/tooling/create-tauri-app)\n[JS] This is a toolkit that will enable engineering teams to rapidly scaffold\nout a new tauri-apps project using the frontend framework of their choice (as\nlong as it has been configured). # External Crates The Tauri-Apps organisation\nmaintains two \"upstream\" crates from Tauri, namely TAO for creating and managing\napplication windows, and WRY for interfacing with the Webview that lives within\nthe window. ## [TAO](https://github.com/tauri-apps/tao) Cross-platform\napplication window creation library in Rust that supports all major platforms\nlike Windows, macOS, Linux, iOS and Android. Written in Rust, it is a fork of\n[winit](https://github.com/rust-windowing/winit) that we have extended for our\nown needs like menu bar and system tray. ##\n[WRY](https://github.com/tauri-apps/wry) WRY is a cross-platform WebView\nrendering library in Rust that supports all major desktop platforms like\nWindows, macOS, and Linux. Tauri uses WRY as the abstract layer responsible to\ndetermine which webview is used (and how interactions are made). ##\n[tauri-hotkey-rs](https://github.com/tauri-apps/tauri-hotkey-rs) We needed to\nfix hotkey to work on all platforms, because upstream was not being responsive.\n# Additional tooling ##\n[binary-releases](https://github.com/tauri-apps/binary-releases) This is the\ndelivery mechanism for tauri prebuilt binaries: currently the cli.rs (used by\ncli.js) and rustup binaries (used by the deps install command of cli.js). These\nartifacts are automatically created on release. ##\n[tauri-action](https://github.com/tauri-apps/tauri-action) This is a github\nworkflow that builds tauri binaries for all platforms. It is not the fastest out\nthere, but it gets the job done and is highly configurable. Even allowing you to\ncreate a (very basic) tauri app even if tauri is not setup. ##\n[create-pull-request](https://github.com/tauri-apps/create-pull-request) Because\nthis is a very risky (potentially destructive) github action, we forked it in\norder to have strong guarantees that the code we think is running is actually\nthe code that is running. ##\n[vue-cli-plugin-tauri](https://github.com/tauri-apps/vue-cli-plugin-tauri) This\nplugin allows you to very quickly install tauri in a vue-cli project. ##\n[tauri-vscode](https://github.com/tauri-apps/tauri-vscode) This project enhances\nthe VS Code interface with several nice-to-have features. # Tauri Plugins\n[documentation](https://tauri.studio/en/docs/guides/plugin) Generally speaking,\nplugins are authored by third parties (even though there may be official,\nsupported plugins). A plugin generally does 3 things: 1. It provides rust code\nto do \"something\". 2. It provides interface glue to make it easy to integrate\ninto an app. 3. It provides a JS API for interfacing with the rust code. Here\nare several examples of Tauri Plugins: -\nhttps://github.com/tauri-apps/tauri-plugin-sql -\nhttps://github.com/tauri-apps/tauri-plugin-stronghold -\nhttps://github.com/tauri-apps/tauri-plugin-authenticator # Workflows ## What\ndoes the Development flow look like? A developer must first install the\nprerequisite toolchains for creating a Tauri app. At the very least this will\nentail installing rust & cargo, and most likely also a modern version of node.js\nand potentially another package manager. Some platforms may also require other\ntooling and libraries, but this has been documented carefully in the respective\nplatform docs. Because of the many ways to build front-ends, we will stick with\na common node.js based approach for development. (Note: Tauri does not by\ndefault ship a node.js runtime.) The easiest way to do this is to run the\nfollowing: ``` npx create-tauri-app ``` Which will ask you a bunch of questions\nabout the framework you want to install and then create everything you need in a\nsingle folder - some via the placement of template files and some through normal\ninstallation procedures of your framework. > If you don't use this process, you\nwill have to manually install the tauri cli, initialise tauri and manually\nconfigure the `tauri.conf.json` file. Once everything is installed, you can run:\n``` yarn tauri dev -or- npm run tauri dev ``` This will do several things: 1.\nstart the JS Framework devserver 2. begin the long process of downloading and\ncompiling the rust libraries 3. open an application window with devtools enabled\n4. keep a long-lived console alive If you change your HTML/CSS/TS/JS, your\nframework devserver should give you its best shot at instant hot module\nreloading and you will see the changes instantly. If you modify your rust code\nor anything in the Cargo.toml, the window will close while rust recompiles. When\nfinished it will reload. If you need to get deeper insight into your current\nproject, or triage requires investigation of installed components, just run: ```\nyarn tauri info ``` ## What does the Release flow look like? The release flow\nbegins with proper configuration in the `tauri.conf.json` file. In this file,\nthe developer can configure not only the basic behaviour of the application\n(like window size and decoration), they can also provide settings for signing\nand updating. Depending upon the operating system that the developer (or CI) is\nbuilding the application on, there will be an app built for them for that\nsystem. (Cross compilation is not currently available, however there is an\nofficial [GitHub Action](https://github.com/tauri-apps/tauri-action) that can be\nused to build for all platforms.) To kick off this process, just: ``` yarn tauri\nbuild ``` After some time, the process will end and you can see the results in\nthe `./src-tauri/target/release` folder. ## What does the End-User flow look\nlike? End users will be provided with binaries in ways that are appropriate for\ntheir systems. Whether macOS, Linux, or Windows, direct download or store\ninstallations - they will be able to follow procedures for installing and\nremoving that they are used to. ## What does the Updating flow look like? When a\nnew version is ready, the developer publishes the new signed artifacts to a\nserver (that they have configured within `tauri.conf.json`). The application can\npoll this server to see if there is a new release. When there is a new release,\nthe user is prompted to update. The application update is downloaded, verified\n(checksum & signature), updated, closed, and restarted. ## License Tauri itself\nis licensed under MIT or Apache-2.0. If you repackage it and modify any source\ncode, it is your responsibility to verify that you are complying with all\nupstream licenses. Tauri is provided AS-IS with no explicit claim for\nsuitability for any purpose. Here you may peruse our [Software Bill of\nMaterials](https://app.fossa.com/projects/git%2Bgithub.com%2Ftauri-apps%2Ftauri).","url":"https://tauri.studio/docs/architecture"},{"id":"prose_docs_faq_md","title":"Frequently Asked Questions","headings":[],"subHeadings":[],"code":[null],"text":"# error: could not find native static libraryWebView2LoaderStatic, perhaps an -L\nflag is missing? The WebView2 crate build pipeline requires `NuGet` to have a\n`PackageSource` to install the `Microsoft.Web.WebView2` package. If you never\nused `NuGet` before, you might need to create a file named `NuGet.Config` on\n`%APPDATA%/NuGet` folder, with the following contents: ``` ``` This\nconfiguration enables the default `NuGet` registry.","url":"https://tauri.studio/docs/faq"},{"id":"prose_docs_about_book_md","title":"Get the book","area":"about","section":"about","headings":["Outline","Errata"],"subHeadings":["tl","Introduction","About the Topic","What you will learn","Stuff you","Chapter 1 ","Chapter 2 ","Chapter 3 ","Chapter 4 ","Chapter 5 "],"code":[null],"text":"import useBaseUrl from '@docusaurus/useBaseUrl'\nTauri - From Theory to Practice [{useBaseUrl('img/bookCover.png')}]\nTauri: From Theory to Practice\nArchitecting Next-Gen Native-Apps for all Platforms [v1:Rust Edition]\nAuthors: [Daniel Thompson-Yvetot, Lucas Fernandes Gonçalves Nogueira]\nPublisher: TBD\nRelease: late 2020\n### tl;dr; Visit https://opencollective.com/tauri and preorder your copy of the\nbook today. Your donation will support the ongoing development of Tauri, and you\nwill receive advance digital PDF's for your review as chapters are completed.\nThe final book will ship concurrently with the release of 1.0.0 stable. If you\ndonate 10 USD / month to Tauri, you will get the advance PDF versions as soon as\nthey are released. If you just want to donate once: 15 USD for PDF and e-book,\n30 USD for print version and PDF, 40 USD for all three. All tutorial\nsubscription tiers receive the rolling PDF free of additional charge. ###\nIntroduction In 2020, the manufacture of native-apps has become easier and more\naccessible than ever before. All the same, beginners and seasoned developers\nalike are confronted with tough choices in a rapidly changing landscape of\nsecurity and privacy. This is especially true in the semi-trusted environment of\nuser devices. Tauri takes the guesswork out of the equation, as it was designed\nfrom the ground up to embrace new paradigms of secure development and creative\nflexibility that leverage the language features of Rust and lets you build an\napp using any frontend framework you like. Find out how you can design, build,\naudit and deploy tiny, fast, robust, and secure native applications for the\nmajor Desktop and Mobile platforms, all from the exact same codebase and in\nrecord time - without even needing to know the Rust programming language.\nAuthors Daniel and Lucas, the architects behind Tauri take you on a journey from\ntheory to execution, during which you will learn why Tauri was built and how it\nworks under the hood. Together with guest personalities that specialize in Open\nSource, DevOps, Security and Enterprise Architecture, this book also presents\ndiscourse-formatted philosophical discussions and open-source sustainability\nviewpoints from which your next-gen apps will profit - and your users will\nbenefit. In this book you will follow the authors in the iterative evolution of\na real project from conception to distribution - all with commentary, complete\ncode resources, built, and packaged Native Apps for reference and staged Capture\nthe Flag (CTF) challenges that progress in difficulty as your comprehension of\nthe system grows. ### About the Topic Tauri is a brand new way to make\ncross-platform native-apps for web, desktop and mobile. At this very moment, the\npre-alpha version of this MIT licensed community-based software is being\nprepared for public release: https://github.com/tauri-apps/tauri Tauri\nintroduces novel methods for WebView integration and innovative patterns for\nrobust threat evasion. The 1.0 release will ship with a multipurpose white-box\nanalyzer and decompiler for any kind of binary and an integrated CLI for\ningesting any type of HTML; which, when combined, provides developers and\nsecurity teams with a holistic platform that has never existed as a single unit\nbefore. Tauri bridges communities and opens up new opportunities for everyone\nfrom the front end developer all the way to the low-level security and network\nadministrators. Due to this level of complexity and robustness, it is important\nto publish a reference guide that will necessarily be updated as major versions\nare released. ### What you will learn By the end of this book you will\nunderstand: - The method and reasoning behind the design of Tauri - The options\nyou have when building with Tauri - That having a moral compass is possible in\nsoftware development - Why the Rust language makes the most sense as a binding\nand application layer - Why Electron, Cordova, React Native, Capacitor and\nothers are no longer the best choice - Why a binary review is important And you\nwill be able to: - Transform a simple website project into a Tauri Native-App -\nMake a variety of Tauri Application Types based on the main Patterns - Decompile\nand analyze your App for Security Issues - Publish your App to a variety of App\nStores - Read and write Rust code ### Stuff you'll get if you preorder - Access\nto a real demo App built for all platforms available at respective stores (that\nincludes CTF Flags). - Exclusive One-Pager cheat sheets made available for each\nsection of the book, including the Appendices. - Early access to videos /\nwebcasts. - Discounted participation in the “Capture the Flag” event hosted at\nthe launch of the book. ## Outline This is an early outline of the contents that\nwe expect to publish. Contents subject to change. ### Chapter 1 - Theory (ca. 50\npages - mostly conversational / technical, graphics) ``` 1. Security Starts with\nYou 2. Privacy Ends with ${you} 3. Languages, Dialects and Patterns 4.\nToolchains and Syntactic Sugar 5. Production Methodologies 6. Enterprise\nReadiness 7. Message Queueing 8. Embracing Chaos 9. Distribution Techniques 10.\nLicensing Strategies ``` ### Chapter 2 - Practice (ca. 130 pages w/ charts,\nscreenshots, code samples) ``` 1. Environment Prerequisites - Node, Npm, Yarn,\nRustc, Rustup, Buildtools 2. Development Platform Details - macOS - Windows -\nLinux - Docker - Virtual Machines - CI / CD 3. Tauri Introduction 4. Tauri\nAnatomy 5. Tauri Configuration - Files & Folders - Icons - Splash Screens -\nWindow - `src-tauri/tauri.conf.json` 6. Preparing your code - Transpile dynamic\nimports - Remove webpack chunking - Monolithic Files - Minification strategies\n7. Tauri API - Design Considerations - API Usage Patterns - Custom API Functions\n- Endpoints - All - Answer - Bridge - Event - Execute - List Files - Open - Read\nBinary File - Read Text File - Set Title - Window - Write File 8. Web APIs 9.\nTauri App Extensions - Anatomy - Flow - Registration - Publication - API 10.\nTaskbar Integration (Desktop Only) - Anatomy - Integrations - macOS - Windows -\nLinux 11. Security Features - Baseline Rust Features - Functional Address Space\nLayout Randomization (fASLR) - Ahead of Time (AoT) Compilation - Content\nSecurity Policy (CSP) - One Time Pads (OTP) - Embedded Server: False - API\nTree-Shaking - Matryoschkasumming (with Tauri-Frida) 12. Bridges and Brokers -\nBridge Patterns - Message hashing with OTP - Plugin Pattern - Kamikaze Function\nInjection (KFI) Closures 13. Testing - Unit Testing - Rust - JS - Integration\nTesting - e2e Testing 14. Building - Debugging - Packaging - Minification -\nDistribution Platform Details - macOS (.app / .dmg) - Win (.exe / .msi) - Linux\nArm64 (.appImage / .deb) - Linux x64 (.appImage / .deb) - iOS (.ipa) - Android\n(.apk) - PWA Website (with wasm) - Code Signing - Keystores - Certs -\nFingerprints - Providing License for End Users - Providers - Keys Files -\nSelf-Updater - Anatomy - Service Provisioning - Github - AWS - Homegrown -\nCross-Platform Bundler 15. Tauri-Frida Harness - Introduction to Reverse\nEngineering - Toolchain - Usage - Binary Hooking at Runtime - Pointer Evaluation\n- Spraying, Fuzzing, Spoofing - Report Generation - Recompilation - Post-Binary\nAnalysis 16. Distribution - Git - Mac Store - iOS Store - Play store - Windows\nStore - Snap Store - PureOS Store - .deb channels - .tar.gz - homebrew - Fdroid\n- Cydia - ChromeOS - WASM ``` ### Chapter 3 - Philosophical Discourses (ca. 40\npages of essays, some graphics) ``` 1. Rights and Responsibilities (with Robin\nvan Boven (SFOSC)) - Who You are Responsible To - Being a Vendor Comes with\nDuties - Ubiquitous Resources are Still Precious - Use Policy to Address\nResponsibilities - Take a Hippocratic Development Oath 2. Take a More Secure\nStance (with Liran Tal (SNYK)) - Security Benefits of Frameworks - Encrypt All\nthe Things, All the Time - Constantly Audit Project Dependencies - Harden\nYourself, Your Organization and Your Ecosystem - “Do What You Can Until You Run\nOut of Time.” - [ROBERT C. SEACORD] 3. Production Strategies for Sustainability\n(with Rhys Parry (Independent)) - Develop in the “Perfect” Environment - Minimal\nImpact for Existing Enterprise Architectures - Use Low-Barrier Tools for\nEnsuring Wholestack Security - Test the Right Things Intelligently - Post-Binary\nAnalysis and Redistribution - The Last Mile ``` ### Chapter 4 - Execution (ca.\n100 pages w/ code examples, screenshots, graphics) ``` 1. Base Pattern Evolution\n- Hermit - Bridge - Cloudish - Cloudbridge - Lockdown - Multiwin - GLUI 2.\nAdvanced Patterns - Cryptographic Enclave - Identity Management - Combine an App\nwith a Daemon - IPC / RPC - Integrate with DENO 3. UI Source Complilation -\nReact - Vue - Angular - Svelte - Gatsby 4. Building a Real App - Multiparty\nPassword Manager - Design - Prototyping - Testing - Debugging - Packaging -\nChecksumming 5. Tauri-Frida - White Box Reversing - Analyzing with Frida - Chaos\nExperiments - Interface Jacking - Disk Change - Latency - Process Kill - CPU\nThrottle - Static Analysis Reporting - Binary Repackaging - Inject License Keys\n- Clear Dead Codepoints - Recalculate Integrated Checksum 6. Publishing the App\n- Git - Mac Store - iOS Store - Play store - Windows Store - Snap Store - PureOS\nStore - .deb channels - .tar.gz - homebrew - Fdroid - Cydia - ChromeOS - WASM 7.\nPublishing an Update ``` ### Chapter 5 - Appendices (ca. 120 pages) ``` 1.\nConfiguration Options 2. Files and Repositories 3. Tauri CLI references 4. Tauri\nAPI references 5. ES6 References 6. Rust References 7. App Pattern Charts 8.\nTauri-Frida Reference 9. Glossary 10. Index ``` ## Errata Got something that you\nthink should be in the book? Want to be our publisher? Reach out to us and let\nus know!","url":"https://tauri.studio/docs/about/book"},{"id":"prose_docs_about_governance_md","title":"Governance","area":"about","section":"about","headings":["Sustainability"],"subHeadings":["Organizational Structure","Code of Conduct","Social Contract","Licensing","Trademark"],"code":[],"text":"## Sustainability One of the main goals of the organizational structure of Tauri\nis to guarantee the sustainability of Tauri and the health and well-being of its\ncontributors. The world of Open Source is fraught with peril and discord, and we\nhave taken measures to ensure the longevity of Tauri. This document explains how\nwe go about doing so. ### Organizational Structure Tauri apps is governed by the\ncommunity and work is done in the context of public working groups. Each working\ngroup has a dedicated channel on the Discord server as well as a Team on GitHub.\nOther than that, each WG is free to use whatever type of organizational model it\nchooses. The current working groups are: - WG Governance & Guidance - WG Tech -\nWG Education - WG Media - WG Security - WG Devops With the exception of the\nsecurity working group, which is by invite only and convenes privately, all\nother working groups are public and open to any and all participants. Please\nvisit [this repository](https://github.com/tauri-apps/governance-and-guidance)\nto get more information. ### Code of Conduct Everyone participating in the Tauri\ncommunity is expected to follow a code of conduct that you can at the\n[Governance and Guidance:Code of\nConduct](https://github.com/tauri-apps/governance-and-guidance/blob/master/CODE_OF_CONDUCT.md).\n### Social Contract We have a Social Contract that informs our decision making\nand organization. You can read about it here: [Governance and Guidance:Social\nContract](https://github.com/tauri-apps/governance-and-guidance/blob/master/SOCIAL_CONTRACT.md).\n### Licensing We, the contributors to Tauri Apps, use the MIT and Apache\nlicenses for all code content. Images and bodies of text, unless otherwise noted\nare CC-BY-ND-NC. ### Trademark It is a permissible use of the name \"Tauri App\"\nor the Tauri logo to show that a project uses Tauri. \"Tauri Studio\" is reserved\nfor use by the organization. Any language that gives the impression that the\nTauri organization approves, authorizes or otherwise supports a project, person\nor company is not permissible without written authorization from the Guidance\nand Governance Working Group.","url":"https://tauri.studio/docs/about/governance"},{"id":"prose_docs_about_intro_md","title":"What is Tauri?","area":"about","section":"about","headings":["Security First","Polyglots","Honest Open Source","The Future"],"subHeadings":[],"code":[],"text":"Tauri is a toolkit that helps developers make applications for the major desktop\nplatforms - using virtually any frontend framework in existence. The core is\nbuilt with Rust and the CLI leverages Node.js making Tauri a genuinely polyglot\napproach to creating and maintaining great apps. If you want to know more about\nthe technical details, then please visit the\n[Introduction](/docs/get-started/intro). If you want to know more about this\nproject's philosophy - then keep reading.\n\n## Security First In today's world, every honest threat model assumes that the\nuser's device has already been compromised. This puts app developers in a\ncomplicated situation, because if the device is already at risk, how can the\nsoftware be trusted? Defense in depth is the approach we've taken. We want you\nto be able to take every precaution possible to minimise the surface area you\npresent to attackers. Tauri lets you choose which API endpoints to ship, whether\nor not you want a localhost server built into your app, and it even randomizes\nfunctional handles at runtime. These and other techniques form a secure baseline\nthat empowers you and your users. Slowing down attackers by making static\nattacks crushingly difficult and isolating systems from one another is the name\nof the game. And if you are coming from the Electron ecosystem - rest assured -\nby default Tauri only ships binaries, not ASAR files. By choosing to build Tauri\nwith security as a guiding force, we give you every opportunity to take a\nproactive security posture. ## Polyglots, not Silos Most contemporary frameworks\nuse a single language paradigm and are therefore trapped in a bubble of\nknowledge and idiom. This can work well for certain niche applications, but it\nalso fosters a kind of tribalism. This can be seen in the way that the React,\nAngular and Vue development communities huddle on their stacks, ultimately\nbreeding very little cross-pollination. This same situation can be seen in the\nRust vs Node vs C++ battlefields, where hardliners take their stances and refuse\nto collaborate across communities. Today, Tauri uses Rust for the backend - but\nin the not too distant future, other backends like Go, Nim, Python, Csharp etc.\nwill be possible. This is because we are maintaining the official Rust bindings\nto the [webview](https://github.com/webview) organisation and plan to let you\nswitch out the backend for your needs. Since our API can be implemented in any\nlanguage with C interop, full compliance is only a PR away. ## Honest Open\nSource None of this would make any sense without a community. Today software\ncommunities are amazing places where people help each other and make awesome\nthings - open source is a very big part of that. Open source means different\nthings to different people, but most will agree that it serves to support\nfreedom. When software doesn't respect your rights, then it can seem unfair and\npotentially compromise your freedoms by operating in unethical ways. This is why\nwe are proud that FLOSS advocates can build applications with Tauri that are\n\"certifiably\" open source and can be included in FSF endorsed GNU/Linux\ndistributions. ## The Future Tauri's future depends on your involvement and\ncontributions. Try it out, file issues, join a working group or make a donation\n- every contribution is important. Please, at any rate, do get in touch!!!","url":"https://tauri.studio/docs/about/intro"},{"id":"prose_docs_about_security_md","title":"Security","area":"about","section":"about","headings":["No Server Required","Language Features of Rust","Dynamic Ahead of Time Compilation ","Function Hardening","System Features","Ecosystem","Future Work"],"subHeadings":["Security Researchers","Functional ASLR","Kamikaze Function Injection","Bridge","One Time Pad Tokenization and Hashing","Allowing API","Content Security Policy Management","Decompilation is Difficult","Build Pipelines and Artifact Authenticity","Resilient PR and Approval Processes","Signed Binaries","Post","Post","Audits"],"code":[],"text":"This guide seeks to explain the high level concepts and Security Features at the\ncore of Tauri's design that make you, your apps and your users safer by default.\nPlease note:\nWhile we take every opportunity to help you harden your application - there are\nalways underlying threats like BIOS attacks, memory rowhammering and other\noperating system vulnerabilities that are constantly being discovered and (in\nthe best cases) responsibly disclosed.\nFurthermore, there are many ways that development teams can cut corners and\neither leak sensitive information or leave doors wide open to any of a range of\nattacks. Security is a never-ending quest, and your users count on you to keep\nthem safe.\nTherefore, we highly recommend that you take some time to consider the security\nramifications of everything that your application does, especially in the\ncontext of running on the semi-hostile platform of end-user devices.\nIf you need help or want a review, you are welcome to contact the Tauri team for\nsecurity consultation.\n### Security Researchers If you feel that there is a security concern or issue\nwith anything in Tauri, please do not publicly comment on your findings.\nInstead, reach out directly to our security team: > security@tauri.studio\nAlthough we do not currently have a budget for Security Bounties, in some cases\nwe will consider rewarding responsible disclosure with our limited resources. ##\nNo Server Required Tauri enables you to construct an application that uses\nweb-technology for the user interface without requiring you to use a server to\ncommunicate with the backend. Even if you used advanced techniques of dynamic\nimports and offload work to the backend, no traffic can be sniffed on TCP ports\nor external processes - because they just aren't there. This reduces not only\nthe physical and virtual footprint of your final binary by a good deal, it also\nreduces the surface area of potential attack vectors by removing them from the\nequation. ## Language Features of Rust By turning to the programming language\nrenowned for its memory-safety and speed, Tauri simply erases whole classes of\nconventional attacks. `Use after free` just isn't something that can happen with\nTauri. ## Dynamic Ahead of Time Compilation (AOT) This process of compilation\nhappens several times during the bootstrapping phase of a Tauri app. By using\nour default dynamic Ahead of Time compiler, you can generate code references\nthat are unique for every session and are still technically static code units.\n## Function Hardening ### Functional ASLR Functional address Space Layout\nRandomization techniques randomize function names at runtime and can implement\nOTP hashing so no two sessions are ever the same. We propose a novel type of\nfunction naming at boot time and optionally after every execution. Using a UID\nfor each function pointer prevents static attacks. ### Kamikaze Function\nInjection This advanced type of fASLR using the `EVENT` API endpoint, is a\npromise wrapped in a closure (with randomized handle) that Rust inserts at\nruntime into the WebView, where its interface is locked within the promise\nresolution handler and is nulled after execution. ### Bridge, don't serve\nInstead of passing potentially unsafe functions, an event bridge can be used to\npass messages and commands to named brokers at each respective side of the\napplication. ### One Time Pad Tokenization and Hashing Hashing important\nmessages with a OTP salt, you are able to encrypt messages between the user\ninterface and the Rust backend. We are currently investigating the use of\nadditional sources of entropy such as the amazing [Infinite Noise\nTRNG](https://13-37.org/en/shop/infinite-noise-trng/). ## System Features ###\nAllowing API You have the ability to pick and choose which API functions are\navailable to the UI and to Rust. If they are not enabled, the code will not be\nshipped with your app, which reduces binary size and attack surface. They are\nopt-in, so you have to consciously choose to progressively enhance your\napplication. ### Content Security Policy Management Preventing unauthorized code\nexecution for websites has long since been \"resolved\" by using CSPs. Tauri can\ninject CSPs into the index.html of the user interface, and when using a\nlocalhost server it will also send these headers to the UI or any other clients\nthat connect with it. ### Decompilation is Difficult This means that your apps\ncannot be easily decompiled as is the case with Electron ASAR files, which makes\nthe process of reverse engineering your project much more time intensive and\nrequires specialist training. ## Ecosystem ### Build Pipelines and Artifact\nAuthenticity The process of releasing our source-code artifacts is highly\nautomated, yet mandates kickoff and review from real humans. Our current release\nstrategy uses a combination of Github Actions and IOTA Tangle publication ###\nResilient PR and Approval Processes Our WG-TECH reviews code changes, tags PRs\nwith scope and make sure that everything stays up to date. And when its time to\npublish a new version, one of the maintainers tags a new release on master,\nwhich: - validates core - runs smoke tests - audits security for crates and npm\n- generates changelogs - creates artifacts - publishes checksums to IOTA -\ncreates a draft release Then the maintainer reviews the release notes, edits if\nnecessary - and a new release is forged. ## Future Work ### Signed Binaries\nBecause the entire project is shipped within a monolithic binary, code can be\nsigned for all distributables. (Currently using external tooling, but we are\nactively working on making the bundler a one-stop-shop.) This makes it virtually\nimpossible for hackers to change an installed Application without the operating\nsystem noticing. [Reference](https://github.com/electron/asar/issues/123) ###\nPost-Binary Analysis Use industrial-grade pentester-tooling (via our forthcoming\nTauri-Frida GUI) to discover and fix security weaknesses in your final binaries.\n### Post-Binary Enhancement After the build is before the delivery, and Tauri\nwill provide you with tools never seen before. Stay tuned! ### Audits We are\ncurrently in the process of our first external audit. When complete, we will\npublish the results here.","url":"https://tauri.studio/docs/about/security"},{"id":"prose_docs_development_ci_cd_md","title":"CI/CD","area":"development","section":"development","headings":["Continuous Integration","Continuous Deployment"],"subHeadings":["Introduction to immutable checksum","Next Steps"],"code":["yml"],"text":"## Continuous Integration Github Actions has two triggers of which we make heavy\nuse: `push` and `pull_request`. Every commit that made to the repo is a `push`.\nWhen you open a pull request from a branch (call it `great_feature`) to another\nbranch (our working branch, `dev`), each commit to `great_feature` would\npossibly trigger both of these events. We can use a filter to focus on the\nevents we care about though. In our workflows, we only PR (pull request) the\n`dev` and `master` branches. This means that if we filter to only the `dev` and\n`master` branches on commit, we will only run that workflow when we _merge_ a\nPR. A merged PR typically only occurs once a day or less so this will be a good\nfit for the longer running tests, e.g. the smoke tests in our case. Below is how\nthat might look. Unit tests: ```yml # these run fast so we can have them run on\nany commit name: unit tests on: pull_request: push: branches: - dev - master ```\nSmoke tests: ```yml # these run slower so we run only on merges to dev or master\nbranch name: smoke tests on: push: branches: - dev - master ``` Tauri operates\noff the `dev` branch as default, and merges to `master` for release. With these\nGithub Actions set up, we will run the unit tests on every commit to an open PR\n(see `pull_request`). When that PR is merged into `dev`, we will run both the\nunit tests and the smoke tests. ## Continuous Deployment ### Introduction to\nimmutable checksum It is not only possible, but trivial to modify release notes\nand artifacts after it has been published on Github. While there are very valid\nreasons for doing this, it is not exactly a totally trustworthy method - i.e.\nyou have no guarantee that what you are reading is really reflective of the\nunderlying truth or the tarballs. It is technically possible to change downloads\nover the wire or in the box or change checksums in targeted attacks. What we are\nseeking to accomplish is a best case scenario where: 1. Human error is reduced\nto a minimum, but humans are still integral in the actual release 2. Machine\nbuilt assets, changelogs and attached security audits are verifiable with\nchecksums that are published in an immutable, globally available store. To this\nend we fashioned a workflow shown below. As it stands now, we have #3 through #6\nimplemented. We manually do #2 which then feeds into #3 and kicks off the rest\nof the automatic workflow. 1. a human pushes to dev through a pull request (can\nhappen any number of times) - pull request includes a changeset file describing\nthe change and required version bump 2. a pull request is created (or updated)\nto include the change and version bump - this pull request stays open and will\nbe force pushed until it gets merged (and published) - increase the version\nnumber based on changesets - delete all changeset files 3. a codeowner merges\nthe publish PR to dev (no direct push permissible for anyone) - all tests (unit,\ne2e, smoke tests) are run on the PR - failures prevent the publish so they must\npass before merge 4. merge to dev triggers release sequence - changes are\nsquashed and a PR is opened against master 5. when PR to master is merged... -\nvulnerability audit (crates and yarn) and output saved - checksums and metadata\nand output saved - packages are published on npm/cargo, tarball/zip created -\nrelease is created for each package that had updates (if version isn't changed,\nbuild skips the publish steps) - output from audit/checksums is piped into the\nrelease body - tarball / zip attached to release - async process to publish to\nIOTA tangle (feeless) via release tag [note: still have things to resolve here]\n6. release is complete - master has updated code and tagged - GitHub release has\ntarballs, checksums, and changelog (may have multiple releases if more than one\npackage published) [note: is part of step 2 and is not yet implemented] ### Next\nSteps Next steps may include transferring and publishing the built assets to\nadditional places: 1. Tauri's private verdaccio 2. IPFS 3. PureOS Gitlab 4.\nGitHub Packages We can also do some interesting things like signing our\nreleases, including a hash in the release and/or even publishing this\ninformation on a blockchain that it can be easily verified. Publishing on the\nblockchain is another avenue to increase the confidence that what is seen on\nGitHub matches what you have downloaded. The IOTA foundation created a Github\nAction which will publish a release to their blockchain. This has shown promise,\nbut he gave a couple errors to tackle still.","url":"https://tauri.studio/docs/development/ci-cd"},{"id":"prose_docs_development_cross_platform_md","title":"Cross-Platform Compilation","area":"development","section":"development","headings":[],"subHeadings":[],"code":[],"text":"How to use GH Action for Building: a glance at Tauri Action.","url":"https://tauri.studio/docs/development/cross-platform"},{"id":"prose_docs_development_debugging_md","title":"Debugging","area":"development","section":"development","headings":["Rust Console","WebView JS Console","Create a Debug Build","Run Your App From the Terminal"],"subHeadings":[],"code":["rust","sh",null],"text":"import Alert from '@theme/Alert' import Command from '@theme/Command' With all\nthe moving pieces in Tauri, you may run into a problem that requires debugging.\nThere are a handful of locations where error details are printed, and Tauri\nincludes some tools to make the debugging process easier. ## Rust Console When\nyou run a Tauri app in development mode you will have a Rust console available.\nThis is in the terminal where you ran e.g. `tauri dev`. You can use the\nfollowing code to print something to that console from within a Rust file:\n```rust println!(\"Message from Rust: {}\", msg); ``` Sometimes you may have an\nerror in your Rust code, and the Rust compiler can give you lots of information.\nIf, for example, `tauri dev` crashes, you can rerun it like this on Linux and\nmacOS: ```sh RUST_DEBUG=1 tauri dev ``` or like this on MS Windows: ```sh set\nRUST_DEBUG=1 tauri dev ``` This will give you a granular stack trace. Generally\nspeaking, the Rust compiler will help you by giving you detailed information\nabout the issue, such as: ``` error[E0425]: cannot find value `sun` in this\nscope --> src/main.rs:11:5 | 11 | sun += i.to_string().parse::().unwrap(); | ^^^\nhelp: a local variable with a similar name exists: `sum` error: aborting due to\nprevious error For more information about this error, try `rustc --explain\nE0425`. ``` ## WebView JS Console Right click in the WebView, and choose\n`Inspect Element`. This will open up a web-inspector similar to the Chrome or\nFirefox dev tools you are used to. ## Create a Debug Build There are cases where\nyou might need to inspect the JS console in the final bundle, so Tauri provides\na simple command to create a debugging bundle: Like the normal build and dev\nprocesses, the first time you run this it will take more time than subsequent\nruns. The final bundled app will be placed in `src-tauri/target/debug/bundle`.\nThat app will ship with the development console enabled. ## Run Your App From\nthe Terminal You can also run a built app from the terminal, which will also\ngive you the Rust compiler notes (in case of errors) or your `println` messages.\nJust find the file `src-tauri/target/(release|debug)/[app name]` and either\ndouble click it (but be warned, the terminal will close on errors) or just run\nit in directly in your console.","url":"https://tauri.studio/docs/development/debugging"},{"id":"prose_docs_development_development_cycle_md","title":"Development Cycle","area":"development","section":"development","headings":[],"subHeadings":["1","2"],"code":[],"text":"import Alert from '@theme/Alert' import Command from '@theme/Command' ### 1.\nStart Your Devserver Now that you have everything setup, you should start your\napplication development server provided by your UI framework or bundler\n(assuming you're using one, of course). Every framework has its own development\ntooling. It is outside of the scope of this document to treat them all or keep\nthem up to date. ### 2. Start Tauri Development Window The first time you run\nthis command, it will take several minutes for the Rust package manager to\ndownload and build all the required packages. Since they are cached, subsequent\nbuilds will be much faster, as only your code will need rebuilding. Once Rust\nhas finished building, the webview will open and it should display your web app.\nYou can make changes to your web app, and if your tooling enables it, the\nwebview should update automatically just like a browser. When you make changes\nto your Rust files, they will be rebuilt automatically and your app will\nrestart. In your project repository, you SHOULD commit the\n\"src-tauri/Cargo.lock\" along with the \"src-tauri/Cargo.toml\" to git because\nCargo uses the lockfile to provide deterministic builds. As a result, it is\nrecommended that all applications check in their Cargo.lock. You SHOULD NOT\ncommit the \"src-tauri/target\" folder or any of its contents.","url":"https://tauri.studio/docs/development/development-cycle"},{"id":"prose_docs_development_integration_md","title":"Integrate with Tauri","area":"development","section":"development","headings":["Vue CLI Plugin Tauri"],"subHeadings":["1","1","2","3","Patterns"],"code":["bash","sh",null],"text":"import Alert from '@theme/Alert' import Command from '@theme/Command' import\nLink from '@docusaurus/Link' You must have completed all the steps required for\nsetting up the development environment on your machine. If you haven't done this\nyet, please see the setup page for your operating system\n[/docs/get-started/intro#setting-up-your-environment]. There are two ways to\nintegrate with Tauri depends on your need: - [Start a new Tauri\nproject](#1-start-a-new-tauri-project) - Or [add Tauri to existing\nproject](#1-add-tauri-to-existing-project) ### 1. Start a New Tauri Project\n```bash yarn create tauri-app #OR npx create-tauri-app ``` Just follow the\ninstructions and choose the web frontend framework you prefer.\n`create-tauri-app` will create a template project depends on your inputs. You\ncan go straight to [check `tauri\ninfo`](#3-check-tauri-info-to-make-sure-everything-is-set-up-properly) after\nthis. ### 1. Add Tauri to Existing Project: The Tauri CLI tool helps you build\nyour project, so install it at first. You can install Tauri CLI [using\n`Node.js`](#install-tauri-cli-package-as-a-dev-dependency) or [using\n`Rust`](#alternatively-install-tauri-cli-as-a-cargo-subcommand) #### Install\nTauri CLI package as a dev dependency: ```bash cd project-folder # Not required\nif you already have a package.json: # yarn init # OR # npm init yarn add -D\n@tauri-apps/cli # OR npm install -D @tauri-apps/cli ``` You can install Tauri as\nboth a local and a global dependency, but we recommend installing it locally. If\nyou decide to use Tauri as a local package with npm (not yarn), you will have to\ndefine a custom script to your package.json: ```js title=package.json { // This\ncontent is just a sample \"scripts\": { \"tauri\": \"tauri\" } } ``` ####\nAlternatively, install Tauri CLI as a cargo subcommand: This will install\n`tauri-cli` as a Cargo subcommand on the cargo binary folder (by default on\n`$HOME/.cargo/bin`): ```bash cargo install tauri-cli --locked --version\n^1.0.0-beta ``` For more installation options, see [`cargo\ninstall`](https://doc.rust-lang.org/cargo/commands/cargo-install.html#description)\n#### Install Tauri API Package as a Dependency (optional): The `@tauri-apps/api`\npackage is recommended for projects using ES modules or modern build tools such\nas Webpack or Vite. It is the most secure way to access the Tauri APIs. ```bash\nyarn add @tauri-apps/api # OR npm install @tauri-apps/api ``` ### 2. Initialize\nTauri in Your App This command will place a new folder in your current working\ndirectory, `src-tauri`. ```sh └── src-tauri ├── .gitignore ├── Cargo.toml ├──\nrustfmt.toml ├── tauri.conf.json ├── icons │ ├── 128x128.png │ ├──\n128x128@2x.png │ ├── 32x32.png │ ├── Square107x107Logo.png │ ├──\nSquare142x142Logo.png │ ├── Square150x150Logo.png │ ├── Square284x284Logo.png │\n├── Square30x30Logo.png │ ├── Square310x310Logo.png │ ├── Square44x44Logo.png │\n├── Square71x71Logo.png │ ├── Square89x89Logo.png │ ├── StoreLogo.png │ ├──\nicon.icns │ ├── icon.ico │ └── icon.png └── src ├── build.rs ├── cmd.rs └──\nmain.rs ``` ### 3. Check `tauri info` to Make Sure Everything Is Set up\nProperly: Which should return something like: ``` Operating System -\nDarwin(16.7.0) - darwin/x64 Node.js environment Node.js - 12.16.3\n@tauri-apps/cli - 1.0.0-beta.2 @tauri-apps/api - 1.0.0-beta.1 Global packages\nnpm - 6.14.4 yarn - 1.22.4 Rust environment rustc - 1.52.1 cargo - 1.52.0 App\ndirectory structure /node_modules /src-tauri /src /public App tauri.rs -\n1.0.0-beta.1 build-type - bundle CSP - default-src blob: data: filesystem: ws:\nwss: http: https: tauri: 'unsafe-eval' 'unsafe-inline' 'self' img-src: 'self'\ndistDir - ../public devPath - ../public framework - Svelte bundler - Rollup ```\nThis information can be very helpful when triaging problems. ### Patterns We've\nalso defined prebuilt configurations called \"Patterns\". They may help you to\ncustomize Tauri to fit your needs. [See more about\npatterns](/docs/guides/patterns/about-patterns). ## Vue CLI Plugin Tauri If you\nare using Vue CLI, it is recommended to use the official [CLI\nplugin](https://github.com/tauri-apps/vue-cli-plugin-tauri).","url":"https://tauri.studio/docs/development/integration"},{"id":"prose_docs_development_intro_md","title":"Introduction","area":"development","section":"development","headings":["Tauri Development Workflow"],"subHeadings":[],"code":[],"text":"This part of the documentation is dedicated to learning how to use Tauri. Tauri\nprovides a [CLI](/docs/api/cli), a Rust API, and a [JavaScript\nAPI](/docs/api/js/index) that you can use in your project. Because raw docs can\nbe quite scary to newcomers (especially people who have never played with Rust\nbefore), we've created this \"learn by example\" section. Here you will find\nguides and techniques to start a new project or add to your own project in order\nto fulfill your goals. ## Tauri Development Workflow - [Integrate With\nTauri](/docs/development/integration) - [Development\nCycle](/docs/development/development-cycle) -\n[Debugging](/docs/development/debugging) - [CI/CD](/docs/development/ci-cd) -\n[Cross-Platform Compilation](/docs/development/cross-platform) - [App\nPublishing](/docs/development/publishing) - [Updating\nPackages](/docs/development/updating)","url":"https://tauri.studio/docs/development/intro"},{"id":"prose_docs_development_publishing_md","title":"App Publishing","area":"development","section":"development","headings":[],"subHeadings":["1","2"],"code":[],"text":"import Alert from '@theme/Alert' import Command from '@theme/Command' ### 1.\nBuild Your Web App Now that you are ready to package your project, you will need\nto run your framework's or bundler's build command (assuming you're using one,\nof course). Every framework has its own publishing tooling. It is outside of the\nscope of this document to treat them all or keep them up to date. ### 2. Bundle\nyour application with Tauri This command will embed your web assets into a\nsingle binary with your Rust code. The binary itself will be located in\n`src-tauri/target/release/[app name]`, and installers will be located in\n`src-tauri/target/release/bundle/`. Like the `tauri dev` command, the first time\nyou run this, it will take some time to collect the Rust crates and build\neverything - but on subsequent runs it will only need to rebuild your code,\nwhich is much quicker.","url":"https://tauri.studio/docs/development/publishing"},{"id":"prose_docs_development_signing_macos_md","title":"Signing for macOS","area":"development","section":"development","headings":[],"subHeadings":[],"code":[],"text":"Signing for macOS","url":"https://tauri.studio/docs/development/signing-macos"},{"id":"prose_docs_development_updating_md","title":"Updating Packages","area":"development","section":"development","headings":["Automatic updates","Manual updates"],"subHeadings":["Update NPM Packages"],"code":[],"text":"import Alert from '@theme/Alert' Especially during the alpha and beta phases,\nyou are expected to keep all Tauri dependencies and toolchains up to date. There\nis no support for any versions other than latest. ## Automatic updates The Tauri\nJS CLI has a command to install and update all needed dependencies, just run\n`tauri deps install` or `tauri deps update`. ## Manual updates ### Update NPM\nPackages If you are using the `tauri` package: ```bash $ yarn upgrade\n@tauri-apps/cli @tauri-apps/api --latest $ npm install @tauri-apps/cli@latest\n@tauri-apps/api@latest ``` You can also detect what the latest version of Tauri\nis on the command line, using: - `npm outdated @tauri-apps/cli` - `yarn outdated\n@tauri-apps/cli` Alternatively, if you are using the `vue-cli-plugin-tauri`\napproach: ```bash $ yarn upgrade vue-cli-plugin-tauri --latest $ npm install\nvue-cli-plugin-tauri@latest ``` ### Update Cargo Packages Go to\n`src-tauri/Cargo.toml` and change `tauri` to `tauri = { version = \"%version%\" }`\nwhere `%version%` is the version number shown above. (You can just use the\n`MAJOR.MINOR`) version, like `0.9`. Then do the following: ```bash $ cd\nsrc-tauri $ cargo update -p tauri ``` You can also run `cargo outdated -r tauri`\nto get direct information about the core library's latest version.","url":"https://tauri.studio/docs/development/updating"},{"id":"prose_docs_get_started_intro_md","title":"Introduction","area":"get-started","section":"get-started","headings":["Steps"],"subHeadings":["Setting up Your Environment"],"code":[],"text":"import OSList from '@theme/OSList' Welcome to Tauri! Tauri is a polyglot and\ngeneric system that is very composable and allows engineers to make a wide\nvariety of applications. It is used for building applications for Desktop\nComputers using a combination of [Rust](https://www.rust-lang.org/) tools and\nHTML rendered in a Webview. Apps built with Tauri can ship with any number of\npieces of an optional JS API / Rust API so that webviews can control the system\nvia message passing. Anything that can be displayed on a website, can be\ndisplayed in a Tauri webview app! Developers are free to build the web front-end\ndisplayed in a Webview through Tauri with any web frameworks of their choice!\n**Developers can even extend the default API** with their own functionality and\nbridge the Webview and Rust-based backend easily! The Architecture is more fully\ndescribed in [Architecture](/docs/architecture). This guide will help you create\nyour first Tauri app. It should only take about 10 minutes, although it could\ntake longer if you have a slower internet connection. If you find an error or\nsomething unclear, or would like to propose an improvement, you have several\noptions: 1. Open an issue on our [Github\nRepo](https://github.com/tauri-apps/tauri-docs) 2. Visit our [Discord\nserver](https://discord.gg/tauri) and raise your concern 3. Request to join the\neducation working group on Discord to gain access to its discussion channel ##\nSteps 1. Install and configure system prerequisites 2. Create a web app with\nyour frontend framework of choice 3. Use the Tauri CLI to setup Tauri in your\napp 4. Write native Rust code to add functionality or improve performance\n(totally optional) 5. Use `tauri dev` to develop your app with features like hot\nmodule reloading and webview devtools 6. Use `tauri build` to package your app\ninto a tiny installer ### Setting up Your Environment Before creating an app,\nyou'll have to install and configure some developer tools. This guide assumes\nthat you know what the command line is, how to install packages on your\noperating system, and generally know your way around the development side of\ncomputing. Follow the platform-specific guides to get started: After that,\nyou'll be ready to [add Tauri to your project!](/docs/development/integration)","url":"https://tauri.studio/docs/get-started/intro"},{"id":"prose_docs_get_started_setup_linux_md","title":"Setup for Linux","area":"get-started","section":"get-started","headings":["1","2","3","4","Continue"],"subHeadings":["Optional dependencies","Node","Optional Node","WSL Version 1","WSL Version 2"],"code":["sh","bash"],"text":"import Alert from '@theme/Alert' import Icon from '@theme/Icon' import { Intro }\nfrom '@theme/SetupDocs' import Tabs from '@theme/Tabs'; import TabItem from\n'@theme/TabItem'; ## 1. System Dependencies  ```sh $ sudo apt update && sudo apt\ninstall libwebkit2gtk-4.0-dev \\ build-essential \\ curl \\ wget \\ libssl-dev \\\nlibgtk-3-dev \\ libappindicator3-dev \\ patchelf \\ librsvg2-dev ``` ```sh $ sudo\npacman -Syu && sudo pacman -S --needed \\ webkit2gtk \\ base-devel \\ curl \\ wget \\\nopenssl \\ appmenu-gtk-module \\ gtk3 \\ libappindicator-gtk3 \\ patchelf \\ librsvg\n\\ libvips ``` ```sh $ sudo dnf check-update && sudo dnf install\nwebkit2gtk3-devel.x86_64 \\ openssl-devel \\ curl \\ wget \\ libappindicator-gtk3 \\\npatchelf \\ librsvg2-devel \\ && sudo dnf group install \"C Development Tools and\nLibraries\" ``` ### Optional dependencies: - `libappindicator`: needed to use the\nsystem tray feature. - `patchelf` and `librsvg`: needed to bundle `AppImage`. ##\n2. Node.js Runtime and Package Manager  ### Node.js (npm included) We recommend\nusing nvm to manage your Node.js runtime. It allows you to easily switch\nversions and update Node.js. ```sh $ curl -o-\nhttps://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash ``` We\nhave audited this bash script, and it does what it says it is supposed to do.\nNevertheless, before blindly curl-bashing a script, it is always wise to look at\nit first. Here is the file as a mere download link\n[https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh]. Once nvm is\ninstalled, close and reopen your terminal, then install the latest version of\nNode.js and npm: ```sh $ nvm install node --latest-npm $ nvm use node ``` If you\nhave any problems with nvm, please consult their project readme\n[https://github.com/nvm-sh/nvm]. ### Optional Node.js Package Manager You may\nwant to use an alternative to npm: - Yarn [https://yarnpkg.com/getting-started],\nis preferred by Tauri's team - pnpm [https://pnpm.js.org/en/installation] ## 3.\nRustc and Cargo Package Manager  The following command will install rustup\n[https://rustup.rs/], the official installer for Rust\n[https://www.rust-lang.org/]. ```bash $ curl --proto '=https' --tlsv1.2 -sSf\nhttps://sh.rustup.rs | sh ``` We have audited this bash script, and it does what\nit says it is supposed to do. Nevertheless, before blindly curl-bashing a\nscript, it is always wise to look at it first. Here is the file as a mere\ndownload link [https://sh.rustup.rs]. To make sure that Rust has been installed\nsuccessfully, run the following command: ```sh $ rustc --version latest update\non 2019-12-19, rust version 1.40.0 ``` You may need to restart your terminal if\nthe command does not work. ## 4. For Windows Subsystem for Linux (WSL) Users  In\norder to run a graphical application with WSL, you need to download **one** of\nthese X servers: Xming, Cygwin X, and vcXsrv. Since vcXsrv has been used\ninternally, it's the one we recommend to install. ### WSL Version 1 Open the X\nserver and then run `export DISPLAY=:0` in the terminal. You should now be able\nto run any graphical application via the terminal. ### WSL Version 2 You'll need\nto run a command that is slightly more complex than WSL 1: `export DISPLAY=$(cat\n/etc/resolv.conf | grep nameserver | awk '{print $2}'):0` and you need to add\n`-ac` to the X server as an argument. Note: if for some reason this command\ndoesn't work you can use an alternative command such as: `export DISPLAY=$(cat\n/etc/resolv.conf | grep nameserver | sed 's/.* //g'):0` or you can manually find\nthe Address using `cat /etc/resolve.conf | grep nameserver`. Don't forget that\nyou'll have to use the \"export\" command anytime you want to use a graphical\napplication, for each newly opened terminal. You can download some examples to\ntry with `sudo apt-get install x11-apps`. xeyes is always a good one. It can be\nhandy when troubleshooting WSL issues. ## Continue Now that you have set up the\nLinux-specific dependencies for Tauri, learn how to [add Tauri to your\nproject](/docs/development/integration).","url":"https://tauri.studio/docs/get-started/setup-linux"},{"id":"prose_docs_get_started_setup_macos_md","title":"Setup for macOS","area":"get-started","section":"get-started","headings":["1","2","3","Continue"],"subHeadings":["Node","Optional Node"],"code":["sh",null],"text":"import Alert from '@theme/Alert' import { Intro } from '@theme/SetupDocs' import\nIcon from '@theme/Icon' ## 1. System Dependencies  You will need to have\nHomebrew [https://brew.sh/] installed to run the following command. ```sh $ brew\ninstall gcc ``` You will also need to make sure `xcode` is installed. ```sh $\nxcode-select --install ``` ## 2. Node.js Runtime and Package Manager  ###\nNode.js (npm included) We recommend using nvm to manage your Node.js runtime. It\nallows you to easily switch versions and update Node.js. ```sh $ curl -o-\nhttps://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash ``` We\nhave audited this bash script, and it does what it says it is supposed to do.\nNevertheless, before blindly curl-bashing a script, it is always wise to look at\nit first. Here is the file as a mere download link\n[https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh]. Once nvm is\ninstalled, close and reopen your terminal, then install the latest version of\nNode.js and npm: ```sh $ nvm install node --latest-npm $ nvm use node ``` If you\nhave any problems with nvm, please consult their project readme\n[https://github.com/nvm-sh/nvm]. ### Optional Node.js Package Manager You may\nwant to use an alternative to npm: - Yarn [https://yarnpkg.com/getting-started],\nis preferred by Tauri's team - pnpm [https://pnpm.js.org/en/installation] ## 3.\nRustc and Cargo Package Manager  The following command will install rustup\n[https://rustup.rs/], the official installer for Rust\n[https://www.rust-lang.org/]. ``` $ curl --proto '=https' --tlsv1.2 -sSf\nhttps://sh.rustup.rs | sh ``` We have audited this bash script, and it does what\nit says it is supposed to do. Nevertheless, before blindly curl-bashing a\nscript, it is always wise to look at it first. Here is the file as a mere\ndownload link [https://sh.rustup.rs]. To make sure that Rust has been installed\nsuccessfully, run the following command: ```sh $ rustc --version latest update\non 2019-12-19, rust version 1.40.0 ``` You may need to restart your terminal if\nthe command does not work. ## Continue Now that you have set up the\nmacOS-specific dependencies for Tauri, learn how to [add Tauri to your\nproject](/docs/development/integration).","url":"https://tauri.studio/docs/get-started/setup-macos"},{"id":"prose_docs_get_started_setup_windows_md","title":"Setup for Windows","area":"get-started","section":"get-started","headings":["1","2","3","4","Continue"],"subHeadings":["Node","Optional Node"],"code":["powershell"],"text":"import Alert from '@theme/Alert' import Icon from '@theme/Icon' import { Intro }\nfrom '@theme/SetupDocs' For those using the Windows Subsystem for Linux (WSL)\nplease refer to our [Linux specific instructions](/docs/get-started/setup-linux)\ninstead. ## 1. System Dependencies  You'll need to install Microsoft Visual\nStudio C++ build tools. Download the installer here\n[https://visualstudio.microsoft.com/visual-cpp-build-tools/], and then run it.\nWhen it asks you what packages you would like to install, select C++ Build Tools\nand make sure the Windows SDK is selected. This is a big download (over 1GB) and\ntakes the most time, so go grab a coffee. You may need to uninstall the 2017\nversion of the build tools if you have them. There are reports of Tauri not\nworking with both the 2017 and 2019 versions installed. ## 2. Node.js Runtime\nand Package Manager  ### Node.js (npm included) We recommend using nvm-windows\n[https://github.com/coreybutler/nvm-windows#installation--upgrades] to manage\nyour Node.js runtime. It allows you to easily switch versions and update\nNode.js. Then run the following from an Administrative PowerShell and press Y\nwhen prompted: ```powershell # BE SURE YOU ARE IN AN ADMINISTRATIVE PowerShell!\nnvm install latest nvm use {{latest}} # Replace with your latest downloaded\nversion ``` This will install the most recent version of Node.js with npm. ###\nOptional Node.js Package Manager You may want to use an alternative to npm: -\nYarn [https://yarnpkg.com/getting-started], is preferred by Tauri's team - pnpm\n[https://pnpm.js.org/en/installation] ## 3. Rustc and Cargo Package Manager  Now\nyou will need to install Rust [https://www.rust-lang.org/]. The easiest way to\ndo this is to use rustup [https://rustup.rs/], the official installer. - 64-bit\ndownload link [https://win.rustup.rs/x86_64] - 32-bit download link\n[https://win.rustup.rs/i686] Download and install the proper variant for your\ncomputer's architecture. ## 4. Install WebView2 WebView2 is pre-installed in\nWindows 11. Finally, you will need to install WebView2. The best way to do this\nis to download and run the Evergreen Bootstrapper from [this\npage](https://developer.microsoft.com/en-us/microsoft-edge/webview2/#download-section).\nIf you have problems of any kind after following these instructions, we\nrecommend that you reboot your computer before developing a Tauri project to\nensure that everything works as expected. ## Continue Now that you have set up\nthe Windows-specific dependencies for Tauri, learn how to [add Tauri to your\nproject](/docs/development/integration).","url":"https://tauri.studio/docs/get-started/setup-windows"},{"id":"prose_docs_guides_cli_md","title":"Make your own CLI","area":"guides","section":"guides","headings":["Base Configuration","Adding Arguments","Subcommands","Reading the matches","Complete documentation"],"subHeadings":["Positional Arguments","Named Arguments","Flag Arguments","Rust","JavaScript"],"code":["rust","js"],"text":"import Alert from '@theme/Alert' Tauri enables your app to have a CLI through\nclap [https://github.com/clap-rs/clap], a robust command line argument parser.\nWith a simple CLI definition in your `tauri.conf.json` file, you can define your\ninterface and read its argument matches map on JavaScript and/or Rust. ## Base\nConfiguration Under `tauri.conf.json`, you have the following structure to\nconfigure the interface: ```js title=src-tauri/tauri.conf.json { \"tauri\": {\n\"cli\": { \"description\": \"\", // command description that's shown on help\n\"longDescription\": \"\", // command long description that's shown on help\n\"beforeHelp\": \"\", // content to show before the help text \"afterHelp\": \"\", //\ncontent to show after the help text \"args\": [], // list of arguments of the\ncommand, we'll explain it later \"subcommands\": { \"subcommand-name\": { //\nconfigures a subcommand that is accessible // with `$ ./app subcommand-name\n--arg1 --arg2 --etc` // configuration as above, with \"description\", \"args\", etc.\n} } } } } ``` All JSON configurations here are just samples, many other fields\nhave been omitted for the sake of clarity. ## Adding Arguments The `args` array\nrepresents the list of arguments accepted by its command or subcommand. You can\nfind more details about the way to configure them here [/docs/api/config#tauri].\n### Positional Arguments A positional argument is identified by its position in\nthe list of arguments. With the following configuration: ```json\ntitle=src-tauri/tauri.conf.json:tauri.cli { \"args\": [ { \"name\": \"source\",\n\"index\": 1, \"takesValue\": true }, { \"name\": \"destination\", \"index\": 2,\n\"takesValue\": true } ] } ``` Users can run your app as `$ ./app tauri.txt\ndest.txt` and the arg matches map will define `source` as `\"tauri.txt\"` and\n`destination` as `\"dest.txt\"`. ### Named Arguments A named argument is a (key,\nvalue) pair where the key identifies the value. With the following\nconfiguration: ```json title=src-tauri/tauri.conf.json:tauri.cli { \"args\": [ {\n\"name\": \"type\", \"short\": \"t\", \"takesValue\": true, \"multiple\": true,\n\"possibleValues\": [\"foo\", \"bar\"] } ] } ``` Users can run your app as `$ ./app\n--type foo bar`, `$ ./app -t foo -t bar` or `$ ./app --type=foo,bar` and the arg\nmatches map will define `type` as `[\"foo\", \"bar\"]`. ### Flag Arguments A flag\nargument is a standalone key whose presence or absence provides information to\nyour application. With the following configuration: ```js\ntitle=src-tauri/tauri.conf.json:tauri.cli { \"args\": [ \"name\": \"verbose\",\n\"short\": \"v\", \"multipleOccurrences\": true ] } ``` Users can run your app as `$\n./app -v -v -v`, `$ ./app --verbose --verbose --verbose` or `$ ./app -vvv` and\nthe arg matches map will define `verbose` as `true`, with `occurrences = 3`. ##\nSubcommands Some CLI applications has additional interfaces as subcommands. For\ninstance, the `git` CLI has `git branch`, `git commit` and `git push`. You can\ndefine additional nested interfaces with the `subcommands` array: ```js\ntitle=src-tauri/tauri.conf.json:tauri { \"cli\": { ... \"subcommands\": { \"branch\":\n{ \"args\": [] }, \"push\": { \"args\": [] } } } } ``` Its configuration is the same\nas the root application configuration, with the `description`,\n`longDescription`, `args`, etc. ## Reading the matches ### Rust ```rust use\ntauri::api::cli::get_matches; fn main() { let context =\ntauri::generate_context!(); let cli_config =\ncontext.config().tauri.cli.clone().unwrap(); match get_matches(&cli_config) { //\n`matches` here is a Struct with { args, subcommand }. // `args` is `HashMap`\nwhere `ArgData` is a struct with { value, occurances }. // `subcommand` is\n`Option>` where `SubcommandMatches` is a struct with { name, matches }.\nOk(matches) => { println!(\"{:?}\", matches) } Err(_) => {} };\ntauri::Builder::default() .run(context) .expect(\"error while running tauri\napplication\"); } ``` ### JavaScript ```js import { getMatches } from\n'@tauri-apps/api/cli' getMatches().then((matches) => { // do something with the\n{ args, subcommand } matches }) ``` ## Complete documentation You can find more\nabout the CLI configuration here [/docs/api/config#tauri].","url":"https://tauri.studio/docs/guides/cli"},{"id":"prose_docs_guides_command_md","title":"Create Rust Commands","area":"guides","section":"guides","headings":["Basic Example","Passing Arguments","Returning Data","Error Handling","Async Commands","Accessing the Window in Commands","Accessing an AppHandle in Commands","Accessing managed state","Creating Multiple Commands","Complete Example"],"subHeadings":[],"code":["rust","js"],"text":"import Alert from '@theme/Alert' Tauri provides a simple yet powerful \"command\"\nsystem for calling Rust functions from your web app. Commands can accept\narguments and return values. They can also return errors and be `async`. ##\nBasic Example Commands are defined in your `src-tauri/src/main.rs` file. To\ncreate a command, just add a function and annotate it with `#[tauri::command]`:\n```rust #[tauri::command] fn my_custom_command() { println!(\"I was invoked from\nJS!\"); } ``` You will have to provide a list of your commands to the builder\nfunction like so: ```rust // Also in main.rs fn main() {\ntauri::Builder::default() // This is where you pass in your commands\n.invoke_handler(tauri::generate_handler![my_custom_command])\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ``` Now, you\ncan invoke the command from your JS code: ```js // With the Tauri API npm\npackage: import { invoke } from '@tauri-apps/api/tauri' // With the Tauri global\nscript, enabled when `tauri.conf.json > build > withGlobalTauri` is set to true:\nconst invoke = window.__TAURI__.invoke // Invoke the command\ninvoke('my_custom_command') ``` ## Passing Arguments Your command handlers can\ntake arguments: ```rust #[tauri::command] fn my_custom_command(invoke_message:\nString) { println!(\"I was invoked from JS, with this message: {}\",\ninvoke_message); } ``` Arguments should be passed as a JSON object with\ncamelCase keys: ```js invoke('my_custom_command', { invokeMessage: 'Hello!' })\n``` Arguments can be of any type, as long as they implement\n[serde::Deserialize](https://serde.rs/derive.html). ## Returning Data Command\nhandlers can return data as well: ```rust #[tauri::command] fn\nmy_custom_command() -> String { \"Hello from Rust!\".into() } ``` The `invoke`\nfunction returns a promise that resolves with the returned value: ```js\ninvoke('my_custom_command').then((message) => console.log(message)) ``` Returned\ndata can be of any type, as long as it implements\n[Serde::Serialize](https://serde.rs/derive.html). ## Error Handling If your\nhandler could fail and needs to be able to return an error, have the function\nreturn a `Result`: ```rust #[tauri::command] fn my_custom_command() -> Result {\n// If something fails Err(\"This failed!\".into()) // If it worked Ok(\"This\nworked!\".into()) } ``` If the command returns an error, the promise will reject,\notherwise it resolves: ```js invoke('my_custom_command') .then((message) =>\nconsole.log(message)) .catch((error) => console.error(error)) ``` ## Async\nCommands Async commands are executed on a separate thread using the async\nruntime [https://docs.rs/tauri/1.0.0-beta.8/tauri/async_runtime/fn.spawn.html].\nCommands without the async keyword are executed on the main thread, unless\ndefined with #[tauri::command(async)]. If your command needs to run\nasynchronously, simply declare it as `async`: ```rust #[tauri::command] async fn\nmy_custom_command() { // Call another async function and wait for it to finish\nlet result = some_async_function().await; println!(\"Result: {}\", result); } ```\nSince invoking the command from JS already returns a promise, it works just like\nany other command: ```js invoke('my_custom_command').then(() =>\nconsole.log('Completed!')) ``` ## Accessing the Window in Commands Commands can\naccess the `Window` instance that invoked the message: ```rust #[tauri::command]\nasync fn my_custom_command(window: tauri::Window) { println!(\"Window: {}\",\nwindow.label()); } ``` ## Accessing an AppHandle in Commands Commands can access\nan `AppHandle` instance: ```rust #[tauri::command] async fn\nmy_custom_command(app_handle: tauri::AppHandle) { let app_dir =\napp_handle.path_resolver().app_dir(); use tauri::GlobalShortcutManager;\napp_handle.global_shortcut_manager().register(\"CTRL + U\", move || {}); } ``` ##\nAccessing managed state Tauri can manage state using the `manage` function on\n`tauri::Builder`. The state can be accessed on a command using `tauri::State`:\n```rust struct MyState(String); #[tauri::command] fn my_custom_command(state:\ntauri::State) { assert_eq!(state.0 == \"some state value\", true); } fn main() {\ntauri::Builder::default() .manage(MyState(\"some state value\".into()))\n.invoke_handler(tauri::generate_handler![my_custom_command])\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ## Creating Multiple Commands The\n`tauri::generate_handler!` macro takes an array of commands. To register\nmultiple commands, you cannot call invoke_handler multiple times. Only the last\ncall will be used. You must pass each command to a single call of\n`tauri::generate_handler!`. ```rust #[tauri::command] fn cmd_a() -> String {\n\"Command a\" } #[tauri::command] fn cmd_b() -> String { \"Command b\" } fn main() {\ntauri::Builder::default() .invoke_handler(tauri::generate_handler![cmd_a,\ncmd_b]) .run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ## Complete Example Any or all of the above features can be\ncombined: ```rust title=main.rs // Definition in main.rs struct Database;\n#[derive(serde::Serialize)] struct CustomResponse { message: String, other_val:\nusize, } async fn some_other_function() -> Option { Some(\"response\".into()) }\n#[tauri::command] async fn my_custom_command( window: tauri::Window, number:\nusize, database: tauri::State<'_, Database>, ) -> Result { println!(\"Called from\n{}\", window.label()); let result: Option = some_other_function().await; if let\nSome(message) = result { Ok(CustomResponse { message, other_val: 42 + number, })\n} else { Err(\"No result\".into()) } } fn main() { tauri::Builder::default()\n.manage(Database {})\n.invoke_handler(tauri::generate_handler![my_custom_command])\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ```js // Invocation from JS invoke('my_custom_command', {\nnumber: 42, }) .then((res) => console.log(`Message: ${res.message}, Other Val:\n${res.other_val}`) ) .catch((e) => console.error(e)) ```","url":"https://tauri.studio/docs/guides/command"},{"id":"prose_docs_guides_contributor_guide_md","title":"Contributor Guide","area":"guides","section":"guides","headings":["Contribution Flow","Hands On Example"],"subHeadings":["A Note About Contributions to the Rust Libraries"],"code":["sh","json","ini"],"text":"todo: make this friendlier and more complete Tauri is a polyglot system that\nuses: - git - Node.js - Rust - GitHub actions It can be developed on macOS,\nLinux and Windows. ## Contribution Flow 1. File an Issue 2. Fork the Repository\n3. Make Your Changes 4. Make a PR ### A Note About Contributions to the Rust\nLibraries When contributing to the Rust libraries `tauri`, `tauri-api`, and\n`tauri-updater`; you will want to setup an environment for RLS (the Rust\nLanguage Server). In the Tauri root directory, there is a `.scripts` folder that\ncontains a set of scripts to automate adding a couple temporary environment\nvariables to your shell/terminal. These environment variables point to\ndirectories in the test fixture which will prevent RLS from crashing on\ncompile-time. This is a necessary step for setting up a development environment\nfor Tauri's Rust libraries. ##### _Example Instructions_ 1. Navigate to the\nTauri Root directory. 2. Execute a script based on your Operating System from\nthis folder: `.scripts/init_env.bat` for Windows Cmd, `.scripts/init_env.ps1`\nfor Windows Powershell, `. .scripts/init_env.sh` for Linux/macOS bash (note the\nfirst `.` in this command). 3. Open your text editor/IDE from this\nshell/terminal. ## Hands On Example Let's make a new example. That's a great way\nto learn. We are going to assume you are on a nixy type of environment like\nLinux or macOS and have all of your development dependencies like rust and node\nalready sorted out. ```sh git clone git@github.com:tauri-apps/tauri.git cd\ntauri/cli/tauri.js yarn mkdir ../../examples/vanillajs && cd \"$_\" ``` ```json\n\"tauri:source\": \"node ../../../cli/tauri.js/bin/tauri\", ``` ```ini\n[dependencies.tauri] path = \"../../../../core/tauri\" features = [ \"all-api\" ]\n```","url":"https://tauri.studio/docs/guides/contributor-guide"},{"id":"prose_docs_guides_events_md","title":"Events","area":"guides","section":"guides","headings":["Frontend","Backend"],"subHeadings":["Global events","Window","Global events","Window"],"code":["ts","rust"],"text":"The Tauri event system is a multi-producer multi-consumer communication\nprimitive that allows message passing between the frontend and the backend. It\nis analogous to the command system, but payload type check must be written on\nthe event handler and it simplifies communication from the backend to the\nfrontend, working like a channel. A Tauri application can listen and emit to\nglobal and window-specific events. Usage from the frontend and the backend are\ndescribed below. ## Frontend The event system is accessible on the frontend on\nthe `event` and `window` modules of the `@tauri-apps/api` package. ### Global\nevents To use the global event channel, import the `event` module and use the\n`emit` and `listen` functions: ```ts import { emit, listen } from\n'@tauri-apps/api/event' // listen to the `click` event and get a function to\nremove the event listener // there's also a `once` function that subscribes to\nan event and automatically unsubscribes the listener on the first event const\nunlisten = await listen('click', event => { // event.event is the event name\n(useful if you want to use a single callback fn for multiple event types) //\nevent.payload is the payload object }) // emits the `click` event with the\nobject payload emit('click', { theMessage: 'Tauri is awesome!' }) ``` ###\nWindow-specific events Window-specific events are exposed on the `window`\nmodule. ```ts import { appWindow, WebviewWindow } from '@tauri-apps/api/window'\n// emit an event that are only visible to the current window\nappWindow.emit('event', { message: 'Tauri is awesome!' }) // create a new\nwebview window and emit an event only to that window const webview = new\nWebviewWindow('window') webview.emit('event') ``` ## Backend On the backend, the\nglobal event channel is exposed on the `App` struct, and window-specific events\ncan be emitted using the `Window` trait. ### Global events ```rust use\ntauri::Manager; // the payload type must implement `Serialize`. // for global\nevents, it also must implement `Clone`. #[derive(Clone, serde::Serialize)]\nstruct Payload { message: String, } fn main() { tauri::Builder::default()\n.setup(|app| { // listen to the `event-name` (emitted on any window) let id =\napp.listen_global(\"event-name\", |event| { println!(\"got event-name with payload\n{:?}\", event.payload()); }); // unlisten to the event using the `id` returned on\nthe `listen_global` function // an `once_global` API is also exposed on the\n`App` struct app.unlisten(id); // emit the `event-name` event to all webview\nwindows on the frontend app.emit_all(\"event-name\", Payload { message: \"Tauri is\nawesome!\".into() }).unwrap(); Ok(()) }) .run(tauri::generate_context!())\n.expect(\"failed to run app\"); } ``` ### Window-specific events To use the\nwindow-specific event channel, a `Window` object can be obtained on a command\nhandler or with the `get_window` function: ```rust use tauri::{Manager, Window};\n// the payload type must implement `Serialize`. #[derive(serde::Serialize)]\nstruct Payload { message: String, } // init a background process on the command,\nand emit periodic events only to the window that used the command\n#[tauri::command] fn init_process(window: Window) { std::thread::spawn(move || {\nloop { window.emit(\"event-name\", Payload { message: \"Tauri is awesome!\".into()\n}).unwrap(); } }); } fn main() { tauri::Builder::default() .setup(|app| { //\n`main` here is the window label; it is defined on the window creation or under\n`tauri.conf.json` // the default value is `main`. note that it must be unique\nlet main_window = app.get_window(\"main\").unwrap(); // listen to the `event-name`\n(emitted on the `main` window) let id = main_window.listen(\"event-name\", |event|\n{ println!(\"got window event-name with payload {:?}\", event.payload()); }); //\nunlisten to the event using the `id` returned on the `listen` function // an\n`once` API is also exposed on the `Window` struct main_window.unlisten(id); //\nemit the `event-name` event to the `main` window main_window.emit(\"event-name\",\nPayload { message: \"Tauri is awesome!\".into() }).unwrap(); Ok(()) })\n.invoke_handler(tauri::generate_handler![init_process])\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ```","url":"https://tauri.studio/docs/guides/events"},{"id":"prose_docs_guides_icons_md","title":"Icons","area":"guides","section":"guides","headings":[],"subHeadings":[],"code":["sh","json"],"text":"import Command from '@theme/Command' import Alert from '@theme/Alert' Tauri\nships with a default iconset based on its logo. This is probably NOT what you\nwant when you ship your application. To remedy this common situation, Tauri\nprovides the `icon` command that will take an input file (\"./app-icon.png\" by\ndefault) and create all the icons needed for the various platforms: ```sh\nOptions --help, -h Displays this message --log, l Logging [boolean] --icon, i\nSource icon (png, 1240x1240 with transparency) --target, t Target folder\n(default: 'src-tauri/icons') --compression, c Compression type\n[pngquant|optipng|zopfli] ``` These will be placed in your `src-tauri/icons`\nfolder where they will automatically be included in your built app. If you need\nto source your icons from some other location, you can edit this part of the\n`src-tauri/tauri.conf.json` file: ```json { \"tauri\": { \"bundle\": { \"icon\": [\n\"icons/32x32.png\", \"icons/128x128.png\", \"icons/128x128@2x.png\",\n\"icons/icon.icns\", \"icons/icon.ico\" ] } } } ``` - icon.icns = macOS - icon.ico =\nMS Windows - \\*.png = Linux","url":"https://tauri.studio/docs/guides/icons"},{"id":"prose_docs_guides_menu_md","title":"Window Menu","area":"guides","section":"guides","headings":[],"subHeadings":["Creating a menu","Adding the menu to all windows","Adding the menu to a specific window","Listening to events on custom menu items","Updating menu items"],"code":["rust"],"text":"Native application menus can be attached to a window. ### Creating a menu To\ncreate a native window menu, import the `Menu`, `Submenu`, `MenuItem` and\n`CustomMenuItem` types. The `MenuItem` enum contains a collection of\nplatform-specific items (currently not implemented on Windows). The\n`CustomMenuItem` allows you to create your own menu items and add special\nfunctionality to them. ```rust use tauri::{CustomMenuItem, Menu, MenuItem,\nSubmenu}; ``` Create a `Menu` instance: ```rust // here `\"quit\".to_string()`\ndefines the menu item id, and the second parameter is the menu item label. let\nquit = CustomMenuItem::new(\"quit\".to_string(), \"Quit\"); let close =\nCustomMenuItem::new(\"close\".to_string(), \"Close\"); let submenu =\nSubmenu::new(\"File\", Menu::new().add_item(quit).add_item(close)); let menu =\nMenu::new() .add_native_item(MenuItem::Copy)\n.add_item(CustomMenuItem::new(\"hide\", \"Hide\")) .add_submenu(submenu); ``` ###\nAdding the menu to all windows The defined menu can be set to all windows using\nthe `menu` API on the `tauri::Builder` struct: ```rust use\ntauri::{CustomMenuItem, Menu, MenuItem, Submenu}; fn main() { let menu =\nMenu::new(); // configure the menu tauri::Builder::default() .menu(menu)\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Adding the menu to a specific window You can create a\nwindow and set the menu to be used. This allows defining a specific menu set for\neach application window. ```rust use tauri::{CustomMenuItem, Menu, MenuItem,\nSubmenu}; use tauri::WindowBuilder; fn main() { let menu = Menu::new(); //\nconfigure the menu tauri::Builder::default() .create_window(\n\"main-window\".to_string(), tauri::WindowUrl::App(\"index.html\".into()), move\n|window_builder, webview_attributes| { (window_builder.menu(menu),\nwebview_attributes) }, ) .run(tauri::generate_context!()) .expect(\"error while\nrunning tauri application\"); } ``` ### Listening to events on custom menu items\nEach `CustomMenuItem` triggers an event when clicked. Use the `on_menu_event`\nAPI to handle them, either on the global `tauri::Builder` or on an specific\nwindow. #### Listening to events on global menus ```rust use\ntauri::{CustomMenuItem, Menu, MenuItem}; fn main() { let menu = vec![]; //\ninsert the menu array here tauri::Builder::default() .menu(menu)\n.on_menu_event(|event| { match event.menu_item_id() { \"quit\" => {\nstd::process::exit(0); } \"close\" => { event.window().close().unwrap(); } _ => {}\n} }) .run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` #### Listening to events on window menus ```rust use\ntauri::{CustomMenuItem, Menu, MenuItem}; use tauri::{Manager, WindowBuilder}; fn\nmain() { let menu = vec![]; // insert the menu array here\ntauri::Builder::default() .create_window( \"main-window\".to_string(),\ntauri::WindowUrl::App(\"index.html\".into()), move |window_builder,\nwebview_attributes| { (window_builder.menu(menu), webview_attributes) }, )\n.setup(|app| { let window = app.get_window(\"main-window\").unwrap(); let window_\n= window.clone(); window.on_menu_event(move |event| { match\nevent.menu_item_id().as_str() { \"quit\" => { std::process::exit(0); } \"close\" =>\n{ window_.close().unwrap(); } _ => {} } }); Ok(()) })\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Updating menu items The `Window` struct has a\n`menu_handle` method, which allows updating menu items: ```rust fn main() {\ntauri::Builder::default() .setup(|app| { let main_window =\napp.get_window(\"main\").unwrap(); let menu_handle = main_window.menu_handle();\nstd::thread::spawn(move || { // you can also `set_selected`, `set_enabled` and\n`set_native_image` (macOS only). menu_handle.get_item(\"item_id\").set_title(\"New\ntitle\"); }) Ok(()) }) } ```","url":"https://tauri.studio/docs/guides/menu"},{"id":"prose_docs_guides_migration_md","title":"Migrating from 0.x","area":"guides","section":"guides","headings":["Commands"],"subHeadings":["Rust","JavaScript"],"code":["diff","rust","js"],"text":"First of all if you still have `tauri` as dependency in your `package.json`\nreplace it with a recent version of `@tauri-apps/cli` (make sure to also change\nthe import path in your JavaScript/TypeScript files, see\n[JavaScript](#javascript)). For example: ```diff - \"tauri\": \"^0.14.1\" +\n\"@tauri-apps/cli\": \"^1.0.0-beta-rc.4\" ``` Next update your `Cargo.toml`: - add\n`tauri-build` as a new build-dependency and remove `winres`, e.g.: ```diff +\n[build-dependencies] + tauri-build = { version = \"1.0.0-beta-rc.0\" } -\n[target.\"cfg(windows)\".build-dependencies] - winres = \"0.1\" ``` - update the\nversion of `tauri` to e.g. `1.0.0-beta-rc.4` - remove all old features of the\n`tauri` dependency - remove all features, that tauri added and add\n`custom-protocol` as a new one: ```diff [features] - embedded-server = [\n\"tauri/embedded-server\" ] - no-server = [ \"tauri/no-server\" ] + custom-protocol\n= [ \"tauri/custom-protocol\" ] + default = [ \"custom-protocol\" ] ``` Update your\n`tauri.conf.json` like this: - remove `ctx` - remove the `embeddedServer` -\nrename `osx` to `macOS` and add some fields: - `\"exceptionDomain\": \"\"` -\n`\"signingIdentity\": null` - `\"entitlements\": null` - remove the\n`exceptionDomain` - add a configuration for `windows`: -\n`\"certificateThumbprint\": null` - `\"digestAlgorithm\": \"sha256\"` -\n`\"timestampUrl\": \"\"` - make the `window` definition into an array and call it\n`windows` - remove `inliner` > for more information about the config see\n[here](../api/config.md) ```diff { - \"ctx\": {}, \"tauri\": { - \"embeddedServer\": {\n- \"active\": true - }, \"bundle\": { - \"osx\": { + \"macOS\": { \"frameworks\": [],\n\"minimumSystemVersion\": \"\", - \"useBootstrapper\": false + \"useBootstrapper\":\nfalse, + \"exceptionDomain\": \"\", + \"signingIdentity\": null, + \"entitlements\":\nnull }, - \"exceptionDomain\": \"\" + \"windows\": { + \"certificateThumbprint\": null,\n+ \"digestAlgorithm\": \"sha256\", + \"timestampUrl\": \"\" + } }, + \"updater\": { +\n\"active\": false + }, - \"window\": { + \"windows\": [ { \"title\": \"Calciumdibromid\",\n\"width\": 800, \"height\": 600, \"resizable\": true, \"fullscreen\": false } + ], -\n\"inliner\": { - \"active\": true - } } } ``` ## Commands The following example is\ntaken from the previous documentation. In the new version of Tauri there is no\ndistinction between synchronous and asynchronous commands, the only difference\nin your code is a call of `tauri::execute_promise()`, that isn't there in a\nsynchronous command. ### Rust Here is the complete example code of the \"old\"\nversion: ```rust use serde::{Deserialize, Serialize}; #[derive(Deserialize)]\nstruct DoSomethingPayload { state: String, data: u64, } #[derive(Deserialize)]\n#[serde(tag = \"cmd\", rename_all = \"camelCase\")] enum Cmd { DoSomething { count:\nu64, payload: DoSomethingPayload, callback: String, error: String, }, }\n#[derive(Serialize)] struct Response<'a> { value: u64, message: &'a str, }\n#[derive(Debug, Clone)] struct CommandError<'a> { message: &'a str, } impl<'a>\nCommandError<'a> { fn new(message: &'a str) -> Self { Self { message } } }\nimpl<'a> std::fmt::Display for CommandError<'a> { fn fmt(&self, f: &mut\nstd::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.message) } }\nimpl<'a> std::error::Error for CommandError<'a> {} fn main() {\ntauri::AppBuilder::new() .invoke_handler(|_webview, arg| { use Cmd::*; match\nserde_json::from_str(arg) { Err(e) => Err(e.to_string()), Ok(command) => { match\ncommand { DoSomething { count, payload, callback, error } =>\ntauri::execute_promise( _webview, move || { if count > 5 { let response =\nResponse { value: 5, message: \"async response!\", }; Ok(response) } else {\nErr(CommandError::new(\"count should be > 5\").into()) } }, callback, error, ), }\nOk(()) } } }) .build() .run(); } ``` Complete the following steps to migrate\nyour code: - create a new function for every `Cmd` enum variant - wrap the new\nfunction with the `#[tauri::command]` macro - use the fields of the enum as\narguments (`callback` and `error` can be deleted) - as function body use the\ncode inside the `match` block of the enum variant - add a return type - rename\n`AppBuilder` to `Builder` in `main()` - replace the big `invoke_handler` with\nthe new syntax The old example code should look like this now: ```rust use\nserde::{Deserialize, Serialize}; #[derive(Deserialize)] struct\nDoSomethingPayload { state: String, data: u64, } #[derive(Serialize)] struct\nResponse<'a> { value: u64, message: &'a str, } #[derive(Debug, Clone,\nSerialize)] struct CommandError<'a> { message: &'a str, } impl<'a>\nCommandError<'a> { fn new(message: &'a str) -> Self { Self { message } } }\nimpl<'a> std::fmt::Display for CommandError<'a> { fn fmt(&self, f: &mut\nstd::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.message) } }\nimpl<'a> std::error::Error for CommandError<'a> {} #[tauri::command] fn\ndo_something(count: u64, payload: DoSomethingPayload) -> Result { if count > 5 {\nlet response = Response { value: 5, message: \"async response!\", }; Ok(response)\n} else { Err(CommandError::new(\"count should be > 5\").into()) } } fn main() {\ntauri::Builder::new() .invoke_handler(tauri::generate_handler![do_something])\n.run(tauri::generate_context!()); } ``` ### JavaScript Like mentioned above\nthere is also no distinction between synchronous and asynchronous commands in\nJavaScript. You only have to use `invoke` and optionally use the results. Here\nis an example of the \"old\" code: ```js invoke({ cmd: 'doSomething', count: 5,\npayload: { state: 'some string data', data: 17 } }); promisified({ cmd:\n'doSomething', count: 5, payload: { state: 'some string data', data: 17 }\n}).then(response => { console.log(response); }).catch(error => {\nconsole.error(error); }); ``` Complete the following steps to migrate your code:\n- replace all `promisified`-calls with `invoke`-calls - extract the `cmd`\nattribute of the argument object as first parameter (you may have to rename it\nto `snake_case` as the `cmd` parameter is now the name of the function in Rust)\n- if you import parts of the tauri-api with `tauri/api/*` replace it with\n`@tauri-apps/api/*`, e.g.: ```diff - import { invoke } from 'tauri/api/tauri'; +\nimport { invoke } from '@tauri-apps/api/tauri'; ``` The old example code should\nlook like this now: ```js invoke( 'do_something', { count: 5, payload: { state:\n'some string data', data: 17 } } ); invoke( 'do_something', { count: 5, payload:\n{ state: 'some string data', data: 17 } } ).then(response => {\nconsole.log(response); }).catch(error => { console.error(error); }); ``` For\nmore information on commands read [Create Rust Commands](command.md).","url":"https://tauri.studio/docs/guides/migration"},{"id":"prose_docs_guides_multiwindow_md","title":"Multiwindow","area":"guides","section":"guides","headings":[],"subHeadings":[],"code":[],"text":"Manage multiple windows on a single application.","url":"https://tauri.studio/docs/guides/multiwindow"},{"id":"prose_docs_guides_plugin_md","title":"Write Tauri Plugins","area":"guides","section":"guides","headings":["Writing a Plugin","Using a plugin","Conventions","Official Tauri Plugins"],"subHeadings":[],"code":["rust"],"text":"import Alert from '@theme/Alert' Plugins allow you to hook into the Tauri\napplication lifecycle and introduce new commands. ## Writing a Plugin To write a\nplugin you just need to implement the `tauri::plugin::Plugin` trait: ```rust use\ntauri::{plugin::{Plugin, Result as PluginResult}, Runtime, PageLoadPayload,\nWindow, Invoke, AppHandle}; struct MyAwesomePlugin { invoke_handler: Box) + Send\n+ Sync>, // plugin state, configuration fields } // the plugin custom command\nhandlers if you choose to extend the API. #[tauri::command] // this will be\naccessible with `invoke('plugin:awesome|initialize')`. // where `awesome` is the\nplugin name. fn initialize() {} #[tauri::command] // this will be accessible\nwith `invoke('plugin:awesome|do_something')`. fn do_something() {} impl\nMyAwesomePlugin { // you can add configuration fields here, // see\nhttps://doc.rust-lang.org/1.0.0/style/ownership/builders.html pub fn new() ->\nSelf { Self { invoke_handler: Box::new(tauri::generate_handler![initialize,\ndo_something]), } } } impl Plugin for MyAwesomePlugin { /// The plugin name.\nMust be defined and used on the `invoke` calls. fn name(&self) -> &'static str {\n\"awesome\" } /// The JS script to evaluate on initialization. /// Useful when\nyour plugin is accessible through `window` /// or needs to perform a JS task on\napp initialization /// e.g. \"window.awesomePlugin = { ... the plugin interface\n}\" fn initialization_script(&self) -> Option { None } /// initialize plugin with\nthe config provided on `tauri.conf.json > plugins > $yourPluginName` or the\ndefault value. fn initialize(&mut self, app: &AppHandle, config:\nserde_json::Value) -> PluginResult<()> { Ok(()) } /// Callback invoked when the\nWindow is created. fn created(&mut self, window: Window) {} /// Callback invoked\nwhen the webview performs a navigation. fn on_page_load(&mut self, window:\nWindow, payload: PageLoadPayload) {} /// Extend the invoke handler. fn\nextend_api(&mut self, message: Invoke) { (self.invoke_handler)(message) } } ```\nNote that each function on the `Plugin` trait is optional, except the `name`\nfunction. ## Using a plugin To use a plugin, just pass an instance of the\n`MyAwesomePlugin` struct to the App's `plugin` method: ```rust fn main() { let\nawesome_plugin = MyAwesomePlugin::new(); tauri::Builder::default()\n.plugin(awesome_plugin) .run(tauri::generate_context!()) .expect(\"failed to run\napp\"); } ``` ## Conventions - Plugins should have a clear name with\n`tauri-plugin-` prefix. - Include `tauri-plugin` keyword in\n`Cargo.toml`/`package.json`. - Document your plugin in English. - Add an example\napp showcasing your plugin. ## Official Tauri Plugins -\n[Stronghold](https://github.com/tauri-apps/tauri-plugin-stronghold) -\n[Authenticator](https://github.com/tauri-apps/tauri-plugin-authenticator) -\n[Logging](https://github.com/tauri-apps/tauri-plugin-log) -\n[SQL](https://github.com/tauri-apps/tauri-plugin-sql) -\n[WebSocket](https://github.com/tauri-apps/tauri-plugin-websocket) - [Restoring\nwindow state](https://github.com/tauri-apps/tauri-plugin-window-state) -\n[Store](https://github.com/tauri-apps/tauri-plugin-store)","url":"https://tauri.studio/docs/guides/plugin"},{"id":"prose_docs_guides_splashscreen_md","title":"Splashscreen","area":"guides","section":"guides","headings":[],"subHeadings":["Setup","Waiting for Webpage","Waiting for Rust"],"code":["diff",null],"text":"import Link from '@docusaurus/Link' If your webpage could take some time to\nload, or if you need to run an initialization procedure in Rust before\ndisplaying your main window, a splashscreen could improve the loading experience\nfor the user. ### Setup First, create a `splashscreen.html` in your `distDir`\nthat contains the HTML code for a splashscreen. Then, update your\n`tauri.conf.json` like so: ```diff \"windows\": [ { \"title\": \"Tauri App\", \"width\":\n800, \"height\": 600, \"resizable\": true, \"fullscreen\": false, + \"visible\": false\n// Hide the main window by default }, // Add the splashscreen window + { +\n\"width\": 400, + \"height\": 200, + \"decorations\": false, + \"url\":\n\"splashscreen.html\", + \"label\": \"splashscreen\" + } ] ``` Now, your main window\nwill be hidden and the splashscreen window will show when your app is launched.\nNext, you'll need a way to close the splashscreen and show the main window when\nyour app is ready. How you do this depends on what you are waiting for before\nclosing the splashscreen. ### Waiting for Webpage If you are waiting for your\nweb code, you'll want to create a `close_splashscreen` [command](command.md).\n```rust title=src-tauri/main.rs use tauri::Manager; // Create the command:\n#[tauri::command] fn close_splashscreen(window: tauri::Window) { // Close\nsplashscreen if let Some(splashscreen) = window.get_window(\"splashscreen\") {\nsplashscreen.close().unwrap(); } // Show main window\nwindow.get_window(\"main\").unwrap().show().unwrap(); } // Register the command:\nfn main() { tauri::Builder::default() // Add this line\n.invoke_handler(tauri::generate_handler![close_splashscreen])\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ``` Then, you\ncan call it from your JS: ```js // With the Tauri API npm package: import {\ninvoke } from '@tauri-apps/api/tauri' // With the Tauri global script: const\ninvoke = window.__TAURI__.invoke document.addEventListener('DOMContentLoaded',\n() => { // This will wait for the window to load, but you could // run this\nfunction on whatever trigger you want invoke('close_splashscreen') }) ``` ###\nWaiting for Rust If you are waiting for Rust code to run, put it in the `setup`\nfunction handler so you have access to the `App` instance: ```rust\ntitle=src-tauri/main.rs use tauri::Manager; fn main() {\ntauri::Builder::default() .setup(|app| { let splashscreen_window =\napp.get_window(\"splashscreen\").unwrap(); let main_window =\napp.get_window(\"main\").unwrap(); // we perform the initialization code on a new\ntask so the app doesn't freeze tauri::async_runtime::spawn(async move { //\ninitialize your app here instead of sleeping :) println!(\"Initializing...\");\nstd::thread::sleep(std::time::Duration::from_secs(2)); println!(\"Done\ninitializing.\"); // After it's done, close the splashscreen and display the main\nwindow splashscreen_window.close().unwrap(); main_window.show().unwrap(); });\nOk(()) }) .run(tauri::generate_context!()) .expect(\"failed to run app\"); } ```","url":"https://tauri.studio/docs/guides/splashscreen"},{"id":"prose_docs_guides_system_tray_md","title":"System Tray","area":"guides","section":"guides","headings":[],"subHeadings":["Setup","Creating a system tray","Configuring a system tray context menu","Configure the app system tray","Listening to system tray events","Updating system tray"],"code":["json","rust"],"text":"Native application system tray. ### Setup Configure the `systemTray` object on\n`tauri.conf.json`: ```json { \"tauri\": { \"systemTray\": { \"iconPath\":\n\"icons/icon.png\", \"iconAsTemplate\": true } } } ``` The `iconPath` is pointed to\na PNG file on macOS and Linux, and a `.ico` file must exist for Windows support.\nThe `iconAsTemplate` is a boolean value that determines whether the image\nrepresents a\n[template](https://developer.apple.com/documentation/appkit/nsimage/1520017-template?language=objc)\nimage on macOS. ### Creating a system tray To create a native system tray,\nimport the `SystemTray` type: ```rust use tauri::SystemTray; ``` Initialize a\nnew tray instance: ```rust let tray = SystemTray::new(); ``` ### Configuring a\nsystem tray context menu Optionally you can add a context menu that is visible\nwhen the tray icon is right clicked. Import the `SystemTrayMenu`,\n`SystemTrayMenuItem` and `CustomMenuItem` types: ```rust use\ntauri::{CustomMenuItem, SystemTrayMenu, SystemTrayMenuItem}; ``` Create the\n`SystemTrayMenu`: ```rust // here `\"quit\".to_string()` defines the menu item id,\nand the second parameter is the menu item label. let quit =\nCustomMenuItem::new(\"quit\".to_string(), \"Quit\"); let hide =\nCustomMenuItem::new(\"hide\".to_string(), \"Hide\"); let tray_menu =\nSystemTrayMenu::new() .add_item(quit)\n.add_native_item(SystemTrayMenuItem::Separator) .add_item(hide); ``` Add the\ntray menu to the `SystemTray` instance: ```rust let tray =\nSystemTray::new().with_menu(tray_menu); ``` ### Configure the app system tray\nThe created `SystemTray` instance can be set using the `system_tray` API on the\n`tauri::Builder` struct: ```rust use tauri::{CustomMenuItem, SystemTray,\nSystemTrayMenu}; fn main() { let tray_menu = SystemTrayMenu::new(); // insert\nthe menu items here let system_tray = SystemTray::new() .with_menu(tray_menu);\ntauri::Builder::default() .system_tray(system_tray)\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Listening to system tray events Each `CustomMenuItem`\ntriggers an event when clicked. Also, Tauri emits tray icon click events. Use\nthe `on_system_tray_event` API to handle them: ```rust use\ntauri::{CustomMenuItem, SystemTray, SystemTrayMenu}; use tauri::Manager; fn\nmain() { let tray_menu = SystemTrayMenu::new(); // insert the menu items here\ntauri::Builder::default() .system_tray(SystemTray::new().with_menu(tray_menu))\n.on_system_tray_event(|app, event| match event { SystemTrayEvent::LeftClick {\nposition: _, size: _, .. } => { println!(\"system tray received a left click\"); }\nSystemTrayEvent::RightClick { position: _, size: _, .. } => { println!(\"system\ntray received a right click\"); } SystemTrayEvent::DoubleClick { position: _,\nsize: _, .. } => { println!(\"system tray received a double click\"); }\nSystemTrayEvent::MenuItemClick { id, .. } => { match id.as_str() { \"quit\" => {\nstd::process::exit(0); } \"hide\" => { let window =\napp.get_window(\"main\").unwrap(); window.hide().unwrap(); } _ => {} } } _ => {}\n}) .run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Updating system tray The `AppHandle` struct has a\n`tray_handle` method, which returns a handle to the system tray allowing\nupdating tray icon and context menu items: #### Updating context menu items\n```rust use tauri::{CustomMenuItem, SystemTray, SystemTrayMenu}; use\ntauri::Manager; fn main() { let tray_menu = SystemTrayMenu::new(); // insert the\nmenu items here tauri::Builder::default()\n.system_tray(SystemTray::new().with_menu(tray_menu)) .on_system_tray_event(|app,\nevent| match event { SystemTrayEvent::MenuItemClick { id, .. } => { // get a\nhandle to the clicked menu item // note that `tray_handle` can be called\nanywhere, // just get a `AppHandle` instance with `app.handle()` on the setup\nhook // and move it to another function or thread let item_handle =\napp.tray_handle().get_item(&id); match id.as_str() { \"hide\" => { let window =\napp.get_window(\"main\").unwrap(); window.hide().unwrap(); // you can also\n`set_selected`, `set_enabled` and `set_native_image` (macOS only).\nitem_handle.set_title(\"Show\").unwrap(); } _ => {} } } _ => {} })\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` #### Updating tray icon Note that `tauri::Icon` must be a\n`Path` variant on Linux, and `Raw` variant on Windows and macOS. ```rust\napp.tray_handle().set_icon(tauri::Icon::Raw(include_bytes!(\"../path/to/myicon.ico\"))).unwrap();\n```","url":"https://tauri.studio/docs/guides/system-tray"},{"id":"prose_docs_guides_updater_md","title":"Updater","area":"guides","section":"guides","headings":["Update Requests","Built","Javascript API","Events","Update Server JSON Format","Update File JSON Format","macOS","Windows","Linux"],"subHeadings":["Initialize updater and check if a new version is available","Listen New Update Available","Emit Install and Download","Listen Install Progress"],"code":["js","json","none","bash"],"text":"# Configuration Once you have your Tauri project ready, you need to configure\nthe updater. Add this in tauri.conf.json ```json \"updater\": { \"active\": true,\n\"endpoints\": [ \"https://releases.myapp.com/{{target}}/{{current_version}}\" ],\n\"dialog\": true, \"pubkey\": \"\" } ``` The required keys are \"active\" and\n\"endpoints\", others are optional. \"active\" must be a boolean. By default, it's\nset to false. \"endpoints\" must be an array. The string `{{target}}` and\n`{{current_version}}` are automatically replaced in the URL allowing you\ndetermine [server-side](#update-server-json-format) if an update is available.\nIf multiple endpoints are specified, the updater will fallback if a server is\nnot responding within the pre-defined timeout. \"dialog\" if present must be a\nboolean. By default, it's set to true. If enabled, [events](#events) are\nturned-off as the updater will handle everything. If you need the custom events,\nyou MUST turn off the built-in dialog. \"pubkey\" if present must be a valid\npublic-key generated with Tauri cli. See [Signing updates](#signing-updates). ##\nUpdate Requests Tauri is indifferent to the request the client application\nprovides for update checking. `Accept: application/json` is added to the request\nheaders because Tauri is responsible for parsing the response. For the\nrequirements imposed on the responses and the body format of an update, response\nsee [Server Support](#server-support). Your update request must *at least*\ninclude a version identifier so that the server can determine whether an update\nfor this specific version is required. It may also include other identifying\ncriteria such as operating system version, to allow the server to deliver as\nfine-grained an update as you would like. How you include the version identifier\nor other criteria is specific to the server that you are requesting updates\nfrom. A common approach is to use query parameters,\n[Configuration](#configuration) shows an example of this. ## Built-in dialog By\ndefault, updater uses a built-in dialog API from Tauri. ![New\nUpdate](https://i.imgur.com/UMilB5A.png) The dialog release notes is represented\nby the update `note` provided by the [server](#server-support). If the user\naccepts, the download and install are initialized. The user will be then\nprompted to restart the application. ## Javascript API **Attention, you need to\n_disable built-in dialog_ in your [tauri configuration](#configuration),\notherwise, events aren't emitted and the javascript API will NOT work.** ```js\nimport { checkUpdate, installUpdate } from \"@tauri-apps/api/updater\"; import {\nrelaunch } from \"@tauri-apps/api/process\"; try { const {shouldUpdate, manifest}\n= await checkUpdate(); if (shouldUpdate) { // display dialog await\ninstallUpdate(); // install complete, restart app await relaunch(); } }\ncatch(error) { console.log(error); } ``` ## Events **Attention, you need to\n_disable built-in dialog_ in your [tauri configuration](#configuration),\notherwise, events aren't emitted.** To know when an update is ready to be\ninstalled, you can subscribe to these events: ### Initialize updater and check\nif a new version is available #### If a new version is available, the event\n`tauri://update-available` is emitted. Event: `tauri://update` ### Rust ```rust\nwindow.emit(\"tauri://update\".to_string(), None); ``` ### Javascript ```js import\n{ emit } from \"@tauri-apps/api/event\"; emit(\"tauri://update\"); ``` ### Listen\nNew Update Available Event: `tauri://update-available` Emitted data: ```none\nversion Version announced by the server date Date announced by the server body\nNote announced by the server ``` ### Rust ```rust\nwindow.listen(\"tauri://update-available\".to_string(), move |msg| { println!(\"New\nversion available: {:?}\", msg); }) ``` ### Javascript ```js import { listen }\nfrom \"@tauri-apps/api/event\"; listen(\"tauri://update-available\", function (res)\n{ console.log(\"New version available: \", res); }); ``` ### Emit Install and\nDownload You need to emit this event to initialize the download and listen to\nthe [install progress](#listen-install-progress). Event:\n`tauri://update-install` ### Rust ```rust\nwindow.emit(\"tauri://update-install\".to_string(), None); ``` ### Javascript\n```js import { emit } from \"@tauri-apps/api/event\";\nemit(\"tauri://update-install\"); ``` ### Listen Install Progress Event:\n`tauri://update-status` Emitted data: ```none status [ERROR/PENDING/DONE] error\nString/null ``` PENDING is emitted when the download is started and DONE when\nthe install is complete. You can then ask to restart the application. ERROR is\nemitted when there is an error with the updater. We suggest to listen to this\nevent even if the dialog is enabled. ### Rust ```rust\nwindow.listen(\"tauri://update-status\".to_string(), move |msg| { println!(\"New\nstatus: {:?}\", msg); }) ``` ### Javascript ```js import { listen } from\n\"@tauri-apps/api/event\"; listen(\"tauri://update-status\", function (res) {\nconsole.log(\"New status: \", res); }); ``` # Server Support Your server should\ndetermine whether an update is required based on the [Update\nRequest](#update-requests) your client issues. If an update is required your\nserver should respond with a status code of [200\nOK](http://tools.ietf.org/html/rfc2616#section-10.2.1) and include the [update\nJSON](#update-server-json-format) in the body. To save redundantly downloading\nthe same version multiple times your server must not inform the client to\nupdate. If no update is required your server must respond with a status code of\n[204 No Content](http://tools.ietf.org/html/rfc2616#section-10.2.5). ## Update\nServer JSON Format When an update is available, Tauri expects the following\nschema in response to the update request provided: ```json { \"url\":\n\"https://mycompany.example.com/myapp/releases/myrelease.tar.gz\", \"version\":\n\"0.0.1\", \"notes\": \"Theses are some release notes\", \"pub_date\":\n\"2020-09-18T12:29:53+01:00\", \"signature\": \"\" } ``` The only required keys are\n\"url\" and \"version\", the others are optional. \"pub_date\" if present must be\nformatted according to ISO 8601. \"signature\" if present must be a valid\nsignature generated with Tauri cli. See [Signing updates](#signing-updates). ##\nUpdate File JSON Format The alternate update technique uses a plain JSON file\nmeaning you can store your update metadata on S3, gist, or another static file\nstore. Tauri will check against the name/version field and if the version is\nsmaller than the current one and the platform is available, the update will be\ntriggered. The format of this file is detailed below: ```json { \"name\":\"v1.0.0\",\n\"notes\":\"Test version\", \"pub_date\":\"2020-06-22T19:25:57Z\", \"platforms\": {\n\"darwin\": { \"signature\":\"\",\n\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.app.tar.gz\"\n}, \"linux\": { \"signature\":\"\",\n\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.AppImage.tar.gz\"\n}, \"win64\": { \"signature\":\"\",\n\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.x64.msi.zip\"\n} } } ``` # Bundler (Artifacts) The Tauri bundler will automatically generate\nupdate artifacts if the updater is enabled in `tauri.conf.json` If the bundler\ncan locate your private and pubkey, your update artifacts will be automatically\nsigned. The signature can be found in the `sig` file. The signature can be\nuploaded to GitHub safely or made public as long as your private key is secure.\nYou can see how it's [bundled with the\nCI](https://github.com/tauri-apps/tauri/blob/5b6c7bb6ee3661f5a42917ce04a89d94f905c949/.github/workflows/artifacts-updater.yml#L44)\nand a [sample\ntauri.conf.json](https://github.com/tauri-apps/tauri/blob/5b6c7bb6ee3661f5a42917ce04a89d94f905c949/examples/updater/src-tauri/tauri.conf.json#L52)\n## macOS On MACOS we create a .tar.gz from the whole application. (.app) ```none\ntarget/release/bundle └── osx └── app.app └── app.app.tar.gz (update bundle) └──\napp.app.tar.gz.sig (if signature enabled) ``` ## Windows On Windows we create a\n.zip from the MSI, when downloaded and validated, we run the MSI install.\n```none target/release └── app.x64.msi └── app.x64.msi.zip (update bundle) └──\napp.x64.msi.zip.sig (if signature enabled) ``` ## Linux On Linux, we create a\n.tar.gz from the AppImage. ```none target/release/bundle └── appimage └──\napp.AppImage └── app.AppImage.tar.gz (update bundle) └── app.AppImage.tar.gz.sig\n(if signature enabled) ``` # Signing updates We offer a built-in signature to\nensure your update is safe to be installed. To sign your updates, you need two\nthings. The *Public-key* (pubkey) should be added inside your `tauri.conf.json`\nto validate the update archive before installing. The *Private key* (privkey) is\nused to sign your update and should NEVER be shared with anyone. Also, if you\nlost this key, you'll NOT be able to publish a new update to the current user\nbase (if pubkey is set in tauri.conf.json). It's important to save it at a safe\nplace and you can always access it. To generate your keys you need to use the\nTauri cli. ```bash tauri sign -g -w ~/.tauri/myapp.key ``` You have multiple\noptions available ```bash Tauri updates signer. USAGE: tauri sign [FLAGS]\n[OPTIONS] FLAGS: --force Overwrite private key even if it exists on the\nspecified path -g, --generate Generate keypair to sign files -h, --help Prints\nhelp information --no-password Set empty password for your private key -V,\n--version Prints version information OPTIONS: -p, --password Set private key\npassword when signing -k, --private-key Load the private key from a string -f,\n--private-key-path Load the private key from a file --sign-file Sign the\nspecified file -w, --write-keys Write private key to a file ``` *** Environment\nvariables used to sign with the Tauri `bundler`: If they are set, and\n`tauri.conf.json` expose the public key, the bundler will automatically generate\nand sign the updater artifacts. `TAURI_PRIVATE_KEY` Path or String of your\nprivate key `TAURI_KEY_PASSWORD` Your private key password (optional)","url":"https://tauri.studio/docs/guides/updater"},{"id":"prose_docs_guides_window_customization_md","title":"Window Customization","area":"guides","section":"guides","headings":["Configuration","Creating a Custom Titlebar"],"subHeadings":["CSS","HTML","JS"],"code":["css","html","js"],"text":"` tag: ```html\nminimize [https://api.iconify.design/mdi:window-minimize.svg]\nmaximize [https://api.iconify.design/mdi:window-maximize.svg]\nclose [https://api.iconify.design/mdi:close.svg]\n``` Note that you may need to move the rest of your content down so that the\ntitlebar doesn't cover it. ### JS Finally, you'll need to make the buttons work:\n```js import { appWindow } from '@tauri-apps/api/window' document\n.getElementById('titlebar-minimize') .addEventListener('click', () =>\nappWindow.minimize()) document .getElementById('titlebar-maximize')\n.addEventListener('click', () => appWindow.toggleMaximize()) document\n.getElementById('titlebar-close') .addEventListener('click', () =>\nappWindow.close()) ```","url":"https://tauri.studio/docs/guides/window-customization"},{"id":"prose_docs_guides_bundler_anti_bloat_md","title":"Anti Bloat","area":"guides","section":"bundler","headings":[],"subHeadings":["Rust Compression Features","Stripping","Allowlist config","UPX"],"code":[null,"json"],"text":"import Alert from '@theme/Alert' The following links have tutorials on reducing\nthe size of your installers: - https://github.com/RazrFalcon/cargo-bloat -\nhttps://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html -\nhttps://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections ###\nRust Compression Features Add this to your `src-tauri/Cargo.toml`\n[profile.release] panic = \"abort\" codegen-units = 1 lto = true incremental =\nfalse opt-level = \"s\" There is also `opt-level = \"z\"` available to try to reduce\nthe resulting binary size. `\"s\"` and `\"z\"` can sometimes be smaller than the\nother, so test it with your own application! We've seen smaller binary sizes\nfrom `\"s\"` for Tauri example applications, but real world applications can\nalways differ. #### Unstable Rust Compression Features The following suggestions\nare all unstable features and require a nightly toolchain. See the Unstable\nFeatures\n[https://doc.rust-lang.org/cargo/reference/unstable.html#unstable-features]\ndocumentation for more information of what this involves. The following methods\ninvolve using unstable compiler features and require having a rust nightly\ntoolchain installed. If you don't have the nightly toolchain + `rust-src`\nnightly component added, try the following: $ rustup toolchain install nightly $\nrustup component add rust-src --toolchain nightly The Rust Standard Library\ncomes precompiled. You can instead apply the optimization options used for the\nrest of your binary + dependencies to the std with an unstable flag. This flag\nrequires specifying your target, so know the target triple that you are\ntargeting. $ cargo +nightly build --release -Z build-std --target\nx86_64-unknown-linux-gnu If you are using `panic = \"abort\"` in your release\nprofile optimizations, then you need to make sure the `panic_abort` crate is\ncompiled with std. Additionally, an extra std feature can be used to further\nreduce the binary size. The following applies both: $ cargo +nightly build\n--release -Z build-std=std,panic_abort -Z\nbuild-std-features=panic_immediate_abort --target x86_64-unknown-linux-gnu See\nthe unstable documentation for more details about [`-Z\nbuild-std`](https://doc.rust-lang.org/cargo/reference/unstable.html#build-std)\nand [`-Z\nbuild-std-features`](https://doc.rust-lang.org/cargo/reference/unstable.html#build-std-features).\n### Stripping Binary size can easily be reduced by stripping out debugging\ninformation from binaries that ship to end users. This is not good for\ndebuggable builds, but means good binary size savings for end user binaries. The\neasiest way is to use the famous `strip` utility to remove this debugging\ninformation. $ strip target/release/my_application See your local `strip`\nmanpage for more information and flags that can be used to specify what\ninformation gets stripped out from the binary. ### Allowlist config You can also\nreduce the application size with the `allowlist` config, and only enabling what\nyou need. Sometimes this is useful with Tauri's\n[Bridge-Pattern](/docs/guides/patterns/bridge) or others, depending on needs.\nFor example in `tauri.conf.json` file: ```json { \"tauri\": { \"allowlist\": {\n\"all\": false, \"fs\": { \"writeFile\": true, \"writeBinaryFile\": true }, \"shell\": {\n\"execute\": true }, \"dialog\": { \"save\": true } } } } ``` ### UPX UPX, **Ultimate\nPacker for eXecutables**, is a dinosaur amongst the binary packers. This 23-year\nold, well-maintained piece of kit is GPL-v2 licensed with a pretty liberal usage\ndeclaration. Our understanding of the licensing is that you can use it for any\npurposes (commercial or otherwise) without needing to change your license unless\nyou modify the source code of UPX. Basically it compresses the binary and\ndecompresses it at runtime. It should work for pretty much any binary type out\nthere. Read more: https://github.com/upx/upx You should know that this technique\nmight flag your binary as a virus on Windows and macOS - so use at your own\ndiscretion, and as always validate with [Frida](https://frida.re/docs/home/) and\ndo real distribution testing! #### Usage on macOS $ brew install upx $ yarn\ntauri build $ upx --ultra-brute\nsrc-tauri/target/release/bundle/macos/app.app/Contents/macOS/app Ultimate Packer\nfor eXecutables Copyright (C) 1996 - 2018 UPX 3.95 Markus Oberhumer, Laszlo\nMolnar & John Reiser Aug 26th 2018 File size Ratio Format Name\n-------------------- ------ ----------- ----------- 963140 -> 274448 28.50%\nmacho/amd64 app","url":"https://tauri.studio/docs/guides/bundler/anti-bloat"},{"id":"prose_docs_guides_bundler_debian_md","title":"Debian packages","area":"guides","section":"bundler","headings":[],"subHeadings":[],"code":["json"],"text":"import Alert from '@theme/Alert' Tauri allows your app to be packaged as a\n`.deb` (Debian package) file. # Bootstrapper Instead of launching the app\ndirectly, you can configure the bundled app to run a script that tries to expose\nthe environment variables to the app; without that you'll have trouble using\nsystem programs because the `PATH` environment variable isn't correct. Enable it\nwith the `useBootstrapper` [/docs/api/config#tauri.bundle.deb.useBootstrapper]\nconfig. # Custom files To include custom files to the debian package, you can\nconfigure a mapping on `tauri.conf.json > tauri > bundle > deb > files` as\nfollows: ```json { \"tauri\": { \"bundle\": { \"deb\": { \"files\": {\n\"/usr/lib/README.md\": \"../README.md\", // copies the README.md file to\n/usr/lib/README.md \"usr/lib/assets\": \"../public/\" // copies the entire public\ndirectory to /usr/lib/assets } } } } } ``` Each `files` object key is the path\non the debian package, and the value is a path to a file or directory relative\nto the `tauri.conf.json` file.","url":"https://tauri.studio/docs/guides/bundler/debian"},{"id":"prose_docs_guides_bundler_introduction_md","title":"Introduction","area":"guides","section":"bundler","headings":[],"subHeadings":[],"code":[],"text":"The Tauri Bundler is a Rust harness for compiling your binary, packaging assets,\nand preparing a final bundle. It will detect your operating system and build a\nbundle accordingly. It currently supports: - Linux: .deb, .appimage - macOS:\n.app, .dmg - Windows: .exe, .msi","url":"https://tauri.studio/docs/guides/bundler/introduction"},{"id":"prose_docs_guides_bundler_sidecar_md","title":"Sidecar (Embedding External Binaries)","area":"guides","section":"bundler","headings":["Running the sidecar binary on JavaScript","Running the sidecar binary on Rust","Using Node"],"subHeadings":[],"code":["json","bash","javascript","rust"],"text":"import Alert from '@theme/Alert' You may need to embed depending binaries in\norder to make your application work or to prevent users having to install\nadditional dependencies (e.g. Node.js, Python, etc). To bundle the binaries of\nyour choice, you can add the `externalBin` property to the `tauri > bundle`\nobject in your `tauri.conf.json`. See more about tauri.conf.json configuration\nhere [/docs/api/config#tauri.bundle]. `externalBin` expects a list of strings\ntargeting binaries either with absolute or relative paths. Here is a sample to\nillustrate the configuration, this is not a complete `tauri.conf.json` file:\n```json { \"tauri\": { \"bundle\": { \"externalBin\": [\"/absolute/path/to/app\",\n\"relative/path/to/binary\", \"bin/python\"] } } } ``` A binary with the same name\nand a `-$TARGET_TRIPLE` suffix must exist on the specified path. For instance,\n`\"externalBin\": [\"bin/python\"]` requires a\n`src-tauri/bin/python-x86_64-unknown-linux-gnu` executable on Linux. You can\nfind the current platform's target triple running the following command: ```bash\nrustc -Vv | grep host | cut -f2 -d' ' ``` Here's a Node.js script to append the\ntarget triple to a binary: ```javascript const execa = require('execa') const fs\n= require('fs') let extension = '' if (process.platform === 'win32') { extension\n= '.exe' } async function main() { const rustInfo = (await execa('rustc',\n['-vV'])).stdout const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1] if\n(!targetTriple) { console.error('Failed to determine platform target triple') }\nfs.renameSync( `src-tauri/binaries/app${extension}`,\n`src-tauri/binaries/app-${targetTriple}${extension}` ) } main().catch((e) => {\nthrow e }) ``` ## Running the sidecar binary on JavaScript On the JavaScript\ncode, import the `Command` class on the `shell` module and use the `sidecar`\nstatic method: ```javascript import { Command } from '@tauri-apps/api/shell' //\nalternatively, use `window.__TAURI__.shell.Command` // `my-sidecar` is the value\nspecified on `tauri.conf.json > tauri > bundle > externalBin` const command =\nCommand.sidecar('my-sidecar') const output = await command.execute() ``` ##\nRunning the sidecar binary on Rust On the Rust code, import the `Command` struct\nfrom the `tauri::api::process` module: ```rust let (mut rx, mut child) =\nCommand::new_sidecar(\"my-sidecar\") .expect(\"failed to create `my-sidecar` binary\ncommand\") .spawn() .expect(\"Failed to spawn sidecar\");\ntauri::async_runtime::spawn(async move { // read events such as stdout while let\nSome(event) = rx.recv().await { if let CommandEvent::Stdout(line) = event {\nwindow .emit(\"message\", Some(format!(\"'{}'\", line))) .expect(\"failed to emit\nevent\"); // write to stdin child.write(\"message from\nRust\\n\".as_bytes()).unwrap(); } } }); ``` ## Using Node.js on a sidecar The\nTauri [sidecar\nexample](https://github.com/tauri-apps/tauri/tree/dev/examples/sidecar)\ndemonstrates how to use the sidecar API to run a Node.js application on Tauri.\nIt compiles the Node.js code using [pkg](https://github.com/vercel/pkg) and uses\nthe scripts above to run it.","url":"https://tauri.studio/docs/guides/bundler/sidecar"},{"id":"prose_docs_guides_bundler_sign_macos_md","title":"macOS - Code signing guide","area":"guides","section":"bundler","headings":["Requirements","tl","Signing Tauri apps"],"subHeadings":["Creating a signing certificate","Downloading a certificate","Signing the Tauri application","Building the application","Example"],"code":["yml"],"text":"import Alert from '@theme/Alert' This guide provides information on code signing\nand notarization for macOS applications. If you are not utilizing GitHub Actions\nto perform builds of OSX DMGs, you will need to ensure the environment variable\nCI=true exists. For more information refer to Issue #592\n[https://github.com/tauri-apps/tauri/issues/592]. ## Requirements - Xcode 11 or\nabove. - An Apple Developer account enrolled to the [Apple Developer\nProgram](https://developer.apple.com/programs/). ## tl;dr The Tauri code signing\nand notarization process is configured through the following environment\nvariables: - `APPLE_SIGNING_IDENTITY`: the name of the keychain entry that\ncontains the signing certificate. - `APPLE_CERTIFICATE`: base64 string of the\n`.p12` certificate, exported from the keychain. Useful if you don't have the\ncertificate on the keychain (e.g. CI machines). - `APPLE_CERTIFICATE_PASSWORD`:\nthe password for the `.p12` certificate. - `APPLE_ID` and `APPLE_PASSWORD`: your\nApple account email and an [app-specific\npassword](https://support.apple.com/en-ca/HT204397). Only required to notarize\nthe app. - `APPLE_API_ISSUER` and `APPLE_API_KEY`: authentication with an App\nStore Connect API key instead of the Apple ID. Only required to notarize the\napp. ## Signing Tauri apps The first step to sign a macOS application is getting\na signing certificate from the Apple Developer Program. ### Creating a signing\ncertificate To create a new signing certificate you must generate a Certificate\nSigning Request (CSR) file from your Mac computer. [This\nguide](https://help.apple.com/developer-account/#/devbfa00fef7) describes the\nprocess to create a CSR. On your Apple Developer account, navigate to the\n[Certificates, IDs & Profiles\npage](https://developer.apple.com/account/resources/certificates/list) and click\non the `Add` button to open the interface to create a new certificate. Choose\nthe appropriate certificate type (`Apple Distribution` to submit apps to the App\nStore, and `Developer ID Application` to ship apps outside of the App Store).\nUpload your CSR and the certificate will be created. Only the Apple Developer\n`Account Holder` can create Developer ID Application certificates, but it can be\nassociated to a different Apple ID by creating a CSR with a different user email\naddress. ### Downloading a certificate On [Certificates, IDs & Profiles\npage](https://developer.apple.com/account/resources/certificates/list), click on\nthe certificate you want to use and then click on the `Download` button. It will\nsave a `.cer` file that once opened, installs the certificate on the keychain.\nThe name of the keychain entry represents the `signing identity`, which can also\nbe found by executing `$ security find-identity -v -p codesigning`. A signing\ncertificate is only valid if associated with your Apple ID. An invalid\ncertificate won't be listed on the Keychain Access > My Certificates tab or the\n$ security find-identity -v -p codesigning output. ### Signing the Tauri\napplication The signing configuration is provided to the Tauri bundler via\nenvironment variables. You will need to configure the certificate to use and an\noptional authentication configuration to notarize the application. ####\nCertificate environment variables - `APPLE_SIGNING_IDENTITY`: this is the\n`signing identity` we highlighted above. It must be defined to sign apps both\nlocally and on CI machines. Additionally, to simplify the process of code\nsigning on CI, Tauri can install the certificate on the keychain for you if you\ndefine the `APPLE_CERTIFICATE` and `APPLE_CERTIFICATE_PASSWORD` environment\nvariables. 1. Open the `Keychain Access` app and find your certificate's\nkeychain entry. 2. Expand the entry, double click on the key item and select\n`Export \"$KEYNAME\"`. 3. Select the path to save the `.p12` file and define the\nexported certificate password. 4. Convert the `.p12` file to base64 running the\nfollowing script on the terminal: `openssl base64 -in /path/to/certificate.p12\n-out certificate-base64.txt`. 5. Set the contents of the\n`certificate-base64.txt` file to the `APPLE_CERTIFICATE` environment variable.\n6. Set the certificate password to the `APPLE_CERTIFICATE_PASSWORD` environment\nvariable. #### Authentication environment variables These variables are only\nrequired to notarize the application. Notarization is required when using a\nDeveloper ID Application certificate. - `APPLE_ID` and `APPLE_PASSWORD`: to\nauthenticate with your Apple ID, set the `APPLE_ID` to your Apple account email\n(example: `export APPLE_ID=tauri@icloud.com`) and the `APPLE_PASSWORD` to an\n[app-specific password](https://support.apple.com/en-ca/HT204397) for the Apple\naccount. - `APPLE_API_ISSUER` and `APPLE_API_KEY`: alternatively, you can\nauthenticate using an App Store Connect API key. Open the App Store Connect's\n[Users and Access page](https://appstoreconnect.apple.com/access/users), select\nthe `Keys` tab and click on the `Add` button; select a name and the `Developer`\naccess. The `APPLE_API_ISSUER` (`Issuer ID`) is presented above the keys table,\nand the `APPLE_API_KEY` is the value on the `Key ID` column on that table. You\nalso need to download the private key, which can only be done once and is only\nvisible after a page reload (the button is shown on the table row for the newly\ncreated key). The private key file must be saved on `./private_keys`,\n`~/private_keys`, `~/.private_keys` or `~/.appstoreconnect/private_keys`, as\nstated on the `$ xcrun altool --help` command. ### Building the application With\nall these environment variables set, the Tauri bundler will automatically sign\nand notarize your application when you run the `tauri build` command. ###\nExample The following example uses GitHub Actions to sign an application using\nthe [Tauri action](https://github.com/tauri-apps/tauri-action). On GitHub, we\nfirst define the environment variables we listed above as GitHub Secrets. You\ncan view this guide\n[https://docs.github.com/en/actions/reference/encrypted-secrets] to learn about\nGitHub secrets. Once we have established the GitHub Secrets we will create a\nGitHub publish workflow in `.github/workflows/main.yml`: ```yml name: \"publish\"\non: push: branches: - release jobs: publish-tauri: strategy: fail-fast: false\nmatrix: platform: [macos-latest] runs-on: ${{ matrix.platform }} steps: - uses:\nactions/checkout@v2 - name: setup node uses: actions/setup-node@v2 with:\nnode-version: 12 - name: install Rust stable uses: actions-rs/toolchain@v1 with:\ntoolchain: stable - name: install app dependencies and build it run: yarn &&\nyarn build - uses: tauri-apps/tauri-action@v0 env: GITHUB_TOKEN: ${{\nsecrets.GITHUB_TOKEN }} ENABLE_CODE_SIGNING: ${{ secrets.APPLE_CERTIFICATE }}\nAPPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }} APPLE_CERTIFICATE_PASSWORD:\n${{ secrets.APPLE_CERTIFICATE_PASSWORD }} APPLE_SIGNING_IDENTITY: ${{\nsecrets.APPLE_IDENTITY_ID }} APPLE_ID: ${{ secrets.APPLE_ID }} APPLE_PASSWORD:\n${{ secrets.APPLE_PASSWORD }} with: tagName: app-v__VERSION__ # the action\nautomatically replaces \\_\\_VERSION\\_\\_ with the app version releaseName: \"App\nv__VERSION__\" releaseBody: \"See the assets to download this version and\ninstall.\" releaseDraft: true prerelease: false ``` The workflow pulls the\nsecrets from GitHub and define them as environment variables before building the\napplication using the Tauri action. The output is a GitHub release with the\nsigned and notarized macOS application.","url":"https://tauri.studio/docs/guides/bundler/sign-macos"},{"id":"prose_docs_guides_bundler_sign_windows_md","title":"Windows - Code signing guide locally & with Github Actions","area":"guides","section":"bundler","headings":["A","B","C","GitHub Secrets","Workflow Modifications"],"subHeadings":[],"code":[null],"text":"import Alert from '@theme/Alert' # Intro Code-signing will add a level of\nauthenticity to your application, while it is not required it can often improve\nthe user experience for your users. # Prerequisites - Windows - you can likely\nuse other platforms, but this tutorial is using Powershell native features. -\nCode signing certificate - you can aqquire one of these on services such as\nDigicert.com, Comodo.com, & Godaddy.com. In this guide we are using Comodo.com -\nA working tauri application # Getting Started There are a few things we will\nhave to do to get our windows installation prepared for code signing. This\nincludes converting our certificate to a speific format, installing this\ncertificate, & then decoding required information from certificate that is\nrequired by tauri. ## A. Convert your `.cer` to `.pfx` 1. You will need the\nfollowing: - certificate file (mine is `cert.cer`) - private key file (mine is\n`private-key.key`) 2. Open up a command prompt and change to your current\ndirectory using `cd Documents/Certs` 3. Convert your `.cer` to a `.pfx` using\n`openssl pkcs12 -export -in cert.cer -inkey private-key.key -out\ncertificate.pfx` 4. You will be prompted to enter an export password **DON'T\nFORGET IT!** ## B. Import your `.pfx` file into the keystore. We will now need\nto import our `.pfx` file. 1. Assign your export password to a variable using\n`$WINDOWS_PFX_PASSWORD = 'MYPASSWORD'` 2. Now Import the certificate using\n`Import-PfxCertificate -FilePath Certs/certificate.pfx -CertStoreLocation\nCert:\\CurrentUser\\My -Password (ConvertTo-SecureString -String\n$env:WINDOWS_PFX_PASSWORD -Force -AsPlainText)` ## C. Prepare Variables 1. We\nwill need the SHA-1 thumbprint of the certificate, you can get this using\n`openssl pkcs12 -info -in certificate.pfx` and look under for following ``` Bag\nAttributes localKeyID: A1 B1 A2 B2 A3 B3 A4 B4 A5 B5 A6 B6 A7 B7 A8 B8 A9 B9 A0\nB0 ``` 2. You will capture the `localKeyID` but with no spaces, in this example\nit would be `A1B1A2B2A3B3A4B4A5B5A6B6A7B7A8B8A9B9A0B0`. This is our\n`certificateThumbprint`. 3. We will need the SHA digest algorythm used for your\ncertificate (Hint: this is likely `sha256` 4. We will also need a timestamp url,\nthis is a time server used to verify the time of the certificate signing. Im\nusing `http://timestamp.comodoca.com` but whoever you got your certificate from\nlikely has one aswell. # Prepare `tauri.conf.json` file 1. Now that we have our\n`certificateThumbprint`, `digestAlgorithm`, & `timestampUrl` we will open up the\n`tauri.conf.json`. 2. In the `tauri.conf.json` you will look for the `tauri` ->\n`bundle` -> `windows` section. You will see there are three variable for the\ninformation we have captured. Fill it out like below. ``` \"windows\": {\n\"certificateThumbprint\": \"A1B1A2B2A3B3A4B4A5B5A6B6A7B7A8B8A9B9A0B0\",\n\"digestAlgorithm\": \"sha256\", \"timestampUrl\": \"http://timestamp.comodoca.com\" }\n``` 3. Save, and run `yarn | yarn build` 4. In the console output you will see\nthe following output. ``` info: signing app info: running signtool \"C:\\\\Program\nFiles (x86)\\\\Windows Kits\\\\10\\\\bin\\\\10.0.19041.0\\\\x64\\\\signtool.exe\" info: \"Done\nAdding Additional Store\\r\\nSuccessfully signed: APPLICATION FILE PATH HERE ```\nwhich shows you have successfully signed the `.exe`. And thats it! You have\nsuccessfully signed your .exe file. # BONUS: Sign your application with GitHub\nActions. We can also create a workflow to sign the application with GitHub\nactions, this will help automate your Publish time. ## GitHub Secrets We will\nneed to add a few GitHub secrets for the proper configuration of the GitHub\nAction. These can be named however you would like. - You can view\n[this](https://docs.github.com/en/actions/reference/encrypted-secrets) guide for\nhow to add GitHub secrets. The secrets we used are as follows | GitHub Secrets |\nValue for Variable | | :---: | :---: | |WINDOWS_CERTIFICATE| Base64 encoded\nversion of your .pfx certificate, can be done using this command `certutil\n-encode certificate.pfx base64cert.txt` |\n|WINDOWS_CERTIFICATE_PASSWORD|Certificate export password used on creation of\ncertificate .pfx| ## Workflow Modifications 1. We will need to add a step in the\nworkflow to properly import the certificate into the windows environment. This\nwork flow accomplishes the following 1. Assign GitHub secrets to environment\nvariables 2. Create a new `certificate` directory 3. Import\n`WINDOWS_CERTIFICATE` into tempCert.txt 4. Use `certutil` to decode the\ntempCert.txt from base64 into a `.pfx` file. 5. Remove tempCert.txt 6. Import\nthe `.pfx` file into the Cert store of Windows & convert the\n`WINDOWS_CERTIFICATE_PASSWORD` to a secure string to be used in the import\ncommand. 2. We will be using the tauri-action publish template available\n[here](https://github.com/tauri-apps/tauri-action) ``` name: \"publish\" on: push:\nbranches: - release jobs: publish-tauri: strategy: fail-fast: false matrix:\nplatform: [macos-latest, ubuntu-latest, windows-latest] runs-on: ${{\nmatrix.platform }} steps: - uses: actions/checkout@v2 - name: setup node uses:\nactions/setup-node@v1 with: node-version: 12 - name: install Rust stable uses:\nactions-rs/toolchain@v1 with: toolchain: stable - name: install webkit2gtk\n(ubuntu only) if: matrix.platform == 'ubuntu-latest' run: | sudo apt-get update\nsudo apt-get install -y webkit2gtk-4.0 - name: install app dependencies and\nbuild it run: yarn && yarn build - uses: tauri-apps/tauri-action@v0 env:\nGITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tagName: app-v__VERSION__ # the\naction automatically replaces \\_\\_VERSION\\_\\_ with the app version releaseName:\n\"App v__VERSION__\" releaseBody: \"See the assets to download this version and\ninstall.\" releaseDraft: true prerelease: false ``` 3. Right above `-name:\ninstall app dependencies and build it` you will want to add the following step\n``` - name: import windows certificate if: matrix.platform == 'windows-latest'\nenv: WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}\nWINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }} run: |\nNew-Item -ItemType directory -Path certificate Set-Content -Path\ncertificate/tempCert.txt -Value $env:WINDOWS_PFX certutil -decode\ncertificate/tempCert.txt certificate/certificate.pfx Remove-Item -path\ncertificate -include tempCert.txt Import-PfxCertificate -FilePath\ncertificate/certificate.pfx -CertStoreLocation Cert:\\CurrentUser\\My -Password\n(ConvertTo-SecureString -String $env:WINDOWS_PFX_PASSWORD -Force -AsPlainText)\n``` 4. Save, and push to your repo. 5. You workflow will now be able to import\nyour windows certificate and import it into the github runner, allowing for\nautomated code-signing!","url":"https://tauri.studio/docs/guides/bundler/sign-windows"},{"id":"prose_docs_guides_patterns_about_patterns_md","title":"A word on patterns","area":"guides","section":"patterns","headings":[],"subHeadings":[],"code":[],"text":"Tauri patterns are descriptions of use-cases that are entirely configurable\nwithin the `src-tauri/tauri.conf.json` file. These are not the limits of what\nTauri can do, and there are probably more out there. If you discover one, why\nnot get in touch and help us update this collection! If you haven't read about\nthe general design of Tauri, then it would make the most sense for you to visit\nthe [\"Get started\"](/docs/get-started/intro) and become familiar with the basic\narchitecture and terminology used in these patterns.","url":"https://tauri.studio/docs/guides/patterns/about-patterns"},{"id":"prose_docs_guides_patterns_bridge_md","title":"Bridge","area":"guides","section":"patterns","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nBridge [{useBaseUrl('img/patterns/Bridge.png')}]\nPros:\n * Highly configurable\n * No Rust skills required\n\nCons:\n * Some WebAPIs unavailable\n * Challenge to implement\n\n## Description The Bridge recipe is a secure pattern where messages are passed\nbetween brokers via an implicit bridge using the API. It isolates functionality\nto scope and passes messages instead of functionality. ## Diagram import\nMermaid, { colors } from '@theme/Mermaid' F subgraph WEBVIEW F-.-E end D-->E\nE-->D B-->D D-->B subgraph RUST A==>H A-->B B-.-C B-.-G end A[Binary] B{Rust\nBroker} C[Subprocess 2] G[Subprocess 1] D(( API BRIDGE )) E{JS Broker} F[Window]\nH{Bootstrap} style D fill:#ccc,stroke:#333,stroke-width:4px,color:white style\nRUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\nstyle WEBVIEW\nfill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`} /> ##\nConfiguration Here's what you need to add to your tauri.conf.json file: ```json\n\"tauri\": { \"allowlist\": { // all API values are default false \"all\": false, //\nuse this flag to enable all API features \"shell\": { \"execute\": false, // enable\napplication execution \"open\": false, // open link/path in the default app },\n\"fs\": { \"listFiles\": false, // list files in a directory \"readBinaryFile\":\nfalse, // read binary file from local filesystem \"readTextFile\": false, // read\ntext file from local filesystem \"setTitle\": false, // set the window title\n\"writeFile\": false // write file to local filesystem } } } ```","url":"https://tauri.studio/docs/guides/patterns/bridge"},{"id":"prose_docs_guides_patterns_cloudbridge_md","title":"Cloudbridge","area":"guides","section":"patterns","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nCloudbridge [{useBaseUrl('img/patterns/Cloudbridge.png')}]\nPros:\n * All available features\n * No Rust skills required\n\nCons:\n * Largest bundle size\n * Hard to separate concerns\n\n## Description The Cloudbridge recipe combines the flexibility of a localhost\nand the security of the bridge. With so many features, it can be easy to get\nlost. ## Diagram import Mermaid, { colors } from '@theme/Mermaid' F2 H==>D2\nD2-->F2 F2-->D2 B-->D D-->B E2-->D D-->E2 subgraph WEBVIEW F2 E2 end subgraph\nSERVER D2 E-->D2 end subgraph RUST A==>H A-->B B-.-C end A[Binary] B{Rust\nBroker} C[Subprocess] D(( API BRIDGE )) E{JS Broker} D2(( localhost )) E[bundled\nresources] E2{JS Broker} F2[Window] H{Bootstrap} style D\nfill:#ccc,stroke:#333,stroke-width:4px,color:white style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\nstyle SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px `} /> ## Configuration\nHere's what you need to add to your tauri.conf.json file: ```json \"tauri\": {\n\"allowlist\": { \"all\": true // enable entire API } } ```","url":"https://tauri.studio/docs/guides/patterns/cloudbridge"},{"id":"prose_docs_guides_patterns_cloudish_md","title":"Cloudish","area":"guides","section":"patterns","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nCloudish [{useBaseUrl('img/patterns/Cloudish.png')}]\nPros:\n * Similar to a SPA web-app\n * No Rust skills required\n\nCons:\n * No access to Rust API\n * Uses a localhost server\n\n## Description The Cloudish recipe is a pattern for maximum flexibility and app\nperformance. It uses a localhost server, which means that your app will\ntechnically be available to other processes, like browsers and potentially other\ndevices on the network. All of your assets are baked into the binary, but served\nas if they were distinct files. ## Diagram import Mermaid, { colors } from\n'@theme/Mermaid' F H==>D D-->F F-->D subgraph RUST A==>H end subgraph WEBVIEW F\nend subgraph SERVER D E-->D end A[Binary] D(( localhost )) E[bundled resources]\nF[Window] H{Bootstrap} style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\nstyle SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px`} /> ## Configuration\nHere's what you need to add to your tauri.conf.json file: ```json \"tauri\": {\n\"allowlist\": { \"all\": false // disable entire API } } ```","url":"https://tauri.studio/docs/guides/patterns/cloudish"},{"id":"prose_docs_guides_patterns_glui_md","title":"GLUI","area":"guides","section":"patterns","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Alert from '@theme/Alert' import useBaseUrl from '@docusaurus/useBaseUrl'\nThis pattern is not available for now. import Rater from '@theme/Rater'\n\nEase of Use Extensibility Performance Security\n\nGLUI [{useBaseUrl('img/patterns/GLUI.png')}]\nPros:\n * Framebuffer FTW\n * Window events rigged\n\nCons:\n * Broken on your machine\n\n## Description The GLUI is a research pattern that we will use internally to\ntest approaches using a GLUTIN window. We’re not sure yet if it will make the\nfinal cut as a bona fide alternative to WebView, although early tests with\ntransparent and multiwindow are exciting. ## Diagram import Mermaid, { colors }\nfrom '@theme/Mermaid' H H==>G A-->D D-->G subgraph GLUTIN G end subgraph RUST A\nend A[Binary] D(Framebuffer) G[GL Window] H{Bootstrap} style GLUTIN\nstroke:${colors.blue.dark},stroke-width:4px style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px`} />\n## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": { // all API endpoints are default false \"all\":\nfalse, // disable the api }, \"window\": { // not yet normative \"glutin\": true,\n\"webview\": false } } ```","url":"https://tauri.studio/docs/guides/patterns/glui"},{"id":"prose_docs_guides_patterns_hermit_md","title":"Hermit","area":"guides","section":"patterns","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":["json"],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nHermit [{useBaseUrl('img/patterns/Hermit.png')}]\nPros:\n * Quick to make\n * Smallest size\n\nCons:\n * No remote resources\n * No access to API\n\n## Description The Hermit recipe is a pattern for ultimate application isolation\nwhere all logic is self-contained in the Window and the binary exists merely to\nbootstrap the Window. There is no communication back to Rust from the Window,\nthere is no localhost server, and the Window has no access to any remote\nresources. The Hermit is great for interactive Kiosk Mode and standalone HTML\nbased games. ## Diagram import Mermaid, { colors } from '@theme/Mermaid' H H==>F\nsubgraph WEBVIEW F end subgraph RUST A end A[fa:fa-cog Binary ]\nF[fa:fa-window-maximize Window] H{Bootstrap} style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": { \"all\": false, // disable and tree-shake all\napi functions } } ```","url":"https://tauri.studio/docs/guides/patterns/hermit"},{"id":"prose_docs_guides_patterns_lockdown_md","title":"Lockdown","area":"guides","section":"patterns","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nLockdown [{useBaseUrl('img/patterns/Lockdown.png')}]\nPros:\n * Highest security rating\n * Elegant and powerful\n\nCons:\n * Rust skills required\n * No remote resources\n\n## Description The Lockdown recipe is a minimal usage of the [Bridge\npattern](/docs/guides/patterns/bridge), which only allows interaction between\nRust and the Window via expiring JS Promise Closures that are injected into the\nWindow by Rust and nulled as part of the callback. ## Diagram import Mermaid, {\ncolors } from '@theme/Mermaid' F G-.->B B-->G subgraph WEBVIEW G-->F end\nsubgraph RUST A-->B A==>H end A[Binary] B[API:Event] F[Window] G((Promise\nClosure)) H{Bootstrap} style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": {} // all API endpoints are default false } ```","url":"https://tauri.studio/docs/guides/patterns/lockdown"},{"id":"prose_docs_guides_patterns_multiwin_md","title":"Multiwin","area":"guides","section":"patterns","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Alert from '@theme/Alert' import useBaseUrl from '@docusaurus/useBaseUrl'\nimport Rater from '@theme/Rater'\n\nEase of Use Extensibility Performance Security\n\nMultiwin [{useBaseUrl('img/patterns/Multiwin.png')}]\nPros:\n * Windows can be spawned or destroyed at runtime\n * Separation of concerns\n\nCons:\n * Somewhat complex\n\n## Description The Multiwin recipe will allow you to have multiple windows. ##\nDiagram import Mermaid, { colors } from '@theme/Mermaid' H H==>F H==>G subgraph\nWEBVIEW F end subgraph WINIT G end subgraph RUST A end A[Binary] F[Window]\nG[Window] H{Bootstrap} style WINIT stroke:${colors.blue.dark},stroke-width:4px\nstyle RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": {}, // all API endpoints are default false\n\"windows\": [{ \"title\": \"Window1\", \"label\": \"main\", }, { \"title\": \"Splash\",\n\"label\": \"splashscreen\" }] } ```","url":"https://tauri.studio/docs/guides/patterns/multiwin"},{"id":"prose_docs_guides_webdriver_ci_md","title":"Continuous Integration","area":"guides","section":"webdriver","headings":[],"subHeadings":[],"code":["yaml"],"text":"Utilizing Linux and some programs to create a fake display, it is possible to\nrun [WebDriver] tests with [`tauri-driver`] on your CI. The following example\nwill use the [WebdriverIO] example we [previously built together] and GitHub\nActions. This means the following assumptions: 1. The Tauri application is in\nthe repository root and the binary builds when running `cargo build --release`.\n2. The [WebDriverIO] test runner is in the `webdriver/webdriverio` directory and\nruns when `yarn test` is used in that directory. The following is a commented\nGitHub Actions workflow file at `.github/workflows/webdriver.yml` ```yaml # run\nthis action when the repository is pushed to on: [ push ] # the name of our\nworkflow name: WebDriver jobs: # a single job named test test: # the display\nname the test job name: WebDriverIO Test Runner # we want to run on the latest\nlinux environment runs-on: ubuntu-latest # the steps our job runs **in order**\nsteps: # checkout the code on the workflow runner - uses: actions/checkout@v2 #\ninstall system dependencies that Tauri needs to compile on Linux. # note the\nextra dependencies for `tauri-driver` to run which are `webkit2gtk-driver` and\n`xvfb` - name: Tauri dependencies run: >- sudo apt-get update && sudo apt-get\ninstall -y libgtk-3-dev libgtksourceview-3.0-dev webkit2gtk-4.0\nlibappindicator3-dev webkit2gtk-driver xvfb # install the latest Rust stable -\nname: Rust stable uses: actions-rs/toolchain@v1 with: toolchain: stable # we run\nour rust tests before the webdriver tests to avoid testing a broken application\n- name: Cargo test uses: actions-rs/cargo@v1 with: command: test # build a\nrelease build of our application to be used during our WebdriverIO tests - name:\nCargo build uses: actions-rs/cargo@v1 with: command: build args: --release #\ninstall the latest stable node version at the time of writing - name: Node v16\nuses: actions/setup-node@v2 with: node-version: 16.x # install our Node.js\ndependencies with Yarn - name: Yarn install run: yarn install working-directory:\nwebdriver/webdriverio # install the latest version of `tauri-driver`. # note:\nthe tauri-driver version is independent of any other Tauri versions - name:\nInstall tauri-driver uses: actions-rs/cargo@v1 with: command: install args:\ntauri-driver # run the WebdriverIO test suite. # we run it through `xvfb-run`\n(the dependency we installed earlier) to have a fake # display server which\nallows our application to run headless without any changes to the code - name:\nWebdriverIO run: xvfb-run yarn test working-directory: webdriver/webdriverio ```\n[WebDriver]: https://www.w3.org/TR/webdriver/ [`tauri-driver`]:\nhttps://crates.io/crates/tauri-driver [WebdriverIO]: https://webdriver.io/\n[previously built together]: example/webdriverio","url":"https://tauri.studio/docs/guides/webdriver/ci"},{"id":"prose_docs_guides_webdriver_introduction_md","title":"Introduction","area":"guides","section":"webdriver","headings":["System Dependencies","Example Application"],"subHeadings":["Linux","Windows"],"code":["sh"],"text":"import Alert from '@theme/Alert' Webdriver support for Tauri is still in\npre-alpha. Tooling that is dedicated to it such as [tauri-driver] is still in\nactive development and may change as necessary over time. Additionally, only\nWindows and Linux are currently supported. [WebDriver] is a standardized\ninterface to interact with web documents that is primarily intended for\nautomated testing. Tauri supports the [WebDriver] interface by leveraging the\nnative platform's [WebDriver] server underneath a cross-platform wrapper\n[`tauri-driver`]. ## System Dependencies Install the latest [`tauri-driver`] or\nupdate an existing installation by running: ```sh cargo install tauri-driver ```\nBecause we currently utilize the platform's native [WebDriver] server, there are\nsome requirements for running [`tauri-driver`] on supported platforms. Platform\nsupport is currently limited to Linux and Windows. ### Linux We use\n`WebKitWebDriver` on linux platforms. Check if this binary exists already\n(command `which WebKitWebDriver`) as some distributions bundle it with the\nregular webkit package. Other platforms may have a separate package for them\nsuch as `webkit2gtk-driver` on Debian based distributions. ### Windows Make sure\nto grab the version of [Microsoft Edge Driver] that matches your Windows' Edge\nversion that the application is being built and tested on. On up-to-date Window\ninstalls, this should almost always be the latest stable version. If the two\nversions do not match, you may experience your WebDriver testing suite hanging\nwhile trying to connect. The download contains a binary called\n`msedgedriver.exe`. [`tauri-driver`] looks for that binary in the `$PATH` so\nmake sure it's either available on the path or use the `--native-driver` option\non [`tauri-driver`]. On Windows CI machines, you may want to download this\nautomatically as part of the CI setup process to ensure the Edge and Edge Driver\nversions stay in sync. A guide on how to do this may be added at a later date.\n## Example Application The [next section](example/setup) of the guide will show\nstep-by-step how to create a minimal example application that is tested with\nWebDriver. If you prefer to just see the result of the guide and look over a\nfinished minimal codebase that utilizes it then you can look at\nhttps://github.com/chippers/hello_tauri. That example also comes with a CI\nscript to test with GitHub actions, but you may still be interested in the\n[WebDriver CI](ci) guide as it explains the concept a bit more. [WebDriver]:\nhttps://www.w3.org/TR/webdriver/ [`tauri-driver`]:\nhttps://crates.io/crates/tauri-driver [tauri-driver]:\nhttps://crates.io/crates/tauri-driver [Microsoft Edge Driver]:\nhttps://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/","url":"https://tauri.studio/docs/guides/webdriver/introduction"},{"id":"prose_docs_guides_webdriver_example_selenium_md","title":"Selenium","area":"guides","parentSection":"webdriver","section":"example","headings":["Create a Directory for the Tests","Initializing a Selenium Project","Testing","Running the Test Suite"],"subHeadings":[],"code":["sh",null,"text"],"text":"import Alert from '@theme/Alert' import Tabs from '@theme/Tabs' import TabItem\nfrom '@theme/TabItem' This [Selenium] guide expects you to have already gone\nthrough the [example Application setup] in order to follow step-by-step. The\ngeneral information may still be useful otherwise. This WebDriver testing\nexample will use [Selenium] and a popular Node.js testing suite. It is expected\nto already have Node.js installed, along with `npm` or `yarn` although the\n[finished example project] uses `yarn`. ## Create a Directory for the Tests\nLet's start off by creating a space in our project to write these tests. We are\ngoing to be using a nested directory for this example project as we will later\nalso go over other frameworks, but typically you will only need to use one.\nCreate the directory we will use with `mkdir -p webdriver/selenium`. The rest of\nthis guide will assume you are inside the `webdriver/selenium` directory. ##\nInitializing a Selenium Project We will be using a pre-existing `package.json`\nto bootstrap this test suite because we have already chosen specific\ndependencies to use and want to showcase a simple working solution. The bottom\nof this section has a collapsed guide on how to set it up from scratch.\n`package.json`: ```json { \"name\": \"selenium\", \"version\": \"1.0.0\", \"private\":\ntrue, \"scripts\": { \"test\": \"mocha\" }, \"dependencies\": { \"chai\": \"^4.3.4\",\n\"mocha\": \"^9.0.3\", \"selenium-webdriver\": \"^4.0.0-beta.4\" } } ``` We have a\nscript which runs [Mocha] as a test framework exposed as the `test` command. We\nalso have various dependencies that we will be using to run the tests. [Mocha]\nas the testing framework, [Chai] as the assertion library, and\n[`selenium-webdriver`] which is the Node.js [Selenium] package. Click me if you\nwant to see how to set a project up from scratch If you wanted to install the\ndependencies from scratch, just run the following command. ```sh npm install\nmocha chai selenium-webdriver ``` ```sh yarn add mocha chai selenium-webdriver\n``` I suggest also adding a `\"test\": \"mocha\"` item in the `package.json`\n`\"scripts\"` key so that running mocha can be called simply with ```sh npm test\n``` ```sh yarn test ``` ## Testing Unlike the [WebdriverIO Test\nSuite](webdriverio#config), Selenium does not come out of the box with a Test\nSuite and leaves it up to the developer to build those out. We chose [Mocha]\nwhich is pretty neutral, and not related to WebDrivers at all, so our script\nwill need to do a bit of work to set up everything for us in the right order.\n[Mocha] expects a testing file at `test/test.js` by default, so let's create\nthat file now. `test/test.js`: ```js const os = require(\"os\"); const path =\nrequire(\"path\"); const { expect } = require(\"chai\"); const { spawn, spawnSync }\n= require(\"child_process\"); const { Builder, By, Capabilities } =\nrequire(\"selenium-webdriver\"); // create the path to the expected application\nbinary const application = path.resolve( __dirname, \"..\", \"..\", \"..\", \"target\",\n\"release\", \"hello-tauri-webdriver\" ); // keep track of the webdriver instance we\ncreate let driver; // keep track of the tauri-driver process we start let\ntauriDriver; before(async function() { // set timeout to 2 minutes to allow the\nprogram to build if it needs to this.timeout(120000) // ensure the program has\nbeen built spawnSync(\"cargo\", [\"build\", \"--release\"]); // start tauri-driver\ntauriDriver = spawn( path.resolve(os.homedir(), \".cargo\", \"bin\",\n\"tauri-driver\"), [], { stdio: [null, process.stdout, process.stderr] } ); const\ncapabilities = new Capabilities(); capabilities.set(\"tauri:options\", {\napplication }); capabilities.setBrowserName(\"wry\"); // start the webdriver\nclient driver = await new Builder() .withCapabilities(capabilities)\n.usingServer(\"http://localhost:4444/\") .build(); }); after(async function() { //\nstop the webdriver session await driver.quit(); // kill the tauri-driver process\ntauriDriver.kill(); }); describe(\"Hello Tauri\", () => { it(\"should be cordial\",\nasync () => { const text = await driver.findElement(By.css(\"body >\nh1\")).getText(); expect(text).to.match(/^[hH]ello/); }); it(\"should be excited\",\nasync () => { const text = await driver.findElement(By.css(\"body >\nh1\")).getText(); expect(text).to.match(/!$/); }); it(\"should be easy on the\neyes\", async () => { // selenium returns color css values as rgb(r, g, b) const\ntext = await driver.findElement(By.css(\"body\")).getCssValue(\"background-color\");\nconst rgb = text.match(/^rgb\\((?\\d+), (?\\d+), (?\\d+)\\)$/).groups;\nexpect(rgb).to.have.all.keys('r','g','b'); const luma = 0.2126 * rgb.r + 0.7152\n* rgb.g + 0.0722 * rgb.b ; expect(luma).to.be.lessThan(100) }); }); ``` If you\nare familiar with JS testing frameworks, `describe`, `it`, and `expect` should\nlook familiar. We also have semi-complex `before()` and `after()` callbacks to\nsetup and teardown mocha. Lines that are not the tests themselves have comments\nexplaining what the setup and teardown code is doing. If you were familiar with\nthe Spec file from the [WebdriverIO example](webdriverio#spec), you will notice\na lot more code that isn't tests, as we have to set up a few more WebDriver\nrelated items. ## Running the Test Suite Now that we are all set up with our\ndependencies and our test script, lets run it! ```sh npm test ``` ```sh yarn\ntest ``` We should see output the following output: ```text ➜ selenium\ngit:(main) ✗ yarn test yarn run v1.22.11 $ mocha Hello Tauri ✔ should be cordial\n(120ms) ✔ should be excited ✔ should be easy on the eyes 3 passing (588ms) Done\nin 0.93s. ``` We can see that our `Hello Tauri` sweet we created with `decribe`\nhad all 3 items we created with `it` pass their tests! With [Selenium] and some\nhooking up to a test suite, we just enabled e2e testing without modifying our\nTauri application at all! [Selenium]: https://selenium.dev/ [finished example\nproject]: https://github.com/chippers/hello_tauri [example Application setup]:\nsetup [Mocha]: https://mochajs.org/ [Chai]: https://www.chaijs.com/\n[`selenium-webdriver`]: https://www.npmjs.com/package/selenium-webdriver","url":"https://tauri.studio/docs/guides/webdriver/example/selenium"},{"id":"prose_docs_guides_webdriver_example_setup_md","title":"Setup Example","area":"guides","parentSection":"webdriver","section":"example","headings":["Initializing a Cargo Project","Creating a Minimal Frontend","Adding Tauri to the Cargo Project","Tauri Configuration","Running the Example Application"],"subHeadings":[],"code":["html","toml","rust","json"],"text":"HELLO, TAURI!","url":"https://tauri.studio/docs/guides/webdriver/example/setup"},{"id":"prose_docs_guides_webdriver_example_webdriverio_md","title":"WebdriverIO","area":"guides","parentSection":"webdriver","section":"example","headings":["Create a Directory for the Tests","Initializing a WebdriverIO Project","Config","Spec","Running the Test Suite"],"subHeadings":[],"code":["sh","text"],"text":"import Alert from '@theme/Alert' import Tabs from '@theme/Tabs' import TabItem\nfrom '@theme/TabItem' This [WebdriverIO] guide expects you to have already gone\nthrough the [example Application setup] in order to follow step-by-step. The\ngeneral information may still be useful otherwise. This WebDriver testing\nexample will use [WebdriverIO] and its testing suite. It is expected to already\nhave Node.js installed, along with `npm` or `yarn` although the [finished\nexample project] uses `yarn`. ## Create a Directory for the Tests Let's start\noff by creating a space in our project to write these tests. We are going to be\nusing a nested directory for this example project as we will later also go over\nother frameworks, but typically you will only need to use one. Create the\ndirectory we will use with `mkdir -p webdriver/webdriverio`. The rest of this\nguide will assume you are inside the `webdriver/webdriverio` directory. ##\nInitializing a WebdriverIO Project We will be using a pre-existing\n`package.json` to bootstrap this test suite because we have already chosen\nspecific [WebdriverIO] config options and want to showcase a simple working\nsolution. The bottom of this section has a collapsed guide on how to set it up\nfrom scratch. `package.json`: ```json { \"name\": \"webdriverio\", \"version\":\n\"1.0.0\", \"private\": true, \"scripts\": { \"test\": \"wdio run wdio.conf.js\" },\n\"dependencies\": { \"@wdio/cli\": \"^7.9.1\" }, \"devDependencies\": {\n\"@wdio/local-runner\": \"^7.9.1\", \"@wdio/mocha-framework\": \"^7.9.1\",\n\"@wdio/spec-reporter\": \"^7.9.0\" } } ``` We have a script which runs a\n[WebdriverIO] config as a test suite exposed as the `test` command. We also have\nvarious dependencies that were added by the `@wdio/cli` command when we first\nset it up. In short, these dependencies are for the most simple setup using a\nlocal WebDriver runner, [Mocha] as the test framework, and a simple Spec\nReporter. Click me if you want to see how to set a project up from scratch The\nCLI is interactive, and you may choose the tools to work with yourself. Note\nthat you will likely diverge from the rest of the guide, and need to set up the\ndifferences yourself. Let's add the [WebdriverIO] CLI to this npm project. ```sh\nnpm install @wdio/cli ``` ```sh yarn add @wdio/cli ``` To then run the\ninteractive config command to set up a [WebdriverIO] test suite, you can then\nrun: ```sh npx wdio config ``` ```sh yarn wdio config ``` ## Config You may have\nnoticed that the `test` script in our `package.json` mentions a file\n`wdio.conf.js`. That's the [WebdriverIO] config file which controls most aspects\nof our testing suite. `wdio.conf.js`: ```js const os = require(\"os\"); const path\n= require(\"path\"); const { spawn, spawnSync } = require(\"child_process\"); //\nkeep track of the `tauri-driver` child process let tauriDriver; exports.config =\n{ specs: [\"./test/specs/**/*.js\"], maxInstances: 1, capabilities: [ {\nmaxInstances: 1, \"tauri:options\": { application:\n\"../../target/release/hello-tauri-webdriver\", }, }, ], reporters: [\"spec\"],\nframework: \"mocha\", mochaOpts: { ui: \"bdd\", timeout: 60000, }, // ensure the\nrust project is built since we expect this binary to exist for the webdriver\nsessions onPrepare: () => spawnSync(\"cargo\", [\"build\", \"--release\"]), // ensure\nwe are running `tauri-driver` before the session starts so that we can proxy the\nwebdriver requests beforeSession: () => (tauriDriver = spawn(\npath.resolve(os.homedir(), \".cargo\", \"bin\", \"tauri-driver\"), [], { stdio: [null,\nprocess.stdout, process.stderr] } )), // clean up the `tauri-driver` process we\nspawned at the start of the session afterSession: () => tauriDriver.kill(), };\n``` If you are interested in the properties on `exports.config` object, then I\n[suggest reading the documentation] for it. For non-WDIO specific items, there\nare comments explaining why we are running commands in `onPrepare`,\n`beforeSession`, and `afterSession`. We also have our specs set to\n`\"./test/specs/**/*.js\"`, so let's create a spec now. ## Spec A spec contains\nthe code that is testing your actual application. The test runner will load\nthese specs and automatically run them as it sees fit. Let's create our spec now\nin the directory we specified. `test/specs/example.e2e.js`: ```js // calculates\nthe luma from a hex color `#abcdef` function luma(hex) { if\n(hex.startsWith(\"#\")) { hex = hex.substring(1); } const rgb = parseInt(hex, 16);\nconst r = (rgb >> 16) & 0xff; const g = (rgb >> 8) & 0xff; const b = (rgb >> 0)\n& 0xff; return 0.2126 * r + 0.7152 * g + 0.0722 * b; } describe(\"Hello Tauri\",\n() => { it(\"should be cordial\", async () => { const header = await $(\"body >\nh1\"); const text = await header.getText(); expect(text).toMatch(/^[hH]ello/);\n}); it(\"should be excited\", async () => { const header = await $(\"body > h1\");\nconst text = await header.getText(); expect(text).toMatch(/!$/); }); it(\"should\nbe easy on the eyes\", async () => { const body = await $(\"body\"); const\nbackgroundColor = await body.getCSSProperty(\"background-color\");\nexpect(luma(backgroundColor.parsed.hex)).toBeLessThan(100); }); }); ``` The\n`luma` function on top is just a helper function for one of our tests and is not\nrelated to the actual testing of the application. If you are familiar with other\ntesting frameworks, you may notice similar functions being exposed that are used\nsuch as `describe`, `it`, and `expect`. The other APIs, such as items like `$`\nand the methods it exposes is covered by the [WebdriverIO API\ndocs](https://webdriver.io/docs/api). ## Running the Test Suite Now that we are\nall set up with a config and a spec, let's run it! ```sh npm test ``` ```sh yarn\ntest ``` We should see output the following output: ```text ➜ webdriverio\ngit:(main) ✗ yarn test yarn run v1.22.11 $ wdio run wdio.conf.js Execution of 1\nworkers started at 2021-08-17T08:06:10.279Z [0-0] RUNNING in undefined -\n/test/specs/example.e2e.js [0-0] PASSED in undefined -\n/test/specs/example.e2e.js \"spec\" Reporter:\n------------------------------------------------------------------ [wry 0.12.1\nlinux #0-0] Running: wry (v0.12.1) on linux [wry 0.12.1 linux #0-0] Session ID:\n81e0107b-4d38-4eed-9b10-ee80ca47bb83 [wry 0.12.1 linux #0-0] [wry 0.12.1 linux\n#0-0] » /test/specs/example.e2e.js [wry 0.12.1 linux #0-0] Hello Tauri [wry\n0.12.1 linux #0-0] ✓ should be cordial [wry 0.12.1 linux #0-0] ✓ should be\nexcited [wry 0.12.1 linux #0-0] ✓ should be easy on the eyes [wry 0.12.1 linux\n#0-0] [wry 0.12.1 linux #0-0] 3 passing (244ms) Spec Files: 1 passed, 1 total\n(100% completed) in 00:00:01 Done in 1.98s. ``` We see the Spec Reporter tell us\nthat all 3 tests from the `test/specs/example.e2e.js` file, along with the final\nreport `Spec Files: 1 passed, 1 total (100% completed) in 00:00:01`. Using the\n[WebdriverIO] test suite, we just easily enabled e2e testing for our Tauri\napplication from just a few lines of configuration and a single command to run\nit! Even better, we didn't have to modify the application at all. [WebdriverIO]:\nhttps://webdriver.io/ [finished example project]:\nhttps://github.com/chippers/hello_tauri [example Application setup]: setup\n[Mocha]: https://mochajs.org/ [suggest reading the documentation]:\nhttps://webdriver.io/docs/configurationfile","url":"https://tauri.studio/docs/guides/webdriver/example/webdriverio"}]